import JSONbigModule from 'json-bigint';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

const JSONbig$1 = JSONbigModule({ useNativeBigInt: true });
/**
 * Helper class to generate query strings.
 */
class Query {
    /**
     * Constructor for Query class.
     *
     * @param {string} method
     * @param {AttributesTypes} attribute
     * @param {QueryTypes} values
     */
    constructor(method, attribute, values) {
        this.method = method;
        this.attribute = attribute;
        if (values !== undefined) {
            if (Array.isArray(values)) {
                this.values = values;
            }
            else {
                this.values = [values];
            }
        }
    }
    /**
     * Convert the query object to a JSON string.
     *
     * @returns {string}
     */
    toString() {
        return JSONbig$1.stringify({
            method: this.method,
            attribute: this.attribute,
            values: this.values,
        });
    }
}
/**
 * Filter resources where attribute is equal to value.
 *
 * @param {string} attribute
 * @param {QueryTypes} value
 * @returns {string}
 */
Query.equal = (attribute, value) => new Query("equal", attribute, value).toString();
/**
 * Filter resources where attribute is not equal to value.
 *
 * @param {string} attribute
 * @param {QueryTypes} value
 * @returns {string}
 */
Query.notEqual = (attribute, value) => new Query("notEqual", attribute, value).toString();
/**
 * Filter resources where attribute matches a regular expression pattern.
 *
 * @param {string} attribute The attribute to filter on.
 * @param {string} pattern The regular expression pattern to match.
 * @returns {string}
 */
Query.regex = (attribute, pattern) => new Query("regex", attribute, pattern).toString();
/**
 * Filter resources where attribute is less than value.
 *
 * @param {string} attribute
 * @param {QueryTypes} value
 * @returns {string}
 */
Query.lessThan = (attribute, value) => new Query("lessThan", attribute, value).toString();
/**
 * Filter resources where attribute is less than or equal to value.
 *
 * @param {string} attribute
 * @param {QueryTypes} value
 * @returns {string}
 */
Query.lessThanEqual = (attribute, value) => new Query("lessThanEqual", attribute, value).toString();
/**
 * Filter resources where attribute is greater than value.
 *
 * @param {string} attribute
 * @param {QueryTypes} value
 * @returns {string}
 */
Query.greaterThan = (attribute, value) => new Query("greaterThan", attribute, value).toString();
/**
 * Filter resources where attribute is greater than or equal to value.
 *
 * @param {string} attribute
 * @param {QueryTypes} value
 * @returns {string}
 */
Query.greaterThanEqual = (attribute, value) => new Query("greaterThanEqual", attribute, value).toString();
/**
 * Filter resources where attribute is null.
 *
 * @param {string} attribute
 * @returns {string}
 */
Query.isNull = (attribute) => new Query("isNull", attribute).toString();
/**
 * Filter resources where attribute is not null.
 *
 * @param {string} attribute
 * @returns {string}
 */
Query.isNotNull = (attribute) => new Query("isNotNull", attribute).toString();
/**
 * Filter resources where the specified attributes exist.
 *
 * @param {string[]} attributes The list of attributes that must exist.
 * @returns {string}
 */
Query.exists = (attributes) => new Query("exists", undefined, attributes).toString();
/**
 * Filter resources where the specified attributes do not exist.
 *
 * @param {string[]} attributes The list of attributes that must not exist.
 * @returns {string}
 */
Query.notExists = (attributes) => new Query("notExists", undefined, attributes).toString();
/**
 * Filter resources where attribute is between start and end (inclusive).
 *
 * @param {string} attribute
 * @param {string | number | bigint} start
 * @param {string | number | bigint} end
 * @returns {string}
 */
Query.between = (attribute, start, end) => new Query("between", attribute, [start, end]).toString();
/**
 * Filter resources where attribute starts with value.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.startsWith = (attribute, value) => new Query("startsWith", attribute, value).toString();
/**
 * Filter resources where attribute ends with value.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.endsWith = (attribute, value) => new Query("endsWith", attribute, value).toString();
/**
 * Specify which attributes should be returned by the API call.
 *
 * @param {string[]} attributes
 * @returns {string}
 */
Query.select = (attributes) => new Query("select", undefined, attributes).toString();
/**
 * Filter resources by searching attribute for value.
 * A fulltext index on attribute is required for this query to work.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.search = (attribute, value) => new Query("search", attribute, value).toString();
/**
 * Sort results by attribute descending.
 *
 * @param {string} attribute
 * @returns {string}
 */
Query.orderDesc = (attribute) => new Query("orderDesc", attribute).toString();
/**
 * Sort results by attribute ascending.
 *
 * @param {string} attribute
 * @returns {string}
 */
Query.orderAsc = (attribute) => new Query("orderAsc", attribute).toString();
/**
 * Sort results randomly.
 *
 * @returns {string}
 */
Query.orderRandom = () => new Query("orderRandom").toString();
/**
 * Return results after documentId.
 *
 * @param {string} documentId
 * @returns {string}
 */
Query.cursorAfter = (documentId) => new Query("cursorAfter", undefined, documentId).toString();
/**
 * Return results before documentId.
 *
 * @param {string} documentId
 * @returns {string}
 */
Query.cursorBefore = (documentId) => new Query("cursorBefore", undefined, documentId).toString();
/**
 * Return only limit results.
 *
 * @param {number} limit
 * @returns {string}
 */
Query.limit = (limit) => new Query("limit", undefined, limit).toString();
/**
 * Filter resources by skipping the first offset results.
 *
 * @param {number} offset
 * @returns {string}
 */
Query.offset = (offset) => new Query("offset", undefined, offset).toString();
/**
 * Filter resources where attribute contains the specified value.
 * For string attributes, checks if the string contains the substring.
 *
 * Note: For array attributes, use {@link containsAny} or {@link containsAll} instead.
 * @param {string} attribute
 * @param {string | string[]} value
 * @returns {string}
 */
Query.contains = (attribute, value) => new Query("contains", attribute, value).toString();
/**
 * Filter resources where attribute contains ANY of the specified values.
 * For array and relationship attributes, matches documents where the attribute
 * contains at least one of the given values.
 *
 * @param {string} attribute
 * @param {any[]} value
 * @returns {string}
 */
Query.containsAny = (attribute, value) => new Query("containsAny", attribute, value).toString();
/**
 * Filter resources where attribute contains ALL of the specified values.
 * For array and relationship attributes, matches documents where the attribute
 * contains every one of the given values.
 *
 * @param {string} attribute
 * @param {any[]} value
 * @returns {string}
 */
Query.containsAll = (attribute, value) => new Query("containsAll", attribute, value).toString();
/**
 * Filter resources where attribute does not contain the specified value.
 *
 * @param {string} attribute
 * @param {string | any[]} value
 * @returns {string}
 */
Query.notContains = (attribute, value) => new Query("notContains", attribute, value).toString();
/**
 * Filter resources by searching attribute for value (inverse of search).
 * A fulltext index on attribute is required for this query to work.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.notSearch = (attribute, value) => new Query("notSearch", attribute, value).toString();
/**
 * Filter resources where attribute is not between start and end (exclusive).
 *
 * @param {string} attribute
 * @param {string | number | bigint} start
 * @param {string | number | bigint} end
 * @returns {string}
 */
Query.notBetween = (attribute, start, end) => new Query("notBetween", attribute, [start, end]).toString();
/**
 * Filter resources where attribute does not start with value.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.notStartsWith = (attribute, value) => new Query("notStartsWith", attribute, value).toString();
/**
 * Filter resources where attribute does not end with value.
 *
 * @param {string} attribute
 * @param {string} value
 * @returns {string}
 */
Query.notEndsWith = (attribute, value) => new Query("notEndsWith", attribute, value).toString();
/**
 * Filter resources where document was created before date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.createdBefore = (value) => Query.lessThan("$createdAt", value);
/**
 * Filter resources where document was created after date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.createdAfter = (value) => Query.greaterThan("$createdAt", value);
/**
 * Filter resources where document was created between dates.
 *
 * @param {string} start
 * @param {string} end
 * @returns {string}
 */
Query.createdBetween = (start, end) => Query.between("$createdAt", start, end);
/**
 * Filter resources where document was updated before date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.updatedBefore = (value) => Query.lessThan("$updatedAt", value);
/**
 * Filter resources where document was updated after date.
 *
 * @param {string} value
 * @returns {string}
 */
Query.updatedAfter = (value) => Query.greaterThan("$updatedAt", value);
/**
 * Filter resources where document was updated between dates.
 *
 * @param {string} start
 * @param {string} end
 * @returns {string}
 */
Query.updatedBetween = (start, end) => Query.between("$updatedAt", start, end);
/**
 * Combine multiple queries using logical OR operator.
 *
 * @param {string[]} queries
 * @returns {string}
 */
Query.or = (queries) => new Query("or", undefined, queries.map((query) => JSONbig$1.parse(query))).toString();
/**
 * Combine multiple queries using logical AND operator.
 *
 * @param {string[]} queries
 * @returns {string}
 */
Query.and = (queries) => new Query("and", undefined, queries.map((query) => JSONbig$1.parse(query))).toString();
/**
 * Filter array elements where at least one element matches all the specified queries.
 *
 * @param {string} attribute The attribute containing the array to filter on.
 * @param {string[]} queries The list of query strings to match against array elements.
 * @returns {string}
 */
Query.elemMatch = (attribute, queries) => new Query("elemMatch", attribute, queries.map((query) => JSONbig$1.parse(query))).toString();
/**
 * Filter resources where attribute is at a specific distance from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceEqual = (attribute, values, distance, meters = true) => new Query("distanceEqual", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute is not at a specific distance from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceNotEqual = (attribute, values, distance, meters = true) => new Query("distanceNotEqual", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceGreaterThan = (attribute, values, distance, meters = true) => new Query("distanceGreaterThan", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute is at a distance less than the specified value from the given coordinates.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @param {number} distance
 * @param {boolean} meters
 * @returns {string}
 */
Query.distanceLessThan = (attribute, values, distance, meters = true) => new Query("distanceLessThan", attribute, [[values, distance, meters]]).toString();
/**
 * Filter resources where attribute intersects with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.intersects = (attribute, values) => new Query("intersects", attribute, [values]).toString();
/**
 * Filter resources where attribute does not intersect with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notIntersects = (attribute, values) => new Query("notIntersects", attribute, [values]).toString();
/**
 * Filter resources where attribute crosses the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.crosses = (attribute, values) => new Query("crosses", attribute, [values]).toString();
/**
 * Filter resources where attribute does not cross the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notCrosses = (attribute, values) => new Query("notCrosses", attribute, [values]).toString();
/**
 * Filter resources where attribute overlaps with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.overlaps = (attribute, values) => new Query("overlaps", attribute, [values]).toString();
/**
 * Filter resources where attribute does not overlap with the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notOverlaps = (attribute, values) => new Query("notOverlaps", attribute, [values]).toString();
/**
 * Filter resources where attribute touches the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.touches = (attribute, values) => new Query("touches", attribute, [values]).toString();
/**
 * Filter resources where attribute does not touch the given geometry.
 *
 * @param {string} attribute
 * @param {any[]} values
 * @returns {string}
 */
Query.notTouches = (attribute, values) => new Query("notTouches", attribute, [values]).toString();

const JSONbigParser = JSONbigModule({ storeAsString: false });
const JSONbigSerializer = JSONbigModule({ useNativeBigInt: true });
const MAX_SAFE = BigInt(Number.MAX_SAFE_INTEGER);
const MIN_SAFE = BigInt(Number.MIN_SAFE_INTEGER);
const MAX_INT64 = BigInt('9223372036854775807');
const MIN_INT64 = BigInt('-9223372036854775808');
function isBigNumber(value) {
    return value !== null
        && typeof value === 'object'
        && value._isBigNumber === true
        && typeof value.isInteger === 'function'
        && typeof value.toFixed === 'function'
        && typeof value.toNumber === 'function';
}
function reviver(_key, value) {
    if (isBigNumber(value)) {
        if (value.isInteger()) {
            const str = value.toFixed();
            const bi = BigInt(str);
            if (bi >= MIN_SAFE && bi <= MAX_SAFE) {
                return Number(str);
            }
            if (bi >= MIN_INT64 && bi <= MAX_INT64) {
                return bi;
            }
            return value.toNumber();
        }
        return value.toNumber();
    }
    return value;
}
const JSONbig = {
    parse: (text) => JSONbigParser.parse(text, reviver),
    stringify: JSONbigSerializer.stringify
};
/**
 * Exception thrown by the  package
 */
class AppwriteException extends Error {
    /**
     * Initializes a Appwrite Exception.
     *
     * @param {string} message - The error message.
     * @param {number} code - The error code. Default is 0.
     * @param {string} type - The error type. Default is an empty string.
     * @param {string} response - The response string. Default is an empty string.
     */
    constructor(message, code = 0, type = '', response = '') {
        super(message);
        this.name = 'AppwriteException';
        this.message = message;
        this.code = code;
        this.type = type;
        this.response = response;
    }
}
/**
 * Client that handles requests to Appwrite
 */
class Client {
    constructor() {
        /**
         * Holds configuration such as project.
         */
        this.config = {
            endpoint: 'https://cloud.appwrite.io/v1',
            endpointRealtime: '',
            project: '',
            key: '',
            jwt: '',
            locale: '',
            mode: '',
            cookie: '',
            platform: '',
            selfSigned: false,
            session: undefined,
        };
        /**
         * Custom headers for API requests.
         */
        this.headers = {
            'x-sdk-name': 'NAME',
            'x-sdk-platform': 'console',
            'x-sdk-language': 'web',
            'x-sdk-version': '0.0.0',
            'X-Appwrite-Response-Format': '1.8.0',
        };
        this.realtime = {
            socket: undefined,
            timeout: undefined,
            heartbeat: undefined,
            url: '',
            channels: new Set(),
            queries: new Set(),
            subscriptions: new Map(),
            slotToSubscriptionId: new Map(),
            subscriptionIdToSlot: new Map(),
            subscriptionsCounter: 0,
            reconnect: true,
            reconnectAttempts: 0,
            lastMessage: undefined,
            connect: () => {
                clearTimeout(this.realtime.timeout);
                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {
                    this.realtime.createSocket();
                }, 50);
            },
            getTimeout: () => {
                switch (true) {
                    case this.realtime.reconnectAttempts < 5:
                        return 1000;
                    case this.realtime.reconnectAttempts < 15:
                        return 5000;
                    case this.realtime.reconnectAttempts < 100:
                        return 10000;
                    default:
                        return 60000;
                }
            },
            createHeartbeat: () => {
                if (this.realtime.heartbeat) {
                    clearTimeout(this.realtime.heartbeat);
                }
                this.realtime.heartbeat = window === null || window === void 0 ? void 0 : window.setInterval(() => {
                    var _a;
                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.send(JSONbig.stringify({
                        type: 'ping'
                    }));
                }, 20000);
            },
            createSocket: () => {
                var _a, _b, _c, _d;
                if (this.realtime.subscriptions.size < 1) {
                    this.realtime.reconnect = false;
                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.close();
                    return;
                }
                const encodedProject = encodeURIComponent((_b = this.config.project) !== null && _b !== void 0 ? _b : '');
                let queryParams = 'project=' + encodedProject;
                this.realtime.channels.forEach(channel => {
                    queryParams += '&channels[]=' + encodeURIComponent(channel);
                });
                // Per-subscription queries: channel[slot][]=query so server can route events by subscription
                const selectAllQuery = Query.select(['*']).toString();
                this.realtime.subscriptions.forEach((sub, slot) => {
                    const queries = sub.queries.length > 0 ? sub.queries : [selectAllQuery];
                    sub.channels.forEach(channel => {
                        queries.forEach(query => {
                            queryParams += '&' + encodeURIComponent(channel) + '[' + slot + '][]=' + encodeURIComponent(query);
                        });
                    });
                });
                const url = this.config.endpointRealtime + '/realtime?' + queryParams;
                if (url !== this.realtime.url || // Check if URL is present
                    !this.realtime.socket || // Check if WebSocket has not been created
                    ((_c = this.realtime.socket) === null || _c === void 0 ? void 0 : _c.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)
                ) {
                    if (this.realtime.socket &&
                        ((_d = this.realtime.socket) === null || _d === void 0 ? void 0 : _d.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)
                    ) {
                        this.realtime.reconnect = false;
                        this.realtime.socket.close();
                    }
                    this.realtime.url = url;
                    this.realtime.socket = new WebSocket(url);
                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);
                    this.realtime.socket.addEventListener('open', _event => {
                        this.realtime.reconnectAttempts = 0;
                        this.realtime.createHeartbeat();
                    });
                    this.realtime.socket.addEventListener('close', event => {
                        var _a, _b, _c;
                        if (!this.realtime.reconnect ||
                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error
                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008
                            )) {
                            this.realtime.reconnect = true;
                            return;
                        }
                        const timeout = this.realtime.getTimeout();
                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);
                        setTimeout(() => {
                            this.realtime.reconnectAttempts++;
                            this.realtime.createSocket();
                        }, timeout);
                    });
                }
            },
            onMessage: (event) => {
                var _a, _b;
                try {
                    const message = JSONbig.parse(event.data);
                    this.realtime.lastMessage = message;
                    switch (message.type) {
                        case 'connected': {
                            const messageData = message.data;
                            if (messageData === null || messageData === void 0 ? void 0 : messageData.subscriptions) {
                                this.realtime.slotToSubscriptionId.clear();
                                this.realtime.subscriptionIdToSlot.clear();
                                for (const [slotStr, subscriptionId] of Object.entries(messageData.subscriptions)) {
                                    const slot = Number(slotStr);
                                    if (!isNaN(slot) && typeof subscriptionId === 'string') {
                                        this.realtime.slotToSubscriptionId.set(slot, subscriptionId);
                                        this.realtime.subscriptionIdToSlot.set(subscriptionId, slot);
                                    }
                                }
                            }
                            let session = this.config.session;
                            if (!session) {
                                const cookie = JSONbig.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');
                                session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];
                            }
                            if (session && !(messageData === null || messageData === void 0 ? void 0 : messageData.user)) {
                                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSONbig.stringify({
                                    type: 'authentication',
                                    data: {
                                        session
                                    }
                                }));
                            }
                            break;
                        }
                        case 'event': {
                            const data = message.data;
                            if (!(data === null || data === void 0 ? void 0 : data.channels))
                                break;
                            const eventSubIds = data.subscriptions;
                            if (eventSubIds && eventSubIds.length > 0) {
                                for (const subscriptionId of eventSubIds) {
                                    const slot = this.realtime.subscriptionIdToSlot.get(subscriptionId);
                                    if (slot !== undefined) {
                                        const subscription = this.realtime.subscriptions.get(slot);
                                        if (subscription) {
                                            setTimeout(() => subscription.callback(data));
                                        }
                                    }
                                }
                            }
                            else {
                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));
                                if (!isSubscribed)
                                    break;
                                this.realtime.subscriptions.forEach(subscription => {
                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {
                                        setTimeout(() => subscription.callback(data));
                                    }
                                });
                            }
                            break;
                        }
                        case 'pong':
                            break; // Handle pong response if needed
                        case 'error':
                            throw message.data;
                        default:
                            break;
                    }
                }
                catch (e) {
                    console.error(e);
                }
            },
            cleanUp: (channels, queries) => {
                this.realtime.channels.forEach(channel => {
                    if (channels.includes(channel)) {
                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {
                            return subscription.channels.includes(channel);
                        });
                        if (!found) {
                            this.realtime.channels.delete(channel);
                        }
                    }
                });
                this.realtime.queries.forEach(query => {
                    if (queries.includes(query)) {
                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {
                            var _a;
                            return (_a = subscription.queries) === null || _a === void 0 ? void 0 : _a.includes(query);
                        });
                        if (!found) {
                            this.realtime.queries.delete(query);
                        }
                    }
                });
            }
        };
    }
    /**
     * Set Endpoint
     *
     * Your project endpoint
     *
     * @param {string} endpoint
     *
     * @returns {this}
     */
    setEndpoint(endpoint) {
        if (!endpoint || typeof endpoint !== 'string') {
            throw new AppwriteException('Endpoint must be a valid string');
        }
        if (!endpoint.startsWith('http://') && !endpoint.startsWith('https://')) {
            throw new AppwriteException('Invalid endpoint URL: ' + endpoint);
        }
        this.config.endpoint = endpoint;
        this.config.endpointRealtime = endpoint.replace('https://', 'wss://').replace('http://', 'ws://');
        return this;
    }
    /**
     * Set Realtime Endpoint
     *
     * @param {string} endpointRealtime
     *
     * @returns {this}
     */
    setEndpointRealtime(endpointRealtime) {
        if (!endpointRealtime || typeof endpointRealtime !== 'string') {
            throw new AppwriteException('Endpoint must be a valid string');
        }
        if (!endpointRealtime.startsWith('ws://') && !endpointRealtime.startsWith('wss://')) {
            throw new AppwriteException('Invalid realtime endpoint URL: ' + endpointRealtime);
        }
        this.config.endpointRealtime = endpointRealtime;
        return this;
    }
    /**
     * Set self-signed
     *
     * @param {boolean} selfSigned
     *
     * @returns {this}
     */
    setSelfSigned(selfSigned) {
        this.config.selfSigned = selfSigned;
        return this;
    }
    /**
     * Set Project
     *
     * Your project ID
     *
     * @param value string
     *
     * @return {this}
     */
    setProject(value) {
        this.headers['X-Appwrite-Project'] = value;
        this.config.project = value;
        return this;
    }
    /**
     * Set Key
     *
     * Your secret API key
     *
     * @param value string
     *
     * @return {this}
     */
    setKey(value) {
        this.headers['X-Appwrite-Key'] = value;
        this.config.key = value;
        return this;
    }
    /**
     * Set JWT
     *
     * Your secret JSON Web Token
     *
     * @param value string
     *
     * @return {this}
     */
    setJWT(value) {
        this.headers['X-Appwrite-JWT'] = value;
        this.config.jwt = value;
        return this;
    }
    /**
     * Set Locale
     *
     * @param value string
     *
     * @return {this}
     */
    setLocale(value) {
        this.headers['X-Appwrite-Locale'] = value;
        this.config.locale = value;
        return this;
    }
    /**
     * Set Mode
     *
     * @param value string
     *
     * @return {this}
     */
    setMode(value) {
        this.headers['X-Appwrite-Mode'] = value;
        this.config.mode = value;
        return this;
    }
    /**
     * Set Cookie
     *
     * The user cookie to authenticate with
     *
     * @param value string
     *
     * @return {this}
     */
    setCookie(value) {
        this.headers['Cookie'] = value;
        this.config.cookie = value;
        return this;
    }
    /**
     * Set Platform
     *
     * The platform type (Appwrite or Imagine)
     *
     * @param value string
     *
     * @return {this}
     */
    setPlatform(value) {
        this.headers['X-Appwrite-Platform'] = value;
        this.config.platform = value;
        return this;
    }
    /**
     * Subscribes to Appwrite events and passes you the payload in realtime.
     *
     * @deprecated Use the Realtime service instead.
     * @see Realtime
     *
     * @param {string|string[]|Channel<any>|ActionableChannel|ResolvedChannel|(Channel<any>|ActionableChannel|ResolvedChannel)[]} channels
     * Channel to subscribe - pass a single channel as a string or Channel builder instance, or multiple with an array.
     *
     * Possible channels are:
     * - account
     * - collections
     * - collections.[ID]
     * - collections.[ID].documents
     * - documents
     * - documents.[ID]
     * - files
     * - files.[ID]
     * - executions
     * - executions.[ID]
     * - functions.[ID]
     * - teams
     * - teams.[ID]
     * - memberships
     * - memberships.[ID]
     *
     * You can also use Channel builders:
     * - Channel.database('db').collection('col').document('doc').create()
     * - Channel.bucket('bucket').file('file').update()
     * - Channel.function('func').execution('exec').delete()
     * - Channel.team('team').create()
     * - Channel.membership('membership').update()
     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.
     * @returns {() => void} Unsubscribes from events.
     */
    subscribe(channels, callback, queries = []) {
        const channelArray = Array.isArray(channels) ? channels : [channels];
        // Convert Channel instances to strings
        const channelStrings = channelArray.map(ch => {
            if (typeof ch === 'string') {
                return ch;
            }
            // All Channel instances have toString() method
            if (ch && typeof ch.toString === 'function') {
                return ch.toString();
            }
            // Fallback to generic string conversion
            return String(ch);
        });
        channelStrings.forEach(channel => this.realtime.channels.add(channel));
        const queryStrings = (queries !== null && queries !== void 0 ? queries : []).map(q => typeof q === 'string' ? q : q.toString());
        queryStrings.forEach(query => this.realtime.queries.add(query));
        const counter = this.realtime.subscriptionsCounter++;
        this.realtime.subscriptions.set(counter, {
            channels: channelStrings,
            queries: queryStrings,
            callback
        });
        this.realtime.connect();
        return () => {
            this.realtime.subscriptions.delete(counter);
            this.realtime.cleanUp(channelStrings, queryStrings);
            this.realtime.connect();
        };
    }
    prepareRequest(method, url, headers = {}, params = {}) {
        method = method.toUpperCase();
        headers = Object.assign({}, this.headers, headers);
        if (typeof window !== 'undefined' && window.localStorage) {
            const cookieFallback = window.localStorage.getItem('cookieFallback');
            if (cookieFallback) {
                headers['X-Fallback-Cookies'] = cookieFallback;
            }
        }
        let options = {
            method,
            headers,
        };
        if (headers['X-Appwrite-Dev-Key'] === undefined) {
            options.credentials = 'include';
        }
        if (method === 'GET') {
            for (const [key, value] of Object.entries(Client.flatten(params))) {
                url.searchParams.append(key, value);
            }
        }
        else {
            switch (headers['content-type']) {
                case 'application/json':
                    options.body = JSONbig.stringify(params);
                    break;
                case 'multipart/form-data':
                    const formData = new FormData();
                    for (const [key, value] of Object.entries(params)) {
                        if (value instanceof File) {
                            formData.append(key, value, value.name);
                        }
                        else if (Array.isArray(value)) {
                            for (const nestedValue of value) {
                                formData.append(`${key}[]`, nestedValue);
                            }
                        }
                        else {
                            formData.append(key, value);
                        }
                    }
                    options.body = formData;
                    delete headers['content-type'];
                    break;
            }
        }
        return { uri: url.toString(), options };
    }
    chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const [fileParam, file] = (_a = Object.entries(originalPayload).find(([_, value]) => value instanceof File)) !== null && _a !== void 0 ? _a : [];
            if (!file || !fileParam) {
                throw new Error('File not found in payload');
            }
            if (file.size <= Client.CHUNK_SIZE) {
                return yield this.call(method, url, headers, originalPayload);
            }
            let start = 0;
            let response = null;
            while (start < file.size) {
                let end = start + Client.CHUNK_SIZE; // Prepare end for the next chunk
                if (end >= file.size) {
                    end = file.size; // Adjust for the last chunk to include the last byte
                }
                headers['content-range'] = `bytes ${start}-${end - 1}/${file.size}`;
                const chunk = file.slice(start, end);
                let payload = Object.assign({}, originalPayload);
                payload[fileParam] = new File([chunk], file.name);
                response = yield this.call(method, url, headers, payload);
                if (onProgress && typeof onProgress === 'function') {
                    onProgress({
                        $id: response.$id,
                        progress: Math.round((end / file.size) * 100),
                        sizeUploaded: end,
                        chunksTotal: Math.ceil(file.size / Client.CHUNK_SIZE),
                        chunksUploaded: Math.ceil(end / Client.CHUNK_SIZE)
                    });
                }
                if (response && response.$id) {
                    headers['x-appwrite-id'] = response.$id;
                }
                start = end;
            }
            return response;
        });
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.call('GET', new URL(this.config.endpoint + '/ping'));
        });
    }
    call(method, url, headers = {}, params = {}, responseType = 'json') {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { uri, options } = this.prepareRequest(method, url, headers, params);
            let data = null;
            const response = yield fetch(uri, options);
            // type opaque: No-CORS, different-origin response (CORS-issue)
            if (response.type === 'opaque') {
                throw new AppwriteException(`Invalid Origin. Register your new client (${window.location.host}) as a new Web platform on your project console dashboard`, 403, "forbidden", "");
            }
            const warnings = response.headers.get('x-appwrite-warning');
            if (warnings) {
                warnings.split(';').forEach((warning) => console.warn('Warning: ' + warning));
            }
            if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {
                data = JSONbig.parse(yield response.text());
            }
            else if (responseType === 'arrayBuffer') {
                data = yield response.arrayBuffer();
            }
            else {
                data = {
                    message: yield response.text()
                };
            }
            if (400 <= response.status) {
                let responseText = '';
                if (((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.includes('application/json')) || responseType === 'arrayBuffer') {
                    responseText = JSONbig.stringify(data);
                }
                else {
                    responseText = data === null || data === void 0 ? void 0 : data.message;
                }
                throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, responseText);
            }
            const cookieFallback = response.headers.get('X-Fallback-Cookies');
            if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {
                window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');
                window.localStorage.setItem('cookieFallback', cookieFallback);
            }
            return data;
        });
    }
    static flatten(data, prefix = '') {
        let output = {};
        for (const [key, value] of Object.entries(data)) {
            let finalKey = prefix ? prefix + '[' + key + ']' : key;
            if (Array.isArray(value)) {
                output = Object.assign(Object.assign({}, output), Client.flatten(value, finalKey));
            }
            else {
                output[finalKey] = value;
            }
        }
        return output;
    }
}
Client.CHUNK_SIZE = 1024 * 1024 * 5;

class Service {
    constructor(client) {
        this.client = client;
    }
    static flatten(data, prefix = '') {
        let output = {};
        for (const [key, value] of Object.entries(data)) {
            let finalKey = prefix ? prefix + '[' + key + ']' : key;
            if (Array.isArray(value)) {
                output = Object.assign(Object.assign({}, output), Service.flatten(value, finalKey));
            }
            else {
                output[finalKey] = value;
            }
        }
        return output;
    }
}
/**
 * The size for chunked uploads in bytes.
 */
Service.CHUNK_SIZE = 5 * 1024 * 1024; // 5MB

class Account {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.User<Preferences>>}
     */
    get() {
        const apiPath = '/account';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                name: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    /**
     * Delete the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise<{}>}
     */
    delete() {
        const apiPath = '/account';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listBillingAddresses(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/account/billing-addresses';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createBillingAddress(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                country: paramsOrFirst,
                city: rest[0],
                streetAddress: rest[1],
                addressLine2: rest[2],
                state: rest[3],
                postalCode: rest[4]
            };
        }
        const country = params.country;
        const city = params.city;
        const streetAddress = params.streetAddress;
        const addressLine2 = params.addressLine2;
        const state = params.state;
        const postalCode = params.postalCode;
        if (typeof country === 'undefined') {
            throw new AppwriteException('Missing required parameter: "country"');
        }
        if (typeof city === 'undefined') {
            throw new AppwriteException('Missing required parameter: "city"');
        }
        if (typeof streetAddress === 'undefined') {
            throw new AppwriteException('Missing required parameter: "streetAddress"');
        }
        const apiPath = '/account/billing-addresses';
        const payload = {};
        if (typeof country !== 'undefined') {
            payload['country'] = country;
        }
        if (typeof city !== 'undefined') {
            payload['city'] = city;
        }
        if (typeof streetAddress !== 'undefined') {
            payload['streetAddress'] = streetAddress;
        }
        if (typeof addressLine2 !== 'undefined') {
            payload['addressLine2'] = addressLine2;
        }
        if (typeof state !== 'undefined') {
            payload['state'] = state;
        }
        if (typeof postalCode !== 'undefined') {
            payload['postalCode'] = postalCode;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getBillingAddress(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                billingAddressId: paramsOrFirst
            };
        }
        const billingAddressId = params.billingAddressId;
        if (typeof billingAddressId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingAddressId"');
        }
        const apiPath = '/account/billing-addresses/{billingAddressId}'.replace('{billingAddressId}', billingAddressId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateBillingAddress(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                billingAddressId: paramsOrFirst,
                country: rest[0],
                city: rest[1],
                streetAddress: rest[2],
                addressLine2: rest[3],
                state: rest[4],
                postalCode: rest[5]
            };
        }
        const billingAddressId = params.billingAddressId;
        const country = params.country;
        const city = params.city;
        const streetAddress = params.streetAddress;
        const addressLine2 = params.addressLine2;
        const state = params.state;
        const postalCode = params.postalCode;
        if (typeof billingAddressId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingAddressId"');
        }
        if (typeof country === 'undefined') {
            throw new AppwriteException('Missing required parameter: "country"');
        }
        if (typeof city === 'undefined') {
            throw new AppwriteException('Missing required parameter: "city"');
        }
        if (typeof streetAddress === 'undefined') {
            throw new AppwriteException('Missing required parameter: "streetAddress"');
        }
        const apiPath = '/account/billing-addresses/{billingAddressId}'.replace('{billingAddressId}', billingAddressId);
        const payload = {};
        if (typeof country !== 'undefined') {
            payload['country'] = country;
        }
        if (typeof city !== 'undefined') {
            payload['city'] = city;
        }
        if (typeof streetAddress !== 'undefined') {
            payload['streetAddress'] = streetAddress;
        }
        if (typeof addressLine2 !== 'undefined') {
            payload['addressLine2'] = addressLine2;
        }
        if (typeof state !== 'undefined') {
            payload['state'] = state;
        }
        if (typeof postalCode !== 'undefined') {
            payload['postalCode'] = postalCode;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteBillingAddress(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                billingAddressId: paramsOrFirst
            };
        }
        const billingAddressId = params.billingAddressId;
        if (typeof billingAddressId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingAddressId"');
        }
        const apiPath = '/account/billing-addresses/{billingAddressId}'.replace('{billingAddressId}', billingAddressId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getCoupon(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                couponId: paramsOrFirst
            };
        }
        const couponId = params.couponId;
        if (typeof couponId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "couponId"');
        }
        const apiPath = '/account/coupons/{couponId}'.replace('{couponId}', couponId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                email: paramsOrFirst,
                password: rest[0]
            };
        }
        const email = params.email;
        const password = params.password;
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/email';
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listIdentities(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                total: rest[0]
            };
        }
        const queries = params.queries;
        const total = params.total;
        const apiPath = '/account/identities';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteIdentity(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                identityId: paramsOrFirst
            };
        }
        const identityId = params.identityId;
        if (typeof identityId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identityId"');
        }
        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listInvoices(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/account/invoices';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createJWT(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                duration: paramsOrFirst
            };
        }
        const duration = params.duration;
        const apiPath = '/account/jwts';
        const payload = {};
        if (typeof duration !== 'undefined') {
            payload['duration'] = duration;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listKeys(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                total: paramsOrFirst
            };
        }
        const total = params.total;
        const apiPath = '/account/keys';
        const payload = {};
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst,
                scopes: rest[0],
                expire: rest[1]
            };
        }
        const name = params.name;
        const scopes = params.scopes;
        const expire = params.expire;
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/account/keys';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getKey(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                keyId: paramsOrFirst
            };
        }
        const keyId = params.keyId;
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/account/keys/{keyId}'.replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                keyId: paramsOrFirst,
                name: rest[0],
                scopes: rest[1],
                expire: rest[2]
            };
        }
        const keyId = params.keyId;
        const name = params.name;
        const scopes = params.scopes;
        const expire = params.expire;
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/account/keys/{keyId}'.replace('{keyId}', keyId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteKey(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                keyId: paramsOrFirst
            };
        }
        const keyId = params.keyId;
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/account/keys/{keyId}'.replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                total: rest[0]
            };
        }
        const queries = params.queries;
        const total = params.total;
        const apiPath = '/account/logs';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateMFA(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                mfa: paramsOrFirst
            };
        }
        const mfa = params.mfa;
        if (typeof mfa === 'undefined') {
            throw new AppwriteException('Missing required parameter: "mfa"');
        }
        const apiPath = '/account/mfa';
        const payload = {};
        if (typeof mfa !== 'undefined') {
            payload['mfa'] = mfa;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createMfaAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('type' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createMFAAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('type' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMfaAuthenticator(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('type' in paramsOrFirst || 'otp' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst,
                otp: rest[0]
            };
        }
        const type = params.type;
        const otp = params.otp;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateMFAAuthenticator(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('type' in paramsOrFirst || 'otp' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst,
                otp: rest[0]
            };
        }
        const type = params.type;
        const otp = params.otp;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteMfaAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('type' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    deleteMFAAuthenticator(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('type' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                type: paramsOrFirst
            };
        }
        const type = params.type;
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createMfaChallenge(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('factor' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                factor: paramsOrFirst
            };
        }
        const factor = params.factor;
        if (typeof factor === 'undefined') {
            throw new AppwriteException('Missing required parameter: "factor"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof factor !== 'undefined') {
            payload['factor'] = factor;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createMFAChallenge(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('factor' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                factor: paramsOrFirst
            };
        }
        const factor = params.factor;
        if (typeof factor === 'undefined') {
            throw new AppwriteException('Missing required parameter: "factor"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof factor !== 'undefined') {
            payload['factor'] = factor;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMfaChallenge(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                challengeId: paramsOrFirst,
                otp: rest[0]
            };
        }
        const challengeId = params.challengeId;
        const otp = params.otp;
        if (typeof challengeId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "challengeId"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof challengeId !== 'undefined') {
            payload['challengeId'] = challengeId;
        }
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateMFAChallenge(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                challengeId: paramsOrFirst,
                otp: rest[0]
            };
        }
        const challengeId = params.challengeId;
        const otp = params.otp;
        if (typeof challengeId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "challengeId"');
        }
        if (typeof otp === 'undefined') {
            throw new AppwriteException('Missing required parameter: "otp"');
        }
        const apiPath = '/account/mfa/challenges';
        const payload = {};
        if (typeof challengeId !== 'undefined') {
            payload['challengeId'] = challengeId;
        }
        if (typeof otp !== 'undefined') {
            payload['otp'] = otp;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    /**
     * List the factors available on the account to be used as a MFA challange.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaFactors>}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.
     */
    listMfaFactors() {
        const apiPath = '/account/mfa/factors';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List the factors available on the account to be used as a MFA challange.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaFactors>}
     */
    listMFAFactors() {
        const apiPath = '/account/mfa/factors';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaRecoveryCodes>}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.
     */
    getMfaRecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaRecoveryCodes>}
     */
    getMFARecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaRecoveryCodes>}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.
     */
    createMfaRecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    /**
     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaRecoveryCodes>}
     */
    createMFARecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    /**
     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaRecoveryCodes>}
     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.
     */
    updateMfaRecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    /**
     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.MfaRecoveryCodes>}
     */
    updateMFARecoveryCodes() {
        const apiPath = '/account/mfa/recovery-codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateName(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst
            };
        }
        const name = params.name;
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/account/name';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePassword(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                password: paramsOrFirst,
                oldPassword: rest[0]
            };
        }
        const password = params.password;
        const oldPassword = params.oldPassword;
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/password';
        const payload = {};
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof oldPassword !== 'undefined') {
            payload['oldPassword'] = oldPassword;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listPaymentMethods(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/account/payment-methods';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Create a new payment method for the current user account.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.PaymentMethod>}
     */
    createPaymentMethod() {
        const apiPath = '/account/payment-methods';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPaymentMethod(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                paymentMethodId: paramsOrFirst
            };
        }
        const paymentMethodId = params.paymentMethodId;
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/account/payment-methods/{paymentMethodId}'.replace('{paymentMethodId}', paymentMethodId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePaymentMethod(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                paymentMethodId: paramsOrFirst,
                expiryMonth: rest[0],
                expiryYear: rest[1],
                state: rest[2]
            };
        }
        const paymentMethodId = params.paymentMethodId;
        const expiryMonth = params.expiryMonth;
        const expiryYear = params.expiryYear;
        const state = params.state;
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        if (typeof expiryMonth === 'undefined') {
            throw new AppwriteException('Missing required parameter: "expiryMonth"');
        }
        if (typeof expiryYear === 'undefined') {
            throw new AppwriteException('Missing required parameter: "expiryYear"');
        }
        const apiPath = '/account/payment-methods/{paymentMethodId}'.replace('{paymentMethodId}', paymentMethodId);
        const payload = {};
        if (typeof expiryMonth !== 'undefined') {
            payload['expiryMonth'] = expiryMonth;
        }
        if (typeof expiryYear !== 'undefined') {
            payload['expiryYear'] = expiryYear;
        }
        if (typeof state !== 'undefined') {
            payload['state'] = state;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deletePaymentMethod(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                paymentMethodId: paramsOrFirst
            };
        }
        const paymentMethodId = params.paymentMethodId;
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/account/payment-methods/{paymentMethodId}'.replace('{paymentMethodId}', paymentMethodId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updatePaymentMethodProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                paymentMethodId: paramsOrFirst,
                providerMethodId: rest[0],
                name: rest[1],
                state: rest[2]
            };
        }
        const paymentMethodId = params.paymentMethodId;
        const providerMethodId = params.providerMethodId;
        const name = params.name;
        const state = params.state;
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        if (typeof providerMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerMethodId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/account/payment-methods/{paymentMethodId}/provider'.replace('{paymentMethodId}', paymentMethodId);
        const payload = {};
        if (typeof providerMethodId !== 'undefined') {
            payload['providerMethodId'] = providerMethodId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof state !== 'undefined') {
            payload['state'] = state;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePaymentMethodMandateOptions(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                paymentMethodId: paramsOrFirst
            };
        }
        const paymentMethodId = params.paymentMethodId;
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/account/payment-methods/{paymentMethodId}/setup'.replace('{paymentMethodId}', paymentMethodId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePhone(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                phone: paramsOrFirst,
                password: rest[0]
            };
        }
        const phone = params.phone;
        const password = params.password;
        if (typeof phone === 'undefined') {
            throw new AppwriteException('Missing required parameter: "phone"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/phone';
        const payload = {};
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    /**
     * Get the preferences as a key-value object for the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Preferences>}
     */
    getPrefs() {
        const apiPath = '/account/prefs';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePrefs(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('prefs' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                prefs: paramsOrFirst
            };
        }
        const prefs = params.prefs;
        if (typeof prefs === 'undefined') {
            throw new AppwriteException('Missing required parameter: "prefs"');
        }
        const apiPath = '/account/prefs';
        const payload = {};
        if (typeof prefs !== 'undefined') {
            payload['prefs'] = prefs;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createRecovery(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                email: paramsOrFirst,
                url: rest[0]
            };
        }
        const email = params.email;
        const url = params.url;
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/account/recovery';
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecovery(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0],
                password: rest[1]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        const password = params.password;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/recovery';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    /**
     * Get the list of active sessions across different devices for the currently logged in user.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.SessionList>}
     */
    listSessions() {
        const apiPath = '/account/sessions';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Delete all sessions from the user account and remove any sessions cookies from the end client.
     *
     * @throws {AppwriteException}
     * @returns {Promise<{}>}
     */
    deleteSessions() {
        const apiPath = '/account/sessions';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    /**
     * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.Session>}
     */
    createAnonymousSession() {
        const apiPath = '/account/sessions/anonymous';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createEmailPasswordSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                email: paramsOrFirst,
                password: rest[0]
            };
        }
        const email = params.email;
        const password = params.password;
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/account/sessions/email';
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMagicURLSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/sessions/magic-url';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createOAuth2Session(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('provider' in paramsOrFirst || 'success' in paramsOrFirst || 'failure' in paramsOrFirst || 'scopes' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                provider: paramsOrFirst,
                success: rest[0],
                failure: rest[1],
                scopes: rest[2]
            };
        }
        const provider = params.provider;
        const success = params.success;
        const failure = params.failure;
        const scopes = params.scopes;
        if (typeof provider === 'undefined') {
            throw new AppwriteException('Missing required parameter: "provider"');
        }
        const apiPath = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);
        const payload = {};
        if (typeof success !== 'undefined') {
            payload['success'] = success;
        }
        if (typeof failure !== 'undefined') {
            payload['failure'] = failure;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {
            window.location.href = uri.toString();
            return;
        }
        else {
            return uri.toString();
        }
    }
    updatePhoneSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/sessions/phone';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/sessions/token';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                sessionId: paramsOrFirst
            };
        }
        const sessionId = params.sessionId;
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                sessionId: paramsOrFirst
            };
        }
        const sessionId = params.sessionId;
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                sessionId: paramsOrFirst
            };
        }
        const sessionId = params.sessionId;
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    /**
     * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.User<Preferences>>}
     */
    updateStatus() {
        const apiPath = '/account/status';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createPushTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                targetId: paramsOrFirst,
                identifier: rest[0],
                providerId: rest[1]
            };
        }
        const targetId = params.targetId;
        const identifier = params.identifier;
        const providerId = params.providerId;
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        if (typeof identifier === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identifier"');
        }
        const apiPath = '/account/targets/push';
        const payload = {};
        if (typeof targetId !== 'undefined') {
            payload['targetId'] = targetId;
        }
        if (typeof identifier !== 'undefined') {
            payload['identifier'] = identifier;
        }
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePushTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                targetId: paramsOrFirst,
                identifier: rest[0]
            };
        }
        const targetId = params.targetId;
        const identifier = params.identifier;
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        if (typeof identifier === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identifier"');
        }
        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);
        const payload = {};
        if (typeof identifier !== 'undefined') {
            payload['identifier'] = identifier;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deletePushTarget(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                targetId: paramsOrFirst
            };
        }
        const targetId = params.targetId;
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createEmailToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                phrase: rest[1]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const phrase = params.phrase;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        const apiPath = '/account/tokens/email';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof phrase !== 'undefined') {
            payload['phrase'] = phrase;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createMagicURLToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                url: rest[1],
                phrase: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const url = params.url;
        const phrase = params.phrase;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        const apiPath = '/account/tokens/magic-url';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof phrase !== 'undefined') {
            payload['phrase'] = phrase;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createOAuth2Token(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('provider' in paramsOrFirst || 'success' in paramsOrFirst || 'failure' in paramsOrFirst || 'scopes' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                provider: paramsOrFirst,
                success: rest[0],
                failure: rest[1],
                scopes: rest[2]
            };
        }
        const provider = params.provider;
        const success = params.success;
        const failure = params.failure;
        const scopes = params.scopes;
        if (typeof provider === 'undefined') {
            throw new AppwriteException('Missing required parameter: "provider"');
        }
        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);
        const payload = {};
        if (typeof success !== 'undefined') {
            payload['success'] = success;
        }
        if (typeof failure !== 'undefined') {
            payload['failure'] = failure;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {
            window.location.href = uri.toString();
            return;
        }
        else {
            return uri.toString();
        }
    }
    createPhoneToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                phone: rest[0]
            };
        }
        const userId = params.userId;
        const phone = params.phone;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof phone === 'undefined') {
            throw new AppwriteException('Missing required parameter: "phone"');
        }
        const apiPath = '/account/tokens/phone';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createEmailVerification(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst
            };
        }
        const url = params.url;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createVerification(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst
            };
        }
        const url = params.url;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEmailVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/verifications/email';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    /**
     * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.Token>}
     */
    createPhoneVerification() {
        const apiPath = '/account/verifications/phone';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePhoneVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                secret: rest[0]
            };
        }
        const userId = params.userId;
        const secret = params.secret;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/account/verifications/phone';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
}

class Activities {
    constructor(client) {
        this.client = client;
    }
    listEvents(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/activities/events';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getEvent(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                eventId: paramsOrFirst
            };
        }
        const eventId = params.eventId;
        if (typeof eventId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "eventId"');
        }
        const apiPath = '/activities/events/{eventId}'.replace('{eventId}', eventId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Avatars {
    constructor(client) {
        this.client = client;
    }
    getBrowser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('code' in paramsOrFirst || 'width' in paramsOrFirst || 'height' in paramsOrFirst || 'quality' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                code: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                quality: rest[2]
            };
        }
        const code = params.code;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getCreditCard(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('code' in paramsOrFirst || 'width' in paramsOrFirst || 'height' in paramsOrFirst || 'quality' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                code: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                quality: rest[2]
            };
        }
        const code = params.code;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getFavicon(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst
            };
        }
        const url = params.url;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/avatars/favicon';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getFlag(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('code' in paramsOrFirst || 'width' in paramsOrFirst || 'height' in paramsOrFirst || 'quality' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                code: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                quality: rest[2]
            };
        }
        const code = params.code;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getImage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst,
                width: rest[0],
                height: rest[1]
            };
        }
        const url = params.url;
        const width = params.width;
        const height = params.height;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/avatars/image';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getInitials(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst,
                width: rest[0],
                height: rest[1],
                background: rest[2]
            };
        }
        const name = params.name;
        const width = params.width;
        const height = params.height;
        const background = params.background;
        const apiPath = '/avatars/initials';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof background !== 'undefined') {
            payload['background'] = background;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getQR(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                text: paramsOrFirst,
                size: rest[0],
                margin: rest[1],
                download: rest[2]
            };
        }
        const text = params.text;
        const size = params.size;
        const margin = params.margin;
        const download = params.download;
        if (typeof text === 'undefined') {
            throw new AppwriteException('Missing required parameter: "text"');
        }
        const apiPath = '/avatars/qr';
        const payload = {};
        if (typeof text !== 'undefined') {
            payload['text'] = text;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof margin !== 'undefined') {
            payload['margin'] = margin;
        }
        if (typeof download !== 'undefined') {
            payload['download'] = download;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getScreenshot(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                url: paramsOrFirst,
                headers: rest[0],
                viewportWidth: rest[1],
                viewportHeight: rest[2],
                scale: rest[3],
                theme: rest[4],
                userAgent: rest[5],
                fullpage: rest[6],
                locale: rest[7],
                timezone: rest[8],
                latitude: rest[9],
                longitude: rest[10],
                accuracy: rest[11],
                touch: rest[12],
                permissions: rest[13],
                sleep: rest[14],
                width: rest[15],
                height: rest[16],
                quality: rest[17],
                output: rest[18]
            };
        }
        const url = params.url;
        const headers = params.headers;
        const viewportWidth = params.viewportWidth;
        const viewportHeight = params.viewportHeight;
        const scale = params.scale;
        const theme = params.theme;
        const userAgent = params.userAgent;
        const fullpage = params.fullpage;
        const locale = params.locale;
        const timezone = params.timezone;
        const latitude = params.latitude;
        const longitude = params.longitude;
        const accuracy = params.accuracy;
        const touch = params.touch;
        const permissions = params.permissions;
        const sleep = params.sleep;
        const width = params.width;
        const height = params.height;
        const quality = params.quality;
        const output = params.output;
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        const apiPath = '/avatars/screenshots';
        const payload = {};
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof headers !== 'undefined') {
            payload['headers'] = headers;
        }
        if (typeof viewportWidth !== 'undefined') {
            payload['viewportWidth'] = viewportWidth;
        }
        if (typeof viewportHeight !== 'undefined') {
            payload['viewportHeight'] = viewportHeight;
        }
        if (typeof scale !== 'undefined') {
            payload['scale'] = scale;
        }
        if (typeof theme !== 'undefined') {
            payload['theme'] = theme;
        }
        if (typeof userAgent !== 'undefined') {
            payload['userAgent'] = userAgent;
        }
        if (typeof fullpage !== 'undefined') {
            payload['fullpage'] = fullpage;
        }
        if (typeof locale !== 'undefined') {
            payload['locale'] = locale;
        }
        if (typeof timezone !== 'undefined') {
            payload['timezone'] = timezone;
        }
        if (typeof latitude !== 'undefined') {
            payload['latitude'] = latitude;
        }
        if (typeof longitude !== 'undefined') {
            payload['longitude'] = longitude;
        }
        if (typeof accuracy !== 'undefined') {
            payload['accuracy'] = accuracy;
        }
        if (typeof touch !== 'undefined') {
            payload['touch'] = touch;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof sleep !== 'undefined') {
            payload['sleep'] = sleep;
        }
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        if (typeof output !== 'undefined') {
            payload['output'] = output;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
}

class Backups {
    constructor(client) {
        this.client = client;
    }
    listArchives(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/backups/archives';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createArchive(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('services' in paramsOrFirst || 'resourceId' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                services: paramsOrFirst,
                resourceId: rest[0]
            };
        }
        const services = params.services;
        const resourceId = params.resourceId;
        if (typeof services === 'undefined') {
            throw new AppwriteException('Missing required parameter: "services"');
        }
        const apiPath = '/backups/archives';
        const payload = {};
        if (typeof services !== 'undefined') {
            payload['services'] = services;
        }
        if (typeof resourceId !== 'undefined') {
            payload['resourceId'] = resourceId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getArchive(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                archiveId: paramsOrFirst
            };
        }
        const archiveId = params.archiveId;
        if (typeof archiveId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "archiveId"');
        }
        const apiPath = '/backups/archives/{archiveId}'.replace('{archiveId}', archiveId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteArchive(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                archiveId: paramsOrFirst
            };
        }
        const archiveId = params.archiveId;
        if (typeof archiveId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "archiveId"');
        }
        const apiPath = '/backups/archives/{archiveId}'.replace('{archiveId}', archiveId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listPolicies(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/backups/policies';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPolicy(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                policyId: paramsOrFirst,
                services: rest[0],
                retention: rest[1],
                schedule: rest[2],
                name: rest[3],
                resourceId: rest[4],
                enabled: rest[5]
            };
        }
        const policyId = params.policyId;
        const services = params.services;
        const retention = params.retention;
        const schedule = params.schedule;
        const name = params.name;
        const resourceId = params.resourceId;
        const enabled = params.enabled;
        if (typeof policyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "policyId"');
        }
        if (typeof services === 'undefined') {
            throw new AppwriteException('Missing required parameter: "services"');
        }
        if (typeof retention === 'undefined') {
            throw new AppwriteException('Missing required parameter: "retention"');
        }
        if (typeof schedule === 'undefined') {
            throw new AppwriteException('Missing required parameter: "schedule"');
        }
        const apiPath = '/backups/policies';
        const payload = {};
        if (typeof policyId !== 'undefined') {
            payload['policyId'] = policyId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof services !== 'undefined') {
            payload['services'] = services;
        }
        if (typeof resourceId !== 'undefined') {
            payload['resourceId'] = resourceId;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof retention !== 'undefined') {
            payload['retention'] = retention;
        }
        if (typeof schedule !== 'undefined') {
            payload['schedule'] = schedule;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPolicy(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                policyId: paramsOrFirst
            };
        }
        const policyId = params.policyId;
        if (typeof policyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "policyId"');
        }
        const apiPath = '/backups/policies/{policyId}'.replace('{policyId}', policyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePolicy(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                policyId: paramsOrFirst,
                name: rest[0],
                retention: rest[1],
                schedule: rest[2],
                enabled: rest[3]
            };
        }
        const policyId = params.policyId;
        const name = params.name;
        const retention = params.retention;
        const schedule = params.schedule;
        const enabled = params.enabled;
        if (typeof policyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "policyId"');
        }
        const apiPath = '/backups/policies/{policyId}'.replace('{policyId}', policyId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof retention !== 'undefined') {
            payload['retention'] = retention;
        }
        if (typeof schedule !== 'undefined') {
            payload['schedule'] = schedule;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deletePolicy(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                policyId: paramsOrFirst
            };
        }
        const policyId = params.policyId;
        if (typeof policyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "policyId"');
        }
        const apiPath = '/backups/policies/{policyId}'.replace('{policyId}', policyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createRestoration(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                archiveId: paramsOrFirst,
                services: rest[0],
                newResourceId: rest[1],
                newResourceName: rest[2]
            };
        }
        const archiveId = params.archiveId;
        const services = params.services;
        const newResourceId = params.newResourceId;
        const newResourceName = params.newResourceName;
        if (typeof archiveId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "archiveId"');
        }
        if (typeof services === 'undefined') {
            throw new AppwriteException('Missing required parameter: "services"');
        }
        const apiPath = '/backups/restoration';
        const payload = {};
        if (typeof archiveId !== 'undefined') {
            payload['archiveId'] = archiveId;
        }
        if (typeof services !== 'undefined') {
            payload['services'] = services;
        }
        if (typeof newResourceId !== 'undefined') {
            payload['newResourceId'] = newResourceId;
        }
        if (typeof newResourceName !== 'undefined') {
            payload['newResourceName'] = newResourceName;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listRestorations(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/backups/restorations';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getRestoration(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                restorationId: paramsOrFirst
            };
        }
        const restorationId = params.restorationId;
        if (typeof restorationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "restorationId"');
        }
        const apiPath = '/backups/restorations/{restorationId}'.replace('{restorationId}', restorationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Assistant {
    constructor(client) {
        this.client = client;
    }
    chat(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                prompt: paramsOrFirst
            };
        }
        const prompt = params.prompt;
        if (typeof prompt === 'undefined') {
            throw new AppwriteException('Missing required parameter: "prompt"');
        }
        const apiPath = '/console/assistant';
        const payload = {};
        if (typeof prompt !== 'undefined') {
            payload['prompt'] = prompt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
}

class Console {
    constructor(client) {
        this.client = client;
    }
    getCampaign(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                campaignId: paramsOrFirst
            };
        }
        const campaignId = params.campaignId;
        if (typeof campaignId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "campaignId"');
        }
        const apiPath = '/console/campaigns/{campaignId}'.replace('{campaignId}', campaignId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getCoupon(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                couponId: paramsOrFirst
            };
        }
        const couponId = params.couponId;
        if (typeof couponId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "couponId"');
        }
        const apiPath = '/console/coupons/{couponId}'.replace('{couponId}', couponId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getPlans(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('platform' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                platform: paramsOrFirst
            };
        }
        const platform = params.platform;
        const apiPath = '/console/plans';
        const payload = {};
        if (typeof platform !== 'undefined') {
            payload['platform'] = platform;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getPlan(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                planId: paramsOrFirst
            };
        }
        const planId = params.planId;
        if (typeof planId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "planId"');
        }
        const apiPath = '/console/plans/{planId}'.replace('{planId}', planId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getProgram(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                programId: paramsOrFirst
            };
        }
        const programId = params.programId;
        if (typeof programId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "programId"');
        }
        const apiPath = '/console/programs/{programId}'.replace('{programId}', programId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createProgramMembership(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                programId: paramsOrFirst
            };
        }
        const programId = params.programId;
        if (typeof programId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "programId"');
        }
        const apiPath = '/console/programs/{programId}/memberships'.replace('{programId}', programId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    /**
     * Get all available regions for the console.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.ConsoleRegionList>}
     */
    listRegions() {
        const apiPath = '/console/regions';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getResource(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                value: paramsOrFirst,
                type: rest[0]
            };
        }
        const value = params.value;
        const type = params.type;
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/console/resources';
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createSource(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ref: paramsOrFirst,
                referrer: rest[0],
                utmSource: rest[1],
                utmCampaign: rest[2],
                utmMedium: rest[3]
            };
        }
        const ref = params.ref;
        const referrer = params.referrer;
        const utmSource = params.utmSource;
        const utmCampaign = params.utmCampaign;
        const utmMedium = params.utmMedium;
        const apiPath = '/console/sources';
        const payload = {};
        if (typeof ref !== 'undefined') {
            payload['ref'] = ref;
        }
        if (typeof referrer !== 'undefined') {
            payload['referrer'] = referrer;
        }
        if (typeof utmSource !== 'undefined') {
            payload['utmSource'] = utmSource;
        }
        if (typeof utmCampaign !== 'undefined') {
            payload['utmCampaign'] = utmCampaign;
        }
        if (typeof utmMedium !== 'undefined') {
            payload['utmMedium'] = utmMedium;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    suggestColumns(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                context: rest[1],
                min: rest[2],
                max: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const context = params.context;
        const min = params.min;
        const max = params.max;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/console/suggestions/columns';
        const payload = {};
        if (typeof databaseId !== 'undefined') {
            payload['databaseId'] = databaseId;
        }
        if (typeof tableId !== 'undefined') {
            payload['tableId'] = tableId;
        }
        if (typeof context !== 'undefined') {
            payload['context'] = context;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    suggestIndexes(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                min: rest[1],
                max: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const min = params.min;
        const max = params.max;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/console/suggestions/indexes';
        const payload = {};
        if (typeof databaseId !== 'undefined') {
            payload['databaseId'] = databaseId;
        }
        if (typeof tableId !== 'undefined') {
            payload['tableId'] = tableId;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Get all Environment Variables that are relevant for the console.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.ConsoleVariables>}
     */
    variables() {
        const apiPath = '/console/variables';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Databases {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/databases';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const name = params.name;
        const enabled = params.enabled;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/databases';
        const payload = {};
        if (typeof databaseId !== 'undefined') {
            payload['databaseId'] = databaseId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listTransactions(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/databases/transactions';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createTransaction(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ttl: paramsOrFirst
            };
        }
        const ttl = params.ttl;
        const apiPath = '/databases/transactions';
        const payload = {};
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateTransaction(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                commit: rest[0],
                rollback: rest[1]
            };
        }
        const transactionId = params.transactionId;
        const commit = params.commit;
        const rollback = params.rollback;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof commit !== 'undefined') {
            payload['commit'] = commit;
        }
        if (typeof rollback !== 'undefined') {
            payload['rollback'] = rollback;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createOperations(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                operations: rest[0]
            };
        }
        const transactionId = params.transactionId;
        const operations = params.operations;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/databases/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof operations !== 'undefined') {
            payload['operations'] = operations;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('range' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                range: paramsOrFirst
            };
        }
        const range = params.range;
        const apiPath = '/databases/usage';
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst
            };
        }
        const databaseId = params.databaseId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const name = params.name;
        const enabled = params.enabled;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst
            };
        }
        const databaseId = params.databaseId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/databases/{databaseId}'.replace('{databaseId}', databaseId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listCollections(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/databases/{databaseId}/collections'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createCollection(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                name: rest[1],
                permissions: rest[2],
                documentSecurity: rest[3],
                enabled: rest[4],
                attributes: rest[5],
                indexes: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const name = params.name;
        const permissions = params.permissions;
        const documentSecurity = params.documentSecurity;
        const enabled = params.enabled;
        const attributes = params.attributes;
        const indexes = params.indexes;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/databases/{databaseId}/collections'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof collectionId !== 'undefined') {
            payload['collectionId'] = collectionId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof documentSecurity !== 'undefined') {
            payload['documentSecurity'] = documentSecurity;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof attributes !== 'undefined') {
            payload['attributes'] = attributes;
        }
        if (typeof indexes !== 'undefined') {
            payload['indexes'] = indexes;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getCollection(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateCollection(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                name: rest[1],
                permissions: rest[2],
                documentSecurity: rest[3],
                enabled: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const name = params.name;
        const permissions = params.permissions;
        const documentSecurity = params.documentSecurity;
        const enabled = params.enabled;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof documentSecurity !== 'undefined') {
            payload['documentSecurity'] = documentSecurity;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteCollection(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listAttributes(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                queries: rest[1],
                total: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const queries = params.queries;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createBooleanAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/boolean'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateBooleanAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/boolean/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createDatetimeAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/datetime'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateDatetimeAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/datetime/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createEmailAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/email'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEmailAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/email/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createEnumAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                elements: rest[2],
                required: rest[3],
                xdefault: rest[4],
                array: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const elements = params.elements;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof elements === 'undefined') {
            throw new AppwriteException('Missing required parameter: "elements"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/enum'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof elements !== 'undefined') {
            payload['elements'] = elements;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEnumAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                elements: rest[2],
                required: rest[3],
                xdefault: rest[4],
                newKey: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const elements = params.elements;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof elements === 'undefined') {
            throw new AppwriteException('Missing required parameter: "elements"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/enum/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof elements !== 'undefined') {
            payload['elements'] = elements;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createFloatAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                min: rest[3],
                max: rest[4],
                xdefault: rest[5],
                array: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const min = params.min;
        const max = params.max;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/float'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateFloatAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                min: rest[4],
                max: rest[5],
                newKey: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const min = params.min;
        const max = params.max;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/float/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createIntegerAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                min: rest[3],
                max: rest[4],
                xdefault: rest[5],
                array: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const min = params.min;
        const max = params.max;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/integer'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateIntegerAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                min: rest[4],
                max: rest[5],
                newKey: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const min = params.min;
        const max = params.max;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/integer/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createIpAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/ip'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateIpAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/ip/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createLineAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/line'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateLineAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/line/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createLongtextAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4],
                encrypt: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/longtext'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateLongtextAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/longtext/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createMediumtextAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4],
                encrypt: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/mediumtext'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMediumtextAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/mediumtext/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createPointAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/point'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePointAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/point/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createPolygonAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/polygon'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePolygonAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/polygon/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createRelationshipAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                relatedCollectionId: rest[1],
                type: rest[2],
                twoWay: rest[3],
                key: rest[4],
                twoWayKey: rest[5],
                onDelete: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const relatedCollectionId = params.relatedCollectionId;
        const type = params.type;
        const twoWay = params.twoWay;
        const key = params.key;
        const twoWayKey = params.twoWayKey;
        const onDelete = params.onDelete;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof relatedCollectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "relatedCollectionId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/relationship'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof relatedCollectionId !== 'undefined') {
            payload['relatedCollectionId'] = relatedCollectionId;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof twoWay !== 'undefined') {
            payload['twoWay'] = twoWay;
        }
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof twoWayKey !== 'undefined') {
            payload['twoWayKey'] = twoWayKey;
        }
        if (typeof onDelete !== 'undefined') {
            payload['onDelete'] = onDelete;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createStringAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                size: rest[2],
                required: rest[3],
                xdefault: rest[4],
                array: rest[5],
                encrypt: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const size = params.size;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof size === 'undefined') {
            throw new AppwriteException('Missing required parameter: "size"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/string'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateStringAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                size: rest[4],
                newKey: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const size = params.size;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/string/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createTextAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4],
                encrypt: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/text'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateTextAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/text/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createUrlAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/url'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateUrlAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/url/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createVarcharAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                size: rest[2],
                required: rest[3],
                xdefault: rest[4],
                array: rest[5],
                encrypt: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const size = params.size;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof size === 'undefined') {
            throw new AppwriteException('Missing required parameter: "size"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/varchar'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateVarcharAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                size: rest[4],
                newKey: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const size = params.size;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/varchar/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateRelationshipAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                onDelete: rest[2],
                newKey: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const onDelete = params.onDelete;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/attributes/{key}/relationship'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        if (typeof onDelete !== 'undefined') {
            payload['onDelete'] = onDelete;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listDocuments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                queries: rest[1],
                transactionId: rest[2],
                total: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof data === 'undefined') {
            throw new AppwriteException('Missing required parameter: "data"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof documentId !== 'undefined') {
            payload['documentId'] = documentId;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createDocuments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documents: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documents = params.documents;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documents === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documents"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof documents !== 'undefined') {
            payload['documents'] = documents;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    upsertDocuments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documents: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documents = params.documents;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documents === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documents"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof documents !== 'undefined') {
            payload['documents'] = documents;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateDocuments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                data: rest[1],
                queries: rest[2],
                transactionId: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const data = params.data;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteDocuments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                queries: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                queries: rest[2],
                transactionId: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    upsertDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteDocument(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listDocumentLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                queries: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const queries = params.queries;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/logs'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    decrementDocumentAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                attribute: rest[2],
                value: rest[3],
                min: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const attribute = params.attribute;
        const value = params.value;
        const min = params.min;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof attribute === 'undefined') {
            throw new AppwriteException('Missing required parameter: "attribute"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    incrementDocumentAttribute(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                documentId: rest[1],
                attribute: rest[2],
                value: rest[3],
                max: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const documentId = params.documentId;
        const attribute = params.attribute;
        const value = params.value;
        const max = params.max;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof documentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "documentId"');
        }
        if (typeof attribute === 'undefined') {
            throw new AppwriteException('Missing required parameter: "attribute"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listIndexes(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                queries: rest[1],
                total: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const queries = params.queries;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createIndex(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1],
                type: rest[2],
                attributes: rest[3],
                orders: rest[4],
                lengths: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        const type = params.type;
        const attributes = params.attributes;
        const orders = params.orders;
        const lengths = params.lengths;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof attributes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "attributes"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof attributes !== 'undefined') {
            payload['attributes'] = attributes;
        }
        if (typeof orders !== 'undefined') {
            payload['orders'] = orders;
        }
        if (typeof lengths !== 'undefined') {
            payload['lengths'] = lengths;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getIndex(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteIndex(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listCollectionLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                queries: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const queries = params.queries;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/logs'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getCollectionUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                collectionId: rest[0],
                range: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const collectionId = params.collectionId;
        const range = params.range;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof collectionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "collectionId"');
        }
        const apiPath = '/databases/{databaseId}/collections/{collectionId}/usage'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                queries: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const queries = params.queries;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/databases/{databaseId}/logs'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                range: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const range = params.range;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/databases/{databaseId}/usage'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Domains {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const apiPath = '/domains';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                domain: rest[0]
            };
        }
        const teamId = params.teamId;
        const domain = params.domain;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        const apiPath = '/domains';
        const payload = {};
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPrice(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst,
                periodYears: rest[0],
                registrationType: rest[1]
            };
        }
        const domain = params.domain;
        const periodYears = params.periodYears;
        const registrationType = params.registrationType;
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        const apiPath = '/domains/price';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof periodYears !== 'undefined') {
            payload['periodYears'] = periodYears;
        }
        if (typeof registrationType !== 'undefined') {
            payload['registrationType'] = registrationType;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPurchase(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst,
                teamId: rest[0],
                firstName: rest[1],
                lastName: rest[2],
                email: rest[3],
                phone: rest[4],
                billingAddressId: rest[5],
                paymentMethodId: rest[6],
                addressLine3: rest[7],
                companyName: rest[8],
                periodYears: rest[9]
            };
        }
        const domain = params.domain;
        const teamId = params.teamId;
        const firstName = params.firstName;
        const lastName = params.lastName;
        const email = params.email;
        const phone = params.phone;
        const billingAddressId = params.billingAddressId;
        const paymentMethodId = params.paymentMethodId;
        const addressLine3 = params.addressLine3;
        const companyName = params.companyName;
        const periodYears = params.periodYears;
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof firstName === 'undefined') {
            throw new AppwriteException('Missing required parameter: "firstName"');
        }
        if (typeof lastName === 'undefined') {
            throw new AppwriteException('Missing required parameter: "lastName"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof phone === 'undefined') {
            throw new AppwriteException('Missing required parameter: "phone"');
        }
        if (typeof billingAddressId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingAddressId"');
        }
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/domains/purchases';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof firstName !== 'undefined') {
            payload['firstName'] = firstName;
        }
        if (typeof lastName !== 'undefined') {
            payload['lastName'] = lastName;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        if (typeof billingAddressId !== 'undefined') {
            payload['billingAddressId'] = billingAddressId;
        }
        if (typeof addressLine3 !== 'undefined') {
            payload['addressLine3'] = addressLine3;
        }
        if (typeof companyName !== 'undefined') {
            payload['companyName'] = companyName;
        }
        if (typeof periodYears !== 'undefined') {
            payload['periodYears'] = periodYears;
        }
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listSuggestions(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                query: paramsOrFirst,
                tlds: rest[0],
                limit: rest[1],
                filterType: rest[2],
                priceMax: rest[3],
                priceMin: rest[4]
            };
        }
        const query = params.query;
        const tlds = params.tlds;
        const limit = params.limit;
        const filterType = params.filterType;
        const priceMax = params.priceMax;
        const priceMin = params.priceMin;
        if (typeof query === 'undefined') {
            throw new AppwriteException('Missing required parameter: "query"');
        }
        const apiPath = '/domains/suggestions';
        const payload = {};
        if (typeof query !== 'undefined') {
            payload['query'] = query;
        }
        if (typeof tlds !== 'undefined') {
            payload['tlds'] = tlds;
        }
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        if (typeof filterType !== 'undefined') {
            payload['filterType'] = filterType;
        }
        if (typeof priceMax !== 'undefined') {
            payload['priceMax'] = priceMax;
        }
        if (typeof priceMin !== 'undefined') {
            payload['priceMin'] = priceMin;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateNameservers(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/nameservers'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getPresetGoogleWorkspace(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/google-workspace'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPresetGoogleWorkspace(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/google-workspace'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPresetICloud(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/icloud'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPresetICloud(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/icloud'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPresetMailgun(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/mailgun'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPresetMailgun(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/mailgun'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPresetOutlook(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/outlook'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPresetOutlook(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/outlook'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPresetProtonMail(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/proton-mail'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPresetProtonMail(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/proton-mail'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPresetZoho(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/zoho'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPresetZoho(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/presets/zoho'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listRecords(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                queries: rest[0]
            };
        }
        const domainId = params.domainId;
        const queries = params.queries;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/records'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createRecordA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/a'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/a/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordAAAA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/aaaa'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordAAAA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/aaaa/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordAlias(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/alias'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordAlias(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/alias/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordCAA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/caa'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordCAA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/caa/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordCNAME(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/cname'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordCNAME(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/cname/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordHTTPS(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/https'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordHTTPS(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/https/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordMX(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                priority: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const priority = params.priority;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        if (typeof priority === 'undefined') {
            throw new AppwriteException('Missing required parameter: "priority"');
        }
        const apiPath = '/domains/{domainId}/records/mx'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof priority !== 'undefined') {
            payload['priority'] = priority;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordMX(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                priority: rest[4],
                comment: rest[5]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const priority = params.priority;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        if (typeof priority === 'undefined') {
            throw new AppwriteException('Missing required parameter: "priority"');
        }
        const apiPath = '/domains/{domainId}/records/mx/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof priority !== 'undefined') {
            payload['priority'] = priority;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordNS(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/ns'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordNS(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/ns/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordSRV(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                value: rest[1],
                ttl: rest[2],
                priority: rest[3],
                weight: rest[4],
                port: rest[5],
                comment: rest[6]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const priority = params.priority;
        const weight = params.weight;
        const port = params.port;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        if (typeof priority === 'undefined') {
            throw new AppwriteException('Missing required parameter: "priority"');
        }
        if (typeof weight === 'undefined') {
            throw new AppwriteException('Missing required parameter: "weight"');
        }
        if (typeof port === 'undefined') {
            throw new AppwriteException('Missing required parameter: "port"');
        }
        const apiPath = '/domains/{domainId}/records/srv'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof priority !== 'undefined') {
            payload['priority'] = priority;
        }
        if (typeof weight !== 'undefined') {
            payload['weight'] = weight;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordSRV(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                priority: rest[4],
                weight: rest[5],
                port: rest[6],
                comment: rest[7]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const priority = params.priority;
        const weight = params.weight;
        const port = params.port;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        if (typeof priority === 'undefined') {
            throw new AppwriteException('Missing required parameter: "priority"');
        }
        if (typeof weight === 'undefined') {
            throw new AppwriteException('Missing required parameter: "weight"');
        }
        if (typeof port === 'undefined') {
            throw new AppwriteException('Missing required parameter: "port"');
        }
        const apiPath = '/domains/{domainId}/records/srv/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof priority !== 'undefined') {
            payload['priority'] = priority;
        }
        if (typeof weight !== 'undefined') {
            payload['weight'] = weight;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createRecordTXT(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                name: rest[0],
                ttl: rest[1],
                value: rest[2],
                comment: rest[3]
            };
        }
        const domainId = params.domainId;
        const name = params.name;
        const ttl = params.ttl;
        const value = params.value;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/txt'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateRecordTXT(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0],
                name: rest[1],
                value: rest[2],
                ttl: rest[3],
                comment: rest[4]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        const name = params.name;
        const value = params.value;
        const ttl = params.ttl;
        const comment = params.comment;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        if (typeof ttl === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ttl"');
        }
        const apiPath = '/domains/{domainId}/records/txt/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        if (typeof comment !== 'undefined') {
            payload['comment'] = comment;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    getRecord(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        const apiPath = '/domains/{domainId}/records/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteRecord(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                recordId: rest[0]
            };
        }
        const domainId = params.domainId;
        const recordId = params.recordId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof recordId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "recordId"');
        }
        const apiPath = '/domains/{domainId}/records/{recordId}'.replace('{domainId}', domainId).replace('{recordId}', recordId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateTeam(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                teamId: rest[0]
            };
        }
        const domainId = params.domainId;
        const teamId = params.teamId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/domains/{domainId}/team'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getZone(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst
            };
        }
        const domainId = params.domainId;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        const apiPath = '/domains/{domainId}/zone'.replace('{domainId}', domainId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateZone(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domainId: paramsOrFirst,
                content: rest[0]
            };
        }
        const domainId = params.domainId;
        const content = params.content;
        if (typeof domainId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domainId"');
        }
        if (typeof content === 'undefined') {
            throw new AppwriteException('Missing required parameter: "content"');
        }
        const apiPath = '/domains/{domainId}/zone'.replace('{domainId}', domainId);
        const payload = {};
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
}

class Functions {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/functions';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                name: rest[0],
                runtime: rest[1],
                execute: rest[2],
                events: rest[3],
                schedule: rest[4],
                timeout: rest[5],
                enabled: rest[6],
                logging: rest[7],
                entrypoint: rest[8],
                commands: rest[9],
                scopes: rest[10],
                installationId: rest[11],
                providerRepositoryId: rest[12],
                providerBranch: rest[13],
                providerSilentMode: rest[14],
                providerRootDirectory: rest[15],
                specification: rest[16]
            };
        }
        const functionId = params.functionId;
        const name = params.name;
        const runtime = params.runtime;
        const execute = params.execute;
        const events = params.events;
        const schedule = params.schedule;
        const timeout = params.timeout;
        const enabled = params.enabled;
        const logging = params.logging;
        const entrypoint = params.entrypoint;
        const commands = params.commands;
        const scopes = params.scopes;
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        const providerBranch = params.providerBranch;
        const providerSilentMode = params.providerSilentMode;
        const providerRootDirectory = params.providerRootDirectory;
        const specification = params.specification;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof runtime === 'undefined') {
            throw new AppwriteException('Missing required parameter: "runtime"');
        }
        const apiPath = '/functions';
        const payload = {};
        if (typeof functionId !== 'undefined') {
            payload['functionId'] = functionId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof runtime !== 'undefined') {
            payload['runtime'] = runtime;
        }
        if (typeof execute !== 'undefined') {
            payload['execute'] = execute;
        }
        if (typeof events !== 'undefined') {
            payload['events'] = events;
        }
        if (typeof schedule !== 'undefined') {
            payload['schedule'] = schedule;
        }
        if (typeof timeout !== 'undefined') {
            payload['timeout'] = timeout;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof logging !== 'undefined') {
            payload['logging'] = logging;
        }
        if (typeof entrypoint !== 'undefined') {
            payload['entrypoint'] = entrypoint;
        }
        if (typeof commands !== 'undefined') {
            payload['commands'] = commands;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof installationId !== 'undefined') {
            payload['installationId'] = installationId;
        }
        if (typeof providerRepositoryId !== 'undefined') {
            payload['providerRepositoryId'] = providerRepositoryId;
        }
        if (typeof providerBranch !== 'undefined') {
            payload['providerBranch'] = providerBranch;
        }
        if (typeof providerSilentMode !== 'undefined') {
            payload['providerSilentMode'] = providerSilentMode;
        }
        if (typeof providerRootDirectory !== 'undefined') {
            payload['providerRootDirectory'] = providerRootDirectory;
        }
        if (typeof specification !== 'undefined') {
            payload['specification'] = specification;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    /**
     * Get a list of all runtimes that are currently active on your instance.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.RuntimeList>}
     */
    listRuntimes() {
        const apiPath = '/functions/runtimes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List allowed function specifications for this instance.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.SpecificationList>}
     */
    listSpecifications() {
        const apiPath = '/functions/specifications';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listTemplates(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('runtimes' in paramsOrFirst || 'useCases' in paramsOrFirst || 'limit' in paramsOrFirst || 'offset' in paramsOrFirst || 'total' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                runtimes: paramsOrFirst,
                useCases: rest[0],
                limit: rest[1],
                offset: rest[2],
                total: rest[3]
            };
        }
        const runtimes = params.runtimes;
        const useCases = params.useCases;
        const limit = params.limit;
        const offset = params.offset;
        const total = params.total;
        const apiPath = '/functions/templates';
        const payload = {};
        if (typeof runtimes !== 'undefined') {
            payload['runtimes'] = runtimes;
        }
        if (typeof useCases !== 'undefined') {
            payload['useCases'] = useCases;
        }
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        if (typeof offset !== 'undefined') {
            payload['offset'] = offset;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getTemplate(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                templateId: paramsOrFirst
            };
        }
        const templateId = params.templateId;
        if (typeof templateId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "templateId"');
        }
        const apiPath = '/functions/templates/{templateId}'.replace('{templateId}', templateId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('range' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                range: paramsOrFirst
            };
        }
        const range = params.range;
        const apiPath = '/functions/usage';
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst
            };
        }
        const functionId = params.functionId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                name: rest[0],
                runtime: rest[1],
                execute: rest[2],
                events: rest[3],
                schedule: rest[4],
                timeout: rest[5],
                enabled: rest[6],
                logging: rest[7],
                entrypoint: rest[8],
                commands: rest[9],
                scopes: rest[10],
                installationId: rest[11],
                providerRepositoryId: rest[12],
                providerBranch: rest[13],
                providerSilentMode: rest[14],
                providerRootDirectory: rest[15],
                specification: rest[16]
            };
        }
        const functionId = params.functionId;
        const name = params.name;
        const runtime = params.runtime;
        const execute = params.execute;
        const events = params.events;
        const schedule = params.schedule;
        const timeout = params.timeout;
        const enabled = params.enabled;
        const logging = params.logging;
        const entrypoint = params.entrypoint;
        const commands = params.commands;
        const scopes = params.scopes;
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        const providerBranch = params.providerBranch;
        const providerSilentMode = params.providerSilentMode;
        const providerRootDirectory = params.providerRootDirectory;
        const specification = params.specification;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof runtime !== 'undefined') {
            payload['runtime'] = runtime;
        }
        if (typeof execute !== 'undefined') {
            payload['execute'] = execute;
        }
        if (typeof events !== 'undefined') {
            payload['events'] = events;
        }
        if (typeof schedule !== 'undefined') {
            payload['schedule'] = schedule;
        }
        if (typeof timeout !== 'undefined') {
            payload['timeout'] = timeout;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof logging !== 'undefined') {
            payload['logging'] = logging;
        }
        if (typeof entrypoint !== 'undefined') {
            payload['entrypoint'] = entrypoint;
        }
        if (typeof commands !== 'undefined') {
            payload['commands'] = commands;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof installationId !== 'undefined') {
            payload['installationId'] = installationId;
        }
        if (typeof providerRepositoryId !== 'undefined') {
            payload['providerRepositoryId'] = providerRepositoryId;
        }
        if (typeof providerBranch !== 'undefined') {
            payload['providerBranch'] = providerBranch;
        }
        if (typeof providerSilentMode !== 'undefined') {
            payload['providerSilentMode'] = providerSilentMode;
        }
        if (typeof providerRootDirectory !== 'undefined') {
            payload['providerRootDirectory'] = providerRootDirectory;
        }
        if (typeof specification !== 'undefined') {
            payload['specification'] = specification;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst
            };
        }
        const functionId = params.functionId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}'.replace('{functionId}', functionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateFunctionDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const functionId = params.functionId;
        const deploymentId = params.deploymentId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/functions/{functionId}/deployment'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof deploymentId !== 'undefined') {
            payload['deploymentId'] = deploymentId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listDeployments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const functionId = params.functionId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/deployments'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createDeployment(paramsOrFirst, ...rest) {
        let params;
        let onProgress;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
            onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;
        }
        else {
            params = {
                functionId: paramsOrFirst,
                code: rest[0],
                activate: rest[1],
                entrypoint: rest[2],
                commands: rest[3]
            };
            onProgress = rest[4];
        }
        const functionId = params.functionId;
        const code = params.code;
        const activate = params.activate;
        const entrypoint = params.entrypoint;
        const commands = params.commands;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        if (typeof activate === 'undefined') {
            throw new AppwriteException('Missing required parameter: "activate"');
        }
        const apiPath = '/functions/{functionId}/deployments'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof entrypoint !== 'undefined') {
            payload['entrypoint'] = entrypoint;
        }
        if (typeof commands !== 'undefined') {
            payload['commands'] = commands;
        }
        if (typeof code !== 'undefined') {
            payload['code'] = code;
        }
        if (typeof activate !== 'undefined') {
            payload['activate'] = activate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'multipart/form-data',
        };
        return this.client.chunkedUpload('post', uri, apiHeaders, payload, onProgress);
    }
    createDuplicateDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                deploymentId: rest[0],
                buildId: rest[1]
            };
        }
        const functionId = params.functionId;
        const deploymentId = params.deploymentId;
        const buildId = params.buildId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/functions/{functionId}/deployments/duplicate'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof deploymentId !== 'undefined') {
            payload['deploymentId'] = deploymentId;
        }
        if (typeof buildId !== 'undefined') {
            payload['buildId'] = buildId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createTemplateDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                repository: rest[0],
                owner: rest[1],
                rootDirectory: rest[2],
                type: rest[3],
                reference: rest[4],
                activate: rest[5]
            };
        }
        const functionId = params.functionId;
        const repository = params.repository;
        const owner = params.owner;
        const rootDirectory = params.rootDirectory;
        const type = params.type;
        const reference = params.reference;
        const activate = params.activate;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof repository === 'undefined') {
            throw new AppwriteException('Missing required parameter: "repository"');
        }
        if (typeof owner === 'undefined') {
            throw new AppwriteException('Missing required parameter: "owner"');
        }
        if (typeof rootDirectory === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rootDirectory"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof reference === 'undefined') {
            throw new AppwriteException('Missing required parameter: "reference"');
        }
        const apiPath = '/functions/{functionId}/deployments/template'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof repository !== 'undefined') {
            payload['repository'] = repository;
        }
        if (typeof owner !== 'undefined') {
            payload['owner'] = owner;
        }
        if (typeof rootDirectory !== 'undefined') {
            payload['rootDirectory'] = rootDirectory;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof reference !== 'undefined') {
            payload['reference'] = reference;
        }
        if (typeof activate !== 'undefined') {
            payload['activate'] = activate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createVcsDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                type: rest[0],
                reference: rest[1],
                activate: rest[2]
            };
        }
        const functionId = params.functionId;
        const type = params.type;
        const reference = params.reference;
        const activate = params.activate;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof reference === 'undefined') {
            throw new AppwriteException('Missing required parameter: "reference"');
        }
        const apiPath = '/functions/{functionId}/deployments/vcs'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof reference !== 'undefined') {
            payload['reference'] = reference;
        }
        if (typeof activate !== 'undefined') {
            payload['activate'] = activate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const functionId = params.functionId;
        const deploymentId = params.deploymentId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const functionId = params.functionId;
        const deploymentId = params.deploymentId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/functions/{functionId}/deployments/{deploymentId}'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getDeploymentDownload(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                deploymentId: rest[0],
                type: rest[1]
            };
        }
        const functionId = params.functionId;
        const deploymentId = params.deploymentId;
        const type = params.type;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/functions/{functionId}/deployments/{deploymentId}/download'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);
        const payload = {};
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    updateDeploymentStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const functionId = params.functionId;
        const deploymentId = params.deploymentId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/functions/{functionId}/deployments/{deploymentId}/status'.replace('{functionId}', functionId).replace('{deploymentId}', deploymentId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listExecutions(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const functionId = params.functionId;
        const queries = params.queries;
        const total = params.total;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createExecution(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                body: rest[0],
                async: rest[1],
                xpath: rest[2],
                method: rest[3],
                headers: rest[4],
                scheduledAt: rest[5]
            };
        }
        const functionId = params.functionId;
        const body = params.body;
        const async = params.async;
        const xpath = params.xpath;
        const method = params.method;
        const headers = params.headers;
        const scheduledAt = params.scheduledAt;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof body !== 'undefined') {
            payload['body'] = body;
        }
        if (typeof async !== 'undefined') {
            payload['async'] = async;
        }
        if (typeof xpath !== 'undefined') {
            payload['path'] = xpath;
        }
        if (typeof method !== 'undefined') {
            payload['method'] = method;
        }
        if (typeof headers !== 'undefined') {
            payload['headers'] = headers;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getExecution(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                executionId: rest[0]
            };
        }
        const functionId = params.functionId;
        const executionId = params.executionId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof executionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "executionId"');
        }
        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteExecution(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                executionId: rest[0]
            };
        }
        const functionId = params.functionId;
        const executionId = params.executionId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof executionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "executionId"');
        }
        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                range: rest[0]
            };
        }
        const functionId = params.functionId;
        const range = params.range;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/usage'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listVariables(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst
            };
        }
        const functionId = params.functionId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/functions/{functionId}/variables'.replace('{functionId}', functionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                key: rest[0],
                value: rest[1],
                secret: rest[2]
            };
        }
        const functionId = params.functionId;
        const key = params.key;
        const value = params.value;
        const secret = params.secret;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        const apiPath = '/functions/{functionId}/variables'.replace('{functionId}', functionId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                variableId: rest[0]
            };
        }
        const functionId = params.functionId;
        const variableId = params.variableId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                variableId: rest[0],
                key: rest[1],
                value: rest[2],
                secret: rest[3]
            };
        }
        const functionId = params.functionId;
        const variableId = params.variableId;
        const key = params.key;
        const value = params.value;
        const secret = params.secret;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                functionId: paramsOrFirst,
                variableId: rest[0]
            };
        }
        const functionId = params.functionId;
        const variableId = params.variableId;
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        const apiPath = '/functions/{functionId}/variables/{variableId}'.replace('{functionId}', functionId).replace('{variableId}', variableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

class Graphql {
    constructor(client) {
        this.client = client;
    }
    query(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('query' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                query: paramsOrFirst
            };
        }
        const query = params.query;
        if (typeof query === 'undefined') {
            throw new AppwriteException('Missing required parameter: "query"');
        }
        const apiPath = '/graphql';
        const payload = {};
        if (typeof query !== 'undefined') {
            payload['query'] = query;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'x-sdk-graphql': 'true',
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    mutation(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('query' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                query: paramsOrFirst
            };
        }
        const query = params.query;
        if (typeof query === 'undefined') {
            throw new AppwriteException('Missing required parameter: "query"');
        }
        const apiPath = '/graphql/mutation';
        const payload = {};
        if (typeof query !== 'undefined') {
            payload['query'] = query;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'x-sdk-graphql': 'true',
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
}

class Health {
    constructor(client) {
        this.client = client;
    }
    /**
     * Check the Appwrite HTTP server is up and responsive.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthStatus>}
     */
    get() {
        const apiPath = '/health';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite Antivirus server is up and connection is successful.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthAntivirus>}
     */
    getAntivirus() {
        const apiPath = '/health/anti-virus';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite in-memory cache servers are up and connection is successful.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthStatusList>}
     */
    getCache() {
        const apiPath = '/health/cache';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getCertificate(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst
            };
        }
        const domain = params.domain;
        const apiPath = '/health/certificate';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getConsolePausing(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst,
                inactivityDays: rest[0]
            };
        }
        const threshold = params.threshold;
        const inactivityDays = params.inactivityDays;
        const apiPath = '/health/console-pausing';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        if (typeof inactivityDays !== 'undefined') {
            payload['inactivityDays'] = inactivityDays;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite database servers are up and connection is successful.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthStatusList>}
     */
    getDB() {
        const apiPath = '/health/db';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite pub-sub servers are up and connection is successful.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthStatusList>}
     */
    getPubSub() {
        const apiPath = '/health/pubsub';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueAudits(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/audits';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueBillingProjectAggregation(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/billing-project-aggregation';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueBillingTeamAggregation(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/billing-team-aggregation';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueBuilds(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/builds';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueuePriorityBuilds(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/builds-priority';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueCertificates(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/certificates';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueDatabases(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst,
                threshold: rest[0]
            };
        }
        const name = params.name;
        const threshold = params.threshold;
        const apiPath = '/health/queue/databases';
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueDeletes(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/deletes';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getFailedJobs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('name' in paramsOrFirst || 'threshold' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                name: paramsOrFirst,
                threshold: rest[0]
            };
        }
        const name = params.name;
        const threshold = params.threshold;
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/health/queue/failed/{name}'.replace('{name}', name);
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueFunctions(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/functions';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueLogs(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/logs';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueMails(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/mails';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueMessaging(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/messaging';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueMigrations(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/migrations';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueRegionManager(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/region-manager';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueStatsResources(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/stats-resources';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/stats-usage';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueThreats(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/threats';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getQueueWebhooks(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                threshold: paramsOrFirst
            };
        }
        const threshold = params.threshold;
        const apiPath = '/health/queue/webhooks';
        const payload = {};
        if (typeof threshold !== 'undefined') {
            payload['threshold'] = threshold;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite storage device is up and connection is successful.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthStatus>}
     */
    getStorage() {
        const apiPath = '/health/storage';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite local storage device is up and connection is successful.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthStatus>}
     */
    getStorageLocal() {
        const apiPath = '/health/storage/local';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Check the Appwrite server time is synced with Google remote NTP server. We use this technology to smoothly handle leap seconds with no disruptive events. The [Network Time Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol) (NTP) is used by hundreds of millions of computers and devices to synchronize their clocks over the Internet. If your computer sets its own clock, it likely uses NTP.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.HealthTime>}
     */
    getTime() {
        const apiPath = '/health/time';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Locale {
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.
     *
     * ([IP Geolocation by DB-IP](https://db-ip.com))
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.Locale>}
     */
    get() {
        const apiPath = '/locale';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.LocaleCodeList>}
     */
    listCodes() {
        const apiPath = '/locale/codes';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all continents. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.ContinentList>}
     */
    listContinents() {
        const apiPath = '/locale/continents';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all countries. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.CountryList>}
     */
    listCountries() {
        const apiPath = '/locale/countries';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.CountryList>}
     */
    listCountriesEU() {
        const apiPath = '/locale/countries/eu';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all countries phone codes. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.PhoneList>}
     */
    listCountriesPhones() {
        const apiPath = '/locale/countries/phones';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.CurrencyList>}
     */
    listCurrencies() {
        const apiPath = '/locale/currencies';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.LanguageList>}
     */
    listLanguages() {
        const apiPath = '/locale/languages';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Messaging {
    constructor(client) {
        this.client = client;
    }
    listMessages(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/messaging/messages';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createEmail(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                subject: rest[0],
                content: rest[1],
                topics: rest[2],
                users: rest[3],
                targets: rest[4],
                cc: rest[5],
                bcc: rest[6],
                attachments: rest[7],
                draft: rest[8],
                html: rest[9],
                scheduledAt: rest[10]
            };
        }
        const messageId = params.messageId;
        const subject = params.subject;
        const content = params.content;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const cc = params.cc;
        const bcc = params.bcc;
        const attachments = params.attachments;
        const draft = params.draft;
        const html = params.html;
        const scheduledAt = params.scheduledAt;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        if (typeof subject === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subject"');
        }
        if (typeof content === 'undefined') {
            throw new AppwriteException('Missing required parameter: "content"');
        }
        const apiPath = '/messaging/messages/email';
        const payload = {};
        if (typeof messageId !== 'undefined') {
            payload['messageId'] = messageId;
        }
        if (typeof subject !== 'undefined') {
            payload['subject'] = subject;
        }
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof cc !== 'undefined') {
            payload['cc'] = cc;
        }
        if (typeof bcc !== 'undefined') {
            payload['bcc'] = bcc;
        }
        if (typeof attachments !== 'undefined') {
            payload['attachments'] = attachments;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof html !== 'undefined') {
            payload['html'] = html;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                topics: rest[0],
                users: rest[1],
                targets: rest[2],
                subject: rest[3],
                content: rest[4],
                draft: rest[5],
                html: rest[6],
                cc: rest[7],
                bcc: rest[8],
                scheduledAt: rest[9],
                attachments: rest[10]
            };
        }
        const messageId = params.messageId;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const subject = params.subject;
        const content = params.content;
        const draft = params.draft;
        const html = params.html;
        const cc = params.cc;
        const bcc = params.bcc;
        const scheduledAt = params.scheduledAt;
        const attachments = params.attachments;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/email/{messageId}'.replace('{messageId}', messageId);
        const payload = {};
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof subject !== 'undefined') {
            payload['subject'] = subject;
        }
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof html !== 'undefined') {
            payload['html'] = html;
        }
        if (typeof cc !== 'undefined') {
            payload['cc'] = cc;
        }
        if (typeof bcc !== 'undefined') {
            payload['bcc'] = bcc;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        if (typeof attachments !== 'undefined') {
            payload['attachments'] = attachments;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createPush(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                title: rest[0],
                body: rest[1],
                topics: rest[2],
                users: rest[3],
                targets: rest[4],
                data: rest[5],
                action: rest[6],
                image: rest[7],
                icon: rest[8],
                sound: rest[9],
                color: rest[10],
                tag: rest[11],
                badge: rest[12],
                draft: rest[13],
                scheduledAt: rest[14],
                contentAvailable: rest[15],
                critical: rest[16],
                priority: rest[17]
            };
        }
        const messageId = params.messageId;
        const title = params.title;
        const body = params.body;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const data = params.data;
        const action = params.action;
        const image = params.image;
        const icon = params.icon;
        const sound = params.sound;
        const color = params.color;
        const tag = params.tag;
        const badge = params.badge;
        const draft = params.draft;
        const scheduledAt = params.scheduledAt;
        const contentAvailable = params.contentAvailable;
        const critical = params.critical;
        const priority = params.priority;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/push';
        const payload = {};
        if (typeof messageId !== 'undefined') {
            payload['messageId'] = messageId;
        }
        if (typeof title !== 'undefined') {
            payload['title'] = title;
        }
        if (typeof body !== 'undefined') {
            payload['body'] = body;
        }
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof action !== 'undefined') {
            payload['action'] = action;
        }
        if (typeof image !== 'undefined') {
            payload['image'] = image;
        }
        if (typeof icon !== 'undefined') {
            payload['icon'] = icon;
        }
        if (typeof sound !== 'undefined') {
            payload['sound'] = sound;
        }
        if (typeof color !== 'undefined') {
            payload['color'] = color;
        }
        if (typeof tag !== 'undefined') {
            payload['tag'] = tag;
        }
        if (typeof badge !== 'undefined') {
            payload['badge'] = badge;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        if (typeof contentAvailable !== 'undefined') {
            payload['contentAvailable'] = contentAvailable;
        }
        if (typeof critical !== 'undefined') {
            payload['critical'] = critical;
        }
        if (typeof priority !== 'undefined') {
            payload['priority'] = priority;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePush(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                topics: rest[0],
                users: rest[1],
                targets: rest[2],
                title: rest[3],
                body: rest[4],
                data: rest[5],
                action: rest[6],
                image: rest[7],
                icon: rest[8],
                sound: rest[9],
                color: rest[10],
                tag: rest[11],
                badge: rest[12],
                draft: rest[13],
                scheduledAt: rest[14],
                contentAvailable: rest[15],
                critical: rest[16],
                priority: rest[17]
            };
        }
        const messageId = params.messageId;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const title = params.title;
        const body = params.body;
        const data = params.data;
        const action = params.action;
        const image = params.image;
        const icon = params.icon;
        const sound = params.sound;
        const color = params.color;
        const tag = params.tag;
        const badge = params.badge;
        const draft = params.draft;
        const scheduledAt = params.scheduledAt;
        const contentAvailable = params.contentAvailable;
        const critical = params.critical;
        const priority = params.priority;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/push/{messageId}'.replace('{messageId}', messageId);
        const payload = {};
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof title !== 'undefined') {
            payload['title'] = title;
        }
        if (typeof body !== 'undefined') {
            payload['body'] = body;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof action !== 'undefined') {
            payload['action'] = action;
        }
        if (typeof image !== 'undefined') {
            payload['image'] = image;
        }
        if (typeof icon !== 'undefined') {
            payload['icon'] = icon;
        }
        if (typeof sound !== 'undefined') {
            payload['sound'] = sound;
        }
        if (typeof color !== 'undefined') {
            payload['color'] = color;
        }
        if (typeof tag !== 'undefined') {
            payload['tag'] = tag;
        }
        if (typeof badge !== 'undefined') {
            payload['badge'] = badge;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        if (typeof contentAvailable !== 'undefined') {
            payload['contentAvailable'] = contentAvailable;
        }
        if (typeof critical !== 'undefined') {
            payload['critical'] = critical;
        }
        if (typeof priority !== 'undefined') {
            payload['priority'] = priority;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createSms(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                content: rest[0],
                topics: rest[1],
                users: rest[2],
                targets: rest[3],
                draft: rest[4],
                scheduledAt: rest[5]
            };
        }
        const messageId = params.messageId;
        const content = params.content;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const draft = params.draft;
        const scheduledAt = params.scheduledAt;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        if (typeof content === 'undefined') {
            throw new AppwriteException('Missing required parameter: "content"');
        }
        const apiPath = '/messaging/messages/sms';
        const payload = {};
        if (typeof messageId !== 'undefined') {
            payload['messageId'] = messageId;
        }
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createSMS(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                content: rest[0],
                topics: rest[1],
                users: rest[2],
                targets: rest[3],
                draft: rest[4],
                scheduledAt: rest[5]
            };
        }
        const messageId = params.messageId;
        const content = params.content;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const draft = params.draft;
        const scheduledAt = params.scheduledAt;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        if (typeof content === 'undefined') {
            throw new AppwriteException('Missing required parameter: "content"');
        }
        const apiPath = '/messaging/messages/sms';
        const payload = {};
        if (typeof messageId !== 'undefined') {
            payload['messageId'] = messageId;
        }
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateSms(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                topics: rest[0],
                users: rest[1],
                targets: rest[2],
                content: rest[3],
                draft: rest[4],
                scheduledAt: rest[5]
            };
        }
        const messageId = params.messageId;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const content = params.content;
        const draft = params.draft;
        const scheduledAt = params.scheduledAt;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/sms/{messageId}'.replace('{messageId}', messageId);
        const payload = {};
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSMS(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                topics: rest[0],
                users: rest[1],
                targets: rest[2],
                content: rest[3],
                draft: rest[4],
                scheduledAt: rest[5]
            };
        }
        const messageId = params.messageId;
        const topics = params.topics;
        const users = params.users;
        const targets = params.targets;
        const content = params.content;
        const draft = params.draft;
        const scheduledAt = params.scheduledAt;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/sms/{messageId}'.replace('{messageId}', messageId);
        const payload = {};
        if (typeof topics !== 'undefined') {
            payload['topics'] = topics;
        }
        if (typeof users !== 'undefined') {
            payload['users'] = users;
        }
        if (typeof targets !== 'undefined') {
            payload['targets'] = targets;
        }
        if (typeof content !== 'undefined') {
            payload['content'] = content;
        }
        if (typeof draft !== 'undefined') {
            payload['draft'] = draft;
        }
        if (typeof scheduledAt !== 'undefined') {
            payload['scheduledAt'] = scheduledAt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getMessage(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst
            };
        }
        const messageId = params.messageId;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst
            };
        }
        const messageId = params.messageId;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listMessageLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const messageId = params.messageId;
        const queries = params.queries;
        const total = params.total;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/{messageId}/logs'.replace('{messageId}', messageId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listTargets(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                messageId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const messageId = params.messageId;
        const queries = params.queries;
        const total = params.total;
        if (typeof messageId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "messageId"');
        }
        const apiPath = '/messaging/messages/{messageId}/targets'.replace('{messageId}', messageId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listProviders(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/messaging/providers';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createApnsProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                authKey: rest[1],
                authKeyId: rest[2],
                teamId: rest[3],
                bundleId: rest[4],
                sandbox: rest[5],
                enabled: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const authKey = params.authKey;
        const authKeyId = params.authKeyId;
        const teamId = params.teamId;
        const bundleId = params.bundleId;
        const sandbox = params.sandbox;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/apns';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof authKey !== 'undefined') {
            payload['authKey'] = authKey;
        }
        if (typeof authKeyId !== 'undefined') {
            payload['authKeyId'] = authKeyId;
        }
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof bundleId !== 'undefined') {
            payload['bundleId'] = bundleId;
        }
        if (typeof sandbox !== 'undefined') {
            payload['sandbox'] = sandbox;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createAPNSProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                authKey: rest[1],
                authKeyId: rest[2],
                teamId: rest[3],
                bundleId: rest[4],
                sandbox: rest[5],
                enabled: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const authKey = params.authKey;
        const authKeyId = params.authKeyId;
        const teamId = params.teamId;
        const bundleId = params.bundleId;
        const sandbox = params.sandbox;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/apns';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof authKey !== 'undefined') {
            payload['authKey'] = authKey;
        }
        if (typeof authKeyId !== 'undefined') {
            payload['authKeyId'] = authKeyId;
        }
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof bundleId !== 'undefined') {
            payload['bundleId'] = bundleId;
        }
        if (typeof sandbox !== 'undefined') {
            payload['sandbox'] = sandbox;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateApnsProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                authKey: rest[2],
                authKeyId: rest[3],
                teamId: rest[4],
                bundleId: rest[5],
                sandbox: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const authKey = params.authKey;
        const authKeyId = params.authKeyId;
        const teamId = params.teamId;
        const bundleId = params.bundleId;
        const sandbox = params.sandbox;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/apns/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof authKey !== 'undefined') {
            payload['authKey'] = authKey;
        }
        if (typeof authKeyId !== 'undefined') {
            payload['authKeyId'] = authKeyId;
        }
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof bundleId !== 'undefined') {
            payload['bundleId'] = bundleId;
        }
        if (typeof sandbox !== 'undefined') {
            payload['sandbox'] = sandbox;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAPNSProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                authKey: rest[2],
                authKeyId: rest[3],
                teamId: rest[4],
                bundleId: rest[5],
                sandbox: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const authKey = params.authKey;
        const authKeyId = params.authKeyId;
        const teamId = params.teamId;
        const bundleId = params.bundleId;
        const sandbox = params.sandbox;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/apns/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof authKey !== 'undefined') {
            payload['authKey'] = authKey;
        }
        if (typeof authKeyId !== 'undefined') {
            payload['authKeyId'] = authKeyId;
        }
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof bundleId !== 'undefined') {
            payload['bundleId'] = bundleId;
        }
        if (typeof sandbox !== 'undefined') {
            payload['sandbox'] = sandbox;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createFcmProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                serviceAccountJSON: rest[1],
                enabled: rest[2]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const serviceAccountJSON = params.serviceAccountJSON;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/fcm';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof serviceAccountJSON !== 'undefined') {
            payload['serviceAccountJSON'] = serviceAccountJSON;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createFCMProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                serviceAccountJSON: rest[1],
                enabled: rest[2]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const serviceAccountJSON = params.serviceAccountJSON;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/fcm';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof serviceAccountJSON !== 'undefined') {
            payload['serviceAccountJSON'] = serviceAccountJSON;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateFcmProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                serviceAccountJSON: rest[2]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const serviceAccountJSON = params.serviceAccountJSON;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/fcm/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof serviceAccountJSON !== 'undefined') {
            payload['serviceAccountJSON'] = serviceAccountJSON;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateFCMProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                serviceAccountJSON: rest[2]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const serviceAccountJSON = params.serviceAccountJSON;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/fcm/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof serviceAccountJSON !== 'undefined') {
            payload['serviceAccountJSON'] = serviceAccountJSON;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createMailgunProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                apiKey: rest[1],
                domain: rest[2],
                isEuRegion: rest[3],
                fromName: rest[4],
                fromEmail: rest[5],
                replyToName: rest[6],
                replyToEmail: rest[7],
                enabled: rest[8]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const apiKey = params.apiKey;
        const domain = params.domain;
        const isEuRegion = params.isEuRegion;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/mailgun';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof isEuRegion !== 'undefined') {
            payload['isEuRegion'] = isEuRegion;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMailgunProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                apiKey: rest[1],
                domain: rest[2],
                isEuRegion: rest[3],
                enabled: rest[4],
                fromName: rest[5],
                fromEmail: rest[6],
                replyToName: rest[7],
                replyToEmail: rest[8]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const apiKey = params.apiKey;
        const domain = params.domain;
        const isEuRegion = params.isEuRegion;
        const enabled = params.enabled;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/mailgun/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof isEuRegion !== 'undefined') {
            payload['isEuRegion'] = isEuRegion;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createMsg91Provider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                templateId: rest[1],
                senderId: rest[2],
                authKey: rest[3],
                enabled: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const templateId = params.templateId;
        const senderId = params.senderId;
        const authKey = params.authKey;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/msg91';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof templateId !== 'undefined') {
            payload['templateId'] = templateId;
        }
        if (typeof senderId !== 'undefined') {
            payload['senderId'] = senderId;
        }
        if (typeof authKey !== 'undefined') {
            payload['authKey'] = authKey;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMsg91Provider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                templateId: rest[2],
                senderId: rest[3],
                authKey: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const templateId = params.templateId;
        const senderId = params.senderId;
        const authKey = params.authKey;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/msg91/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof templateId !== 'undefined') {
            payload['templateId'] = templateId;
        }
        if (typeof senderId !== 'undefined') {
            payload['senderId'] = senderId;
        }
        if (typeof authKey !== 'undefined') {
            payload['authKey'] = authKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createResendProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                apiKey: rest[1],
                fromName: rest[2],
                fromEmail: rest[3],
                replyToName: rest[4],
                replyToEmail: rest[5],
                enabled: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const apiKey = params.apiKey;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/resend';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateResendProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                apiKey: rest[2],
                fromName: rest[3],
                fromEmail: rest[4],
                replyToName: rest[5],
                replyToEmail: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const apiKey = params.apiKey;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/resend/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createSendgridProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                apiKey: rest[1],
                fromName: rest[2],
                fromEmail: rest[3],
                replyToName: rest[4],
                replyToEmail: rest[5],
                enabled: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const apiKey = params.apiKey;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/sendgrid';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateSendgridProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                apiKey: rest[2],
                fromName: rest[3],
                fromEmail: rest[4],
                replyToName: rest[5],
                replyToEmail: rest[6]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const apiKey = params.apiKey;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/sendgrid/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createSmtpProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                host: rest[1],
                port: rest[2],
                username: rest[3],
                password: rest[4],
                encryption: rest[5],
                autoTLS: rest[6],
                mailer: rest[7],
                fromName: rest[8],
                fromEmail: rest[9],
                replyToName: rest[10],
                replyToEmail: rest[11],
                enabled: rest[12]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const host = params.host;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const encryption = params.encryption;
        const autoTLS = params.autoTLS;
        const mailer = params.mailer;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof host === 'undefined') {
            throw new AppwriteException('Missing required parameter: "host"');
        }
        const apiPath = '/messaging/providers/smtp';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof encryption !== 'undefined') {
            payload['encryption'] = encryption;
        }
        if (typeof autoTLS !== 'undefined') {
            payload['autoTLS'] = autoTLS;
        }
        if (typeof mailer !== 'undefined') {
            payload['mailer'] = mailer;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createSMTPProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                host: rest[1],
                port: rest[2],
                username: rest[3],
                password: rest[4],
                encryption: rest[5],
                autoTLS: rest[6],
                mailer: rest[7],
                fromName: rest[8],
                fromEmail: rest[9],
                replyToName: rest[10],
                replyToEmail: rest[11],
                enabled: rest[12]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const host = params.host;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const encryption = params.encryption;
        const autoTLS = params.autoTLS;
        const mailer = params.mailer;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof host === 'undefined') {
            throw new AppwriteException('Missing required parameter: "host"');
        }
        const apiPath = '/messaging/providers/smtp';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof encryption !== 'undefined') {
            payload['encryption'] = encryption;
        }
        if (typeof autoTLS !== 'undefined') {
            payload['autoTLS'] = autoTLS;
        }
        if (typeof mailer !== 'undefined') {
            payload['mailer'] = mailer;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateSmtpProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                host: rest[1],
                port: rest[2],
                username: rest[3],
                password: rest[4],
                encryption: rest[5],
                autoTLS: rest[6],
                mailer: rest[7],
                fromName: rest[8],
                fromEmail: rest[9],
                replyToName: rest[10],
                replyToEmail: rest[11],
                enabled: rest[12]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const host = params.host;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const encryption = params.encryption;
        const autoTLS = params.autoTLS;
        const mailer = params.mailer;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/smtp/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof encryption !== 'undefined') {
            payload['encryption'] = encryption;
        }
        if (typeof autoTLS !== 'undefined') {
            payload['autoTLS'] = autoTLS;
        }
        if (typeof mailer !== 'undefined') {
            payload['mailer'] = mailer;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSMTPProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                host: rest[1],
                port: rest[2],
                username: rest[3],
                password: rest[4],
                encryption: rest[5],
                autoTLS: rest[6],
                mailer: rest[7],
                fromName: rest[8],
                fromEmail: rest[9],
                replyToName: rest[10],
                replyToEmail: rest[11],
                enabled: rest[12]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const host = params.host;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const encryption = params.encryption;
        const autoTLS = params.autoTLS;
        const mailer = params.mailer;
        const fromName = params.fromName;
        const fromEmail = params.fromEmail;
        const replyToName = params.replyToName;
        const replyToEmail = params.replyToEmail;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/smtp/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof encryption !== 'undefined') {
            payload['encryption'] = encryption;
        }
        if (typeof autoTLS !== 'undefined') {
            payload['autoTLS'] = autoTLS;
        }
        if (typeof mailer !== 'undefined') {
            payload['mailer'] = mailer;
        }
        if (typeof fromName !== 'undefined') {
            payload['fromName'] = fromName;
        }
        if (typeof fromEmail !== 'undefined') {
            payload['fromEmail'] = fromEmail;
        }
        if (typeof replyToName !== 'undefined') {
            payload['replyToName'] = replyToName;
        }
        if (typeof replyToEmail !== 'undefined') {
            payload['replyToEmail'] = replyToEmail;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createTelesignProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                from: rest[1],
                customerId: rest[2],
                apiKey: rest[3],
                enabled: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const from = params.from;
        const customerId = params.customerId;
        const apiKey = params.apiKey;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/telesign';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        if (typeof customerId !== 'undefined') {
            payload['customerId'] = customerId;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateTelesignProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                customerId: rest[2],
                apiKey: rest[3],
                from: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const customerId = params.customerId;
        const apiKey = params.apiKey;
        const from = params.from;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/telesign/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof customerId !== 'undefined') {
            payload['customerId'] = customerId;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createTextmagicProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                from: rest[1],
                username: rest[2],
                apiKey: rest[3],
                enabled: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const from = params.from;
        const username = params.username;
        const apiKey = params.apiKey;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/textmagic';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateTextmagicProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                username: rest[2],
                apiKey: rest[3],
                from: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const username = params.username;
        const apiKey = params.apiKey;
        const from = params.from;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/textmagic/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createTwilioProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                from: rest[1],
                accountSid: rest[2],
                authToken: rest[3],
                enabled: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const from = params.from;
        const accountSid = params.accountSid;
        const authToken = params.authToken;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/twilio';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        if (typeof accountSid !== 'undefined') {
            payload['accountSid'] = accountSid;
        }
        if (typeof authToken !== 'undefined') {
            payload['authToken'] = authToken;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateTwilioProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                accountSid: rest[2],
                authToken: rest[3],
                from: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const accountSid = params.accountSid;
        const authToken = params.authToken;
        const from = params.from;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/twilio/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof accountSid !== 'undefined') {
            payload['accountSid'] = accountSid;
        }
        if (typeof authToken !== 'undefined') {
            payload['authToken'] = authToken;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createVonageProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                from: rest[1],
                apiKey: rest[2],
                apiSecret: rest[3],
                enabled: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const from = params.from;
        const apiKey = params.apiKey;
        const apiSecret = params.apiSecret;
        const enabled = params.enabled;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/providers/vonage';
        const payload = {};
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof apiSecret !== 'undefined') {
            payload['apiSecret'] = apiSecret;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateVonageProvider(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1],
                apiKey: rest[2],
                apiSecret: rest[3],
                from: rest[4]
            };
        }
        const providerId = params.providerId;
        const name = params.name;
        const enabled = params.enabled;
        const apiKey = params.apiKey;
        const apiSecret = params.apiSecret;
        const from = params.from;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/vonage/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof apiSecret !== 'undefined') {
            payload['apiSecret'] = apiSecret;
        }
        if (typeof from !== 'undefined') {
            payload['from'] = from;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getProvider(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst
            };
        }
        const providerId = params.providerId;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteProvider(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst
            };
        }
        const providerId = params.providerId;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listProviderLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                providerId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const providerId = params.providerId;
        const queries = params.queries;
        const total = params.total;
        if (typeof providerId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerId"');
        }
        const apiPath = '/messaging/providers/{providerId}/logs'.replace('{providerId}', providerId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listSubscriberLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                subscriberId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const subscriberId = params.subscriberId;
        const queries = params.queries;
        const total = params.total;
        if (typeof subscriberId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subscriberId"');
        }
        const apiPath = '/messaging/subscribers/{subscriberId}/logs'.replace('{subscriberId}', subscriberId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listTopics(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/messaging/topics';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createTopic(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                name: rest[0],
                subscribe: rest[1]
            };
        }
        const topicId = params.topicId;
        const name = params.name;
        const subscribe = params.subscribe;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/messaging/topics';
        const payload = {};
        if (typeof topicId !== 'undefined') {
            payload['topicId'] = topicId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof subscribe !== 'undefined') {
            payload['subscribe'] = subscribe;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getTopic(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst
            };
        }
        const topicId = params.topicId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateTopic(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                name: rest[0],
                subscribe: rest[1]
            };
        }
        const topicId = params.topicId;
        const name = params.name;
        const subscribe = params.subscribe;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof subscribe !== 'undefined') {
            payload['subscribe'] = subscribe;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteTopic(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst
            };
        }
        const topicId = params.topicId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listTopicLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const topicId = params.topicId;
        const queries = params.queries;
        const total = params.total;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        const apiPath = '/messaging/topics/{topicId}/logs'.replace('{topicId}', topicId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listSubscribers(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const topicId = params.topicId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createSubscriber(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                subscriberId: rest[0],
                targetId: rest[1]
            };
        }
        const topicId = params.topicId;
        const subscriberId = params.subscriberId;
        const targetId = params.targetId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        if (typeof subscriberId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subscriberId"');
        }
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);
        const payload = {};
        if (typeof subscriberId !== 'undefined') {
            payload['subscriberId'] = subscriberId;
        }
        if (typeof targetId !== 'undefined') {
            payload['targetId'] = targetId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getSubscriber(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                subscriberId: rest[0]
            };
        }
        const topicId = params.topicId;
        const subscriberId = params.subscriberId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        if (typeof subscriberId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subscriberId"');
        }
        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteSubscriber(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                topicId: paramsOrFirst,
                subscriberId: rest[0]
            };
        }
        const topicId = params.topicId;
        const subscriberId = params.subscriberId;
        if (typeof topicId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "topicId"');
        }
        if (typeof subscriberId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subscriberId"');
        }
        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

class Migrations {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/migrations';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createAppwriteMigration(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'endpoint' in paramsOrFirst || 'projectId' in paramsOrFirst || 'apiKey' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                endpoint: rest[0],
                projectId: rest[1],
                apiKey: rest[2]
            };
        }
        const resources = params.resources;
        const endpoint = params.endpoint;
        const projectId = params.projectId;
        const apiKey = params.apiKey;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof endpoint === 'undefined') {
            throw new AppwriteException('Missing required parameter: "endpoint"');
        }
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof apiKey === 'undefined') {
            throw new AppwriteException('Missing required parameter: "apiKey"');
        }
        const apiPath = '/migrations/appwrite';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof endpoint !== 'undefined') {
            payload['endpoint'] = endpoint;
        }
        if (typeof projectId !== 'undefined') {
            payload['projectId'] = projectId;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getAppwriteReport(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'endpoint' in paramsOrFirst || 'projectID' in paramsOrFirst || 'key' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                endpoint: rest[0],
                projectID: rest[1],
                key: rest[2]
            };
        }
        const resources = params.resources;
        const endpoint = params.endpoint;
        const projectID = params.projectID;
        const key = params.key;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof endpoint === 'undefined') {
            throw new AppwriteException('Missing required parameter: "endpoint"');
        }
        if (typeof projectID === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectID"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/migrations/appwrite/report';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof endpoint !== 'undefined') {
            payload['endpoint'] = endpoint;
        }
        if (typeof projectID !== 'undefined') {
            payload['projectID'] = projectID;
        }
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createCSVExport(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resourceId: paramsOrFirst,
                filename: rest[0],
                columns: rest[1],
                queries: rest[2],
                delimiter: rest[3],
                enclosure: rest[4],
                escape: rest[5],
                header: rest[6],
                notify: rest[7]
            };
        }
        const resourceId = params.resourceId;
        const filename = params.filename;
        const columns = params.columns;
        const queries = params.queries;
        const delimiter = params.delimiter;
        const enclosure = params.enclosure;
        const escape = params.escape;
        const header = params.header;
        const notify = params.notify;
        if (typeof resourceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resourceId"');
        }
        if (typeof filename === 'undefined') {
            throw new AppwriteException('Missing required parameter: "filename"');
        }
        const apiPath = '/migrations/csv/exports';
        const payload = {};
        if (typeof resourceId !== 'undefined') {
            payload['resourceId'] = resourceId;
        }
        if (typeof filename !== 'undefined') {
            payload['filename'] = filename;
        }
        if (typeof columns !== 'undefined') {
            payload['columns'] = columns;
        }
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof delimiter !== 'undefined') {
            payload['delimiter'] = delimiter;
        }
        if (typeof enclosure !== 'undefined') {
            payload['enclosure'] = enclosure;
        }
        if (typeof escape !== 'undefined') {
            payload['escape'] = escape;
        }
        if (typeof header !== 'undefined') {
            payload['header'] = header;
        }
        if (typeof notify !== 'undefined') {
            payload['notify'] = notify;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createCSVImport(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                resourceId: rest[1],
                internalFile: rest[2]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const resourceId = params.resourceId;
        const internalFile = params.internalFile;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        if (typeof resourceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resourceId"');
        }
        const apiPath = '/migrations/csv/imports';
        const payload = {};
        if (typeof bucketId !== 'undefined') {
            payload['bucketId'] = bucketId;
        }
        if (typeof fileId !== 'undefined') {
            payload['fileId'] = fileId;
        }
        if (typeof resourceId !== 'undefined') {
            payload['resourceId'] = resourceId;
        }
        if (typeof internalFile !== 'undefined') {
            payload['internalFile'] = internalFile;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createFirebaseMigration(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'serviceAccount' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                serviceAccount: rest[0]
            };
        }
        const resources = params.resources;
        const serviceAccount = params.serviceAccount;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof serviceAccount === 'undefined') {
            throw new AppwriteException('Missing required parameter: "serviceAccount"');
        }
        const apiPath = '/migrations/firebase';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof serviceAccount !== 'undefined') {
            payload['serviceAccount'] = serviceAccount;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getFirebaseReport(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'serviceAccount' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                serviceAccount: rest[0]
            };
        }
        const resources = params.resources;
        const serviceAccount = params.serviceAccount;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof serviceAccount === 'undefined') {
            throw new AppwriteException('Missing required parameter: "serviceAccount"');
        }
        const apiPath = '/migrations/firebase/report';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof serviceAccount !== 'undefined') {
            payload['serviceAccount'] = serviceAccount;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createNHostMigration(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'subdomain' in paramsOrFirst || 'region' in paramsOrFirst || 'adminSecret' in paramsOrFirst || 'database' in paramsOrFirst || 'username' in paramsOrFirst || 'password' in paramsOrFirst || 'port' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                subdomain: rest[0],
                region: rest[1],
                adminSecret: rest[2],
                database: rest[3],
                username: rest[4],
                password: rest[5],
                port: rest[6]
            };
        }
        const resources = params.resources;
        const subdomain = params.subdomain;
        const region = params.region;
        const adminSecret = params.adminSecret;
        const database = params.database;
        const username = params.username;
        const password = params.password;
        const port = params.port;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof subdomain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subdomain"');
        }
        if (typeof region === 'undefined') {
            throw new AppwriteException('Missing required parameter: "region"');
        }
        if (typeof adminSecret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "adminSecret"');
        }
        if (typeof database === 'undefined') {
            throw new AppwriteException('Missing required parameter: "database"');
        }
        if (typeof username === 'undefined') {
            throw new AppwriteException('Missing required parameter: "username"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/migrations/nhost';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof subdomain !== 'undefined') {
            payload['subdomain'] = subdomain;
        }
        if (typeof region !== 'undefined') {
            payload['region'] = region;
        }
        if (typeof adminSecret !== 'undefined') {
            payload['adminSecret'] = adminSecret;
        }
        if (typeof database !== 'undefined') {
            payload['database'] = database;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getNHostReport(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'subdomain' in paramsOrFirst || 'region' in paramsOrFirst || 'adminSecret' in paramsOrFirst || 'database' in paramsOrFirst || 'username' in paramsOrFirst || 'password' in paramsOrFirst || 'port' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                subdomain: rest[0],
                region: rest[1],
                adminSecret: rest[2],
                database: rest[3],
                username: rest[4],
                password: rest[5],
                port: rest[6]
            };
        }
        const resources = params.resources;
        const subdomain = params.subdomain;
        const region = params.region;
        const adminSecret = params.adminSecret;
        const database = params.database;
        const username = params.username;
        const password = params.password;
        const port = params.port;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof subdomain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subdomain"');
        }
        if (typeof region === 'undefined') {
            throw new AppwriteException('Missing required parameter: "region"');
        }
        if (typeof adminSecret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "adminSecret"');
        }
        if (typeof database === 'undefined') {
            throw new AppwriteException('Missing required parameter: "database"');
        }
        if (typeof username === 'undefined') {
            throw new AppwriteException('Missing required parameter: "username"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/migrations/nhost/report';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof subdomain !== 'undefined') {
            payload['subdomain'] = subdomain;
        }
        if (typeof region !== 'undefined') {
            payload['region'] = region;
        }
        if (typeof adminSecret !== 'undefined') {
            payload['adminSecret'] = adminSecret;
        }
        if (typeof database !== 'undefined') {
            payload['database'] = database;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createSupabaseMigration(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'endpoint' in paramsOrFirst || 'apiKey' in paramsOrFirst || 'databaseHost' in paramsOrFirst || 'username' in paramsOrFirst || 'password' in paramsOrFirst || 'port' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                endpoint: rest[0],
                apiKey: rest[1],
                databaseHost: rest[2],
                username: rest[3],
                password: rest[4],
                port: rest[5]
            };
        }
        const resources = params.resources;
        const endpoint = params.endpoint;
        const apiKey = params.apiKey;
        const databaseHost = params.databaseHost;
        const username = params.username;
        const password = params.password;
        const port = params.port;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof endpoint === 'undefined') {
            throw new AppwriteException('Missing required parameter: "endpoint"');
        }
        if (typeof apiKey === 'undefined') {
            throw new AppwriteException('Missing required parameter: "apiKey"');
        }
        if (typeof databaseHost === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseHost"');
        }
        if (typeof username === 'undefined') {
            throw new AppwriteException('Missing required parameter: "username"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/migrations/supabase';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof endpoint !== 'undefined') {
            payload['endpoint'] = endpoint;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof databaseHost !== 'undefined') {
            payload['databaseHost'] = databaseHost;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getSupabaseReport(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('resources' in paramsOrFirst || 'endpoint' in paramsOrFirst || 'apiKey' in paramsOrFirst || 'databaseHost' in paramsOrFirst || 'username' in paramsOrFirst || 'password' in paramsOrFirst || 'port' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                resources: paramsOrFirst,
                endpoint: rest[0],
                apiKey: rest[1],
                databaseHost: rest[2],
                username: rest[3],
                password: rest[4],
                port: rest[5]
            };
        }
        const resources = params.resources;
        const endpoint = params.endpoint;
        const apiKey = params.apiKey;
        const databaseHost = params.databaseHost;
        const username = params.username;
        const password = params.password;
        const port = params.port;
        if (typeof resources === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resources"');
        }
        if (typeof endpoint === 'undefined') {
            throw new AppwriteException('Missing required parameter: "endpoint"');
        }
        if (typeof apiKey === 'undefined') {
            throw new AppwriteException('Missing required parameter: "apiKey"');
        }
        if (typeof databaseHost === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseHost"');
        }
        if (typeof username === 'undefined') {
            throw new AppwriteException('Missing required parameter: "username"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/migrations/supabase/report';
        const payload = {};
        if (typeof resources !== 'undefined') {
            payload['resources'] = resources;
        }
        if (typeof endpoint !== 'undefined') {
            payload['endpoint'] = endpoint;
        }
        if (typeof apiKey !== 'undefined') {
            payload['apiKey'] = apiKey;
        }
        if (typeof databaseHost !== 'undefined') {
            payload['databaseHost'] = databaseHost;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                migrationId: paramsOrFirst
            };
        }
        const migrationId = params.migrationId;
        if (typeof migrationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "migrationId"');
        }
        const apiPath = '/migrations/{migrationId}'.replace('{migrationId}', migrationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    retry(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                migrationId: paramsOrFirst
            };
        }
        const migrationId = params.migrationId;
        if (typeof migrationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "migrationId"');
        }
        const apiPath = '/migrations/{migrationId}'.replace('{migrationId}', migrationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                migrationId: paramsOrFirst
            };
        }
        const migrationId = params.migrationId;
        if (typeof migrationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "migrationId"');
        }
        const apiPath = '/migrations/{migrationId}'.replace('{migrationId}', migrationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

class Organizations {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const apiPath = '/organizations';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                name: rest[0],
                billingPlan: rest[1],
                paymentMethodId: rest[2],
                billingAddressId: rest[3],
                invites: rest[4],
                couponId: rest[5],
                taxId: rest[6],
                budget: rest[7],
                platform: rest[8]
            };
        }
        const organizationId = params.organizationId;
        const name = params.name;
        const billingPlan = params.billingPlan;
        const paymentMethodId = params.paymentMethodId;
        const billingAddressId = params.billingAddressId;
        const invites = params.invites;
        const couponId = params.couponId;
        const taxId = params.taxId;
        const budget = params.budget;
        const platform = params.platform;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof billingPlan === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingPlan"');
        }
        const apiPath = '/organizations';
        const payload = {};
        if (typeof organizationId !== 'undefined') {
            payload['organizationId'] = organizationId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof billingPlan !== 'undefined') {
            payload['billingPlan'] = billingPlan;
        }
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        if (typeof billingAddressId !== 'undefined') {
            payload['billingAddressId'] = billingAddressId;
        }
        if (typeof invites !== 'undefined') {
            payload['invites'] = invites;
        }
        if (typeof couponId !== 'undefined') {
            payload['couponId'] = couponId;
        }
        if (typeof taxId !== 'undefined') {
            payload['taxId'] = taxId;
        }
        if (typeof budget !== 'undefined') {
            payload['budget'] = budget;
        }
        if (typeof platform !== 'undefined') {
            payload['platform'] = platform;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    estimationCreateOrganization(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                billingPlan: paramsOrFirst,
                paymentMethodId: rest[0],
                invites: rest[1],
                couponId: rest[2],
                platform: rest[3]
            };
        }
        const billingPlan = params.billingPlan;
        const paymentMethodId = params.paymentMethodId;
        const invites = params.invites;
        const couponId = params.couponId;
        const platform = params.platform;
        if (typeof billingPlan === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingPlan"');
        }
        const apiPath = '/organizations/estimations/create-organization';
        const payload = {};
        if (typeof billingPlan !== 'undefined') {
            payload['billingPlan'] = billingPlan;
        }
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        if (typeof invites !== 'undefined') {
            payload['invites'] = invites;
        }
        if (typeof couponId !== 'undefined') {
            payload['couponId'] = couponId;
        }
        if (typeof platform !== 'undefined') {
            payload['platform'] = platform;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listAggregations(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                queries: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const queries = params.queries;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/aggregations'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getAggregation(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                aggregationId: rest[0],
                limit: rest[1],
                offset: rest[2]
            };
        }
        const organizationId = params.organizationId;
        const aggregationId = params.aggregationId;
        const limit = params.limit;
        const offset = params.offset;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof aggregationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "aggregationId"');
        }
        const apiPath = '/organizations/{organizationId}/aggregations/{aggregationId}'.replace('{organizationId}', organizationId).replace('{aggregationId}', aggregationId);
        const payload = {};
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        if (typeof offset !== 'undefined') {
            payload['offset'] = offset;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    setBillingAddress(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                billingAddressId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const billingAddressId = params.billingAddressId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof billingAddressId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingAddressId"');
        }
        const apiPath = '/organizations/{organizationId}/billing-address'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof billingAddressId !== 'undefined') {
            payload['billingAddressId'] = billingAddressId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteBillingAddress(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/billing-address'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getBillingAddress(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                billingAddressId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const billingAddressId = params.billingAddressId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof billingAddressId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingAddressId"');
        }
        const apiPath = '/organizations/{organizationId}/billing-addresses/{billingAddressId}'.replace('{organizationId}', organizationId).replace('{billingAddressId}', billingAddressId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    setBillingEmail(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                billingEmail: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const billingEmail = params.billingEmail;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof billingEmail === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingEmail"');
        }
        const apiPath = '/organizations/{organizationId}/billing-email'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof billingEmail !== 'undefined') {
            payload['billingEmail'] = billingEmail;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateBudget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                budget: rest[0],
                alerts: rest[1]
            };
        }
        const organizationId = params.organizationId;
        const budget = params.budget;
        const alerts = params.alerts;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof budget === 'undefined') {
            throw new AppwriteException('Missing required parameter: "budget"');
        }
        const apiPath = '/organizations/{organizationId}/budget'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof budget !== 'undefined') {
            payload['budget'] = budget;
        }
        if (typeof alerts !== 'undefined') {
            payload['alerts'] = alerts;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listCredits(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                queries: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const queries = params.queries;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/credits'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    addCredit(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                couponId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const couponId = params.couponId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof couponId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "couponId"');
        }
        const apiPath = '/organizations/{organizationId}/credits'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof couponId !== 'undefined') {
            payload['couponId'] = couponId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getAvailableCredits(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/credits/available'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getCredit(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                creditId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const creditId = params.creditId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof creditId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "creditId"');
        }
        const apiPath = '/organizations/{organizationId}/credits/{creditId}'.replace('{organizationId}', organizationId).replace('{creditId}', creditId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    estimationDeleteOrganization(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/estimations/delete-organization'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    estimationUpdatePlan(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                billingPlan: rest[0],
                invites: rest[1],
                couponId: rest[2]
            };
        }
        const organizationId = params.organizationId;
        const billingPlan = params.billingPlan;
        const invites = params.invites;
        const couponId = params.couponId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof billingPlan === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingPlan"');
        }
        const apiPath = '/organizations/{organizationId}/estimations/update-plan'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof billingPlan !== 'undefined') {
            payload['billingPlan'] = billingPlan;
        }
        if (typeof invites !== 'undefined') {
            payload['invites'] = invites;
        }
        if (typeof couponId !== 'undefined') {
            payload['couponId'] = couponId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createDowngradeFeedback(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                reason: rest[0],
                message: rest[1],
                fromPlanId: rest[2],
                toPlanId: rest[3]
            };
        }
        const organizationId = params.organizationId;
        const reason = params.reason;
        const message = params.message;
        const fromPlanId = params.fromPlanId;
        const toPlanId = params.toPlanId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof reason === 'undefined') {
            throw new AppwriteException('Missing required parameter: "reason"');
        }
        if (typeof message === 'undefined') {
            throw new AppwriteException('Missing required parameter: "message"');
        }
        if (typeof fromPlanId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fromPlanId"');
        }
        if (typeof toPlanId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "toPlanId"');
        }
        const apiPath = '/organizations/{organizationId}/feedbacks/downgrade'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof reason !== 'undefined') {
            payload['reason'] = reason;
        }
        if (typeof message !== 'undefined') {
            payload['message'] = message;
        }
        if (typeof fromPlanId !== 'undefined') {
            payload['fromPlanId'] = fromPlanId;
        }
        if (typeof toPlanId !== 'undefined') {
            payload['toPlanId'] = toPlanId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listInvoices(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                queries: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const queries = params.queries;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/invoices'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getInvoice(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                invoiceId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const invoiceId = params.invoiceId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof invoiceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "invoiceId"');
        }
        const apiPath = '/organizations/{organizationId}/invoices/{invoiceId}'.replace('{organizationId}', organizationId).replace('{invoiceId}', invoiceId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getInvoiceDownload(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                invoiceId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const invoiceId = params.invoiceId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof invoiceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "invoiceId"');
        }
        const apiPath = '/organizations/{organizationId}/invoices/{invoiceId}/download'.replace('{organizationId}', organizationId).replace('{invoiceId}', invoiceId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createInvoicePayment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                invoiceId: rest[0],
                paymentMethodId: rest[1]
            };
        }
        const organizationId = params.organizationId;
        const invoiceId = params.invoiceId;
        const paymentMethodId = params.paymentMethodId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof invoiceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "invoiceId"');
        }
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/organizations/{organizationId}/invoices/{invoiceId}/payments'.replace('{organizationId}', organizationId).replace('{invoiceId}', invoiceId);
        const payload = {};
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    validateInvoice(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                invoiceId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const invoiceId = params.invoiceId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof invoiceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "invoiceId"');
        }
        const apiPath = '/organizations/{organizationId}/invoices/{invoiceId}/status'.replace('{organizationId}', organizationId).replace('{invoiceId}', invoiceId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getInvoiceView(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                invoiceId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const invoiceId = params.invoiceId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof invoiceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "invoiceId"');
        }
        const apiPath = '/organizations/{organizationId}/invoices/{invoiceId}/view'.replace('{organizationId}', organizationId).replace('{invoiceId}', invoiceId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listKeys(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                total: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const total = params.total;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/keys'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                name: rest[0],
                scopes: rest[1],
                expire: rest[2]
            };
        }
        const organizationId = params.organizationId;
        const name = params.name;
        const scopes = params.scopes;
        const expire = params.expire;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/organizations/{organizationId}/keys'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                keyId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const keyId = params.keyId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/organizations/{organizationId}/keys/{keyId}'.replace('{organizationId}', organizationId).replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                keyId: rest[0],
                name: rest[1],
                scopes: rest[2],
                expire: rest[3]
            };
        }
        const organizationId = params.organizationId;
        const keyId = params.keyId;
        const name = params.name;
        const scopes = params.scopes;
        const expire = params.expire;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/organizations/{organizationId}/keys/{keyId}'.replace('{organizationId}', organizationId).replace('{keyId}', keyId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                keyId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const keyId = params.keyId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/organizations/{organizationId}/keys/{keyId}'.replace('{organizationId}', organizationId).replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    setDefaultPaymentMethod(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                paymentMethodId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const paymentMethodId = params.paymentMethodId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/organizations/{organizationId}/payment-method'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteDefaultPaymentMethod(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/payment-method'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    setBackupPaymentMethod(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                paymentMethodId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const paymentMethodId = params.paymentMethodId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/organizations/{organizationId}/payment-method/backup'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteBackupPaymentMethod(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/payment-method/backup'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getPaymentMethod(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                paymentMethodId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const paymentMethodId = params.paymentMethodId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof paymentMethodId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "paymentMethodId"');
        }
        const apiPath = '/organizations/{organizationId}/payment-methods/{paymentMethodId}'.replace('{organizationId}', organizationId).replace('{paymentMethodId}', paymentMethodId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getPlan(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/plan'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePlan(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                billingPlan: rest[0],
                paymentMethodId: rest[1],
                billingAddressId: rest[2],
                invites: rest[3],
                couponId: rest[4],
                taxId: rest[5],
                budget: rest[6]
            };
        }
        const organizationId = params.organizationId;
        const billingPlan = params.billingPlan;
        const paymentMethodId = params.paymentMethodId;
        const billingAddressId = params.billingAddressId;
        const invites = params.invites;
        const couponId = params.couponId;
        const taxId = params.taxId;
        const budget = params.budget;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof billingPlan === 'undefined') {
            throw new AppwriteException('Missing required parameter: "billingPlan"');
        }
        const apiPath = '/organizations/{organizationId}/plan'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof billingPlan !== 'undefined') {
            payload['billingPlan'] = billingPlan;
        }
        if (typeof paymentMethodId !== 'undefined') {
            payload['paymentMethodId'] = paymentMethodId;
        }
        if (typeof billingAddressId !== 'undefined') {
            payload['billingAddressId'] = billingAddressId;
        }
        if (typeof invites !== 'undefined') {
            payload['invites'] = invites;
        }
        if (typeof couponId !== 'undefined') {
            payload['couponId'] = couponId;
        }
        if (typeof taxId !== 'undefined') {
            payload['taxId'] = taxId;
        }
        if (typeof budget !== 'undefined') {
            payload['budget'] = budget;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    cancelDowngrade(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/plan/cancel'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listRegions(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst
            };
        }
        const organizationId = params.organizationId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/regions'.replace('{organizationId}', organizationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getScopes(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                projectId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const projectId = params.projectId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/roles'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof projectId !== 'undefined') {
            payload['projectId'] = projectId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    setBillingTaxId(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                taxId: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const taxId = params.taxId;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        if (typeof taxId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "taxId"');
        }
        const apiPath = '/organizations/{organizationId}/taxId'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof taxId !== 'undefined') {
            payload['taxId'] = taxId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                startDate: rest[0],
                endDate: rest[1]
            };
        }
        const organizationId = params.organizationId;
        const startDate = params.startDate;
        const endDate = params.endDate;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/usage'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof startDate !== 'undefined') {
            payload['startDate'] = startDate;
        }
        if (typeof endDate !== 'undefined') {
            payload['endDate'] = endDate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    validatePayment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                organizationId: paramsOrFirst,
                invites: rest[0]
            };
        }
        const organizationId = params.organizationId;
        const invites = params.invites;
        if (typeof organizationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "organizationId"');
        }
        const apiPath = '/organizations/{organizationId}/validate'.replace('{organizationId}', organizationId);
        const payload = {};
        if (typeof invites !== 'undefined') {
            payload['invites'] = invites;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
}

class Project {
    constructor(client) {
        this.client = client;
    }
    getUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                startDate: paramsOrFirst,
                endDate: rest[0],
                period: rest[1]
            };
        }
        const startDate = params.startDate;
        const endDate = params.endDate;
        const period = params.period;
        if (typeof startDate === 'undefined') {
            throw new AppwriteException('Missing required parameter: "startDate"');
        }
        if (typeof endDate === 'undefined') {
            throw new AppwriteException('Missing required parameter: "endDate"');
        }
        const apiPath = '/project/usage';
        const payload = {};
        if (typeof startDate !== 'undefined') {
            payload['startDate'] = startDate;
        }
        if (typeof endDate !== 'undefined') {
            payload['endDate'] = endDate;
        }
        if (typeof period !== 'undefined') {
            payload['period'] = period;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * Get a list of all project variables. These variables will be accessible in all Appwrite Functions at runtime.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.VariableList>}
     */
    listVariables() {
        const apiPath = '/project/variables';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                key: paramsOrFirst,
                value: rest[0],
                secret: rest[1]
            };
        }
        const key = params.key;
        const value = params.value;
        const secret = params.secret;
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        const apiPath = '/project/variables';
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getVariable(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                variableId: paramsOrFirst
            };
        }
        const variableId = params.variableId;
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        const apiPath = '/project/variables/{variableId}'.replace('{variableId}', variableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                variableId: paramsOrFirst,
                key: rest[0],
                value: rest[1],
                secret: rest[2]
            };
        }
        const variableId = params.variableId;
        const key = params.key;
        const value = params.value;
        const secret = params.secret;
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/project/variables/{variableId}'.replace('{variableId}', variableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteVariable(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                variableId: paramsOrFirst
            };
        }
        const variableId = params.variableId;
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        const apiPath = '/project/variables/{variableId}'.replace('{variableId}', variableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

class Projects {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/projects';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                name: rest[0],
                teamId: rest[1],
                region: rest[2],
                description: rest[3],
                logo: rest[4],
                url: rest[5],
                legalName: rest[6],
                legalCountry: rest[7],
                legalState: rest[8],
                legalCity: rest[9],
                legalAddress: rest[10],
                legalTaxId: rest[11]
            };
        }
        const projectId = params.projectId;
        const name = params.name;
        const teamId = params.teamId;
        const region = params.region;
        const description = params.description;
        const logo = params.logo;
        const url = params.url;
        const legalName = params.legalName;
        const legalCountry = params.legalCountry;
        const legalState = params.legalState;
        const legalCity = params.legalCity;
        const legalAddress = params.legalAddress;
        const legalTaxId = params.legalTaxId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/projects';
        const payload = {};
        if (typeof projectId !== 'undefined') {
            payload['projectId'] = projectId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof region !== 'undefined') {
            payload['region'] = region;
        }
        if (typeof description !== 'undefined') {
            payload['description'] = description;
        }
        if (typeof logo !== 'undefined') {
            payload['logo'] = logo;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof legalName !== 'undefined') {
            payload['legalName'] = legalName;
        }
        if (typeof legalCountry !== 'undefined') {
            payload['legalCountry'] = legalCountry;
        }
        if (typeof legalState !== 'undefined') {
            payload['legalState'] = legalState;
        }
        if (typeof legalCity !== 'undefined') {
            payload['legalCity'] = legalCity;
        }
        if (typeof legalAddress !== 'undefined') {
            payload['legalAddress'] = legalAddress;
        }
        if (typeof legalTaxId !== 'undefined') {
            payload['legalTaxId'] = legalTaxId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst
            };
        }
        const projectId = params.projectId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}'.replace('{projectId}', projectId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                name: rest[0],
                description: rest[1],
                logo: rest[2],
                url: rest[3],
                legalName: rest[4],
                legalCountry: rest[5],
                legalState: rest[6],
                legalCity: rest[7],
                legalAddress: rest[8],
                legalTaxId: rest[9]
            };
        }
        const projectId = params.projectId;
        const name = params.name;
        const description = params.description;
        const logo = params.logo;
        const url = params.url;
        const legalName = params.legalName;
        const legalCountry = params.legalCountry;
        const legalState = params.legalState;
        const legalCity = params.legalCity;
        const legalAddress = params.legalAddress;
        const legalTaxId = params.legalTaxId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/projects/{projectId}'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof description !== 'undefined') {
            payload['description'] = description;
        }
        if (typeof logo !== 'undefined') {
            payload['logo'] = logo;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof legalName !== 'undefined') {
            payload['legalName'] = legalName;
        }
        if (typeof legalCountry !== 'undefined') {
            payload['legalCountry'] = legalCountry;
        }
        if (typeof legalState !== 'undefined') {
            payload['legalState'] = legalState;
        }
        if (typeof legalCity !== 'undefined') {
            payload['legalCity'] = legalCity;
        }
        if (typeof legalAddress !== 'undefined') {
            payload['legalAddress'] = legalAddress;
        }
        if (typeof legalTaxId !== 'undefined') {
            payload['legalTaxId'] = legalTaxId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst
            };
        }
        const projectId = params.projectId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}'.replace('{projectId}', projectId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateApiStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                api: rest[0],
                status: rest[1]
            };
        }
        const projectId = params.projectId;
        const api = params.api;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof api === 'undefined') {
            throw new AppwriteException('Missing required parameter: "api"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/api'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof api !== 'undefined') {
            payload['api'] = api;
        }
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAPIStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                api: rest[0],
                status: rest[1]
            };
        }
        const projectId = params.projectId;
        const api = params.api;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof api === 'undefined') {
            throw new AppwriteException('Missing required parameter: "api"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/api'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof api !== 'undefined') {
            payload['api'] = api;
        }
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateApiStatusAll(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                status: rest[0]
            };
        }
        const projectId = params.projectId;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/api/all'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAPIStatusAll(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                status: rest[0]
            };
        }
        const projectId = params.projectId;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/api/all'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAuthDuration(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                duration: rest[0]
            };
        }
        const projectId = params.projectId;
        const duration = params.duration;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof duration === 'undefined') {
            throw new AppwriteException('Missing required parameter: "duration"');
        }
        const apiPath = '/projects/{projectId}/auth/duration'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof duration !== 'undefined') {
            payload['duration'] = duration;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAuthLimit(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                limit: rest[0]
            };
        }
        const projectId = params.projectId;
        const limit = params.limit;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof limit === 'undefined') {
            throw new AppwriteException('Missing required parameter: "limit"');
        }
        const apiPath = '/projects/{projectId}/auth/limit'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAuthSessionsLimit(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                limit: rest[0]
            };
        }
        const projectId = params.projectId;
        const limit = params.limit;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof limit === 'undefined') {
            throw new AppwriteException('Missing required parameter: "limit"');
        }
        const apiPath = '/projects/{projectId}/auth/max-sessions'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateMembershipsPrivacy(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                userName: rest[0],
                userEmail: rest[1],
                mfa: rest[2]
            };
        }
        const projectId = params.projectId;
        const userName = params.userName;
        const userEmail = params.userEmail;
        const mfa = params.mfa;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof userName === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userName"');
        }
        if (typeof userEmail === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userEmail"');
        }
        if (typeof mfa === 'undefined') {
            throw new AppwriteException('Missing required parameter: "mfa"');
        }
        const apiPath = '/projects/{projectId}/auth/memberships-privacy'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof userName !== 'undefined') {
            payload['userName'] = userName;
        }
        if (typeof userEmail !== 'undefined') {
            payload['userEmail'] = userEmail;
        }
        if (typeof mfa !== 'undefined') {
            payload['mfa'] = mfa;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateMockNumbers(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                numbers: rest[0]
            };
        }
        const projectId = params.projectId;
        const numbers = params.numbers;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof numbers === 'undefined') {
            throw new AppwriteException('Missing required parameter: "numbers"');
        }
        const apiPath = '/projects/{projectId}/auth/mock-numbers'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof numbers !== 'undefined') {
            payload['numbers'] = numbers;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAuthPasswordDictionary(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                enabled: rest[0]
            };
        }
        const projectId = params.projectId;
        const enabled = params.enabled;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof enabled === 'undefined') {
            throw new AppwriteException('Missing required parameter: "enabled"');
        }
        const apiPath = '/projects/{projectId}/auth/password-dictionary'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAuthPasswordHistory(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                limit: rest[0]
            };
        }
        const projectId = params.projectId;
        const limit = params.limit;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof limit === 'undefined') {
            throw new AppwriteException('Missing required parameter: "limit"');
        }
        const apiPath = '/projects/{projectId}/auth/password-history'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePersonalDataCheck(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                enabled: rest[0]
            };
        }
        const projectId = params.projectId;
        const enabled = params.enabled;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof enabled === 'undefined') {
            throw new AppwriteException('Missing required parameter: "enabled"');
        }
        const apiPath = '/projects/{projectId}/auth/personal-data'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSessionAlerts(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                alerts: rest[0]
            };
        }
        const projectId = params.projectId;
        const alerts = params.alerts;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof alerts === 'undefined') {
            throw new AppwriteException('Missing required parameter: "alerts"');
        }
        const apiPath = '/projects/{projectId}/auth/session-alerts'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof alerts !== 'undefined') {
            payload['alerts'] = alerts;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSessionInvalidation(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                enabled: rest[0]
            };
        }
        const projectId = params.projectId;
        const enabled = params.enabled;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof enabled === 'undefined') {
            throw new AppwriteException('Missing required parameter: "enabled"');
        }
        const apiPath = '/projects/{projectId}/auth/session-invalidation'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateAuthStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                method: rest[0],
                status: rest[1]
            };
        }
        const projectId = params.projectId;
        const method = params.method;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof method === 'undefined') {
            throw new AppwriteException('Missing required parameter: "method"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/auth/{method}'.replace('{projectId}', projectId).replace('{method}', method);
        const payload = {};
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateConsoleAccess(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst
            };
        }
        const projectId = params.projectId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}/console-access'.replace('{projectId}', projectId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listDevKeys(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                queries: rest[0]
            };
        }
        const projectId = params.projectId;
        const queries = params.queries;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}/dev-keys'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createDevKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                name: rest[0],
                expire: rest[1]
            };
        }
        const projectId = params.projectId;
        const name = params.name;
        const expire = params.expire;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof expire === 'undefined') {
            throw new AppwriteException('Missing required parameter: "expire"');
        }
        const apiPath = '/projects/{projectId}/dev-keys'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getDevKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                keyId: rest[0]
            };
        }
        const projectId = params.projectId;
        const keyId = params.keyId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/projects/{projectId}/dev-keys/{keyId}'.replace('{projectId}', projectId).replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateDevKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                keyId: rest[0],
                name: rest[1],
                expire: rest[2]
            };
        }
        const projectId = params.projectId;
        const keyId = params.keyId;
        const name = params.name;
        const expire = params.expire;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof expire === 'undefined') {
            throw new AppwriteException('Missing required parameter: "expire"');
        }
        const apiPath = '/projects/{projectId}/dev-keys/{keyId}'.replace('{projectId}', projectId).replace('{keyId}', keyId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteDevKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                keyId: rest[0]
            };
        }
        const projectId = params.projectId;
        const keyId = params.keyId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/projects/{projectId}/dev-keys/{keyId}'.replace('{projectId}', projectId).replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createJWT(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                scopes: rest[0],
                duration: rest[1]
            };
        }
        const projectId = params.projectId;
        const scopes = params.scopes;
        const duration = params.duration;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/projects/{projectId}/jwts'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof duration !== 'undefined') {
            payload['duration'] = duration;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listKeys(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const projectId = params.projectId;
        const queries = params.queries;
        const total = params.total;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}/keys'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                name: rest[0],
                scopes: rest[1],
                keyId: rest[2],
                expire: rest[3]
            };
        }
        const projectId = params.projectId;
        const name = params.name;
        const scopes = params.scopes;
        const keyId = params.keyId;
        const expire = params.expire;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/projects/{projectId}/keys'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof keyId !== 'undefined') {
            payload['keyId'] = keyId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                keyId: rest[0]
            };
        }
        const projectId = params.projectId;
        const keyId = params.keyId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/projects/{projectId}/keys/{keyId}'.replace('{projectId}', projectId).replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                keyId: rest[0],
                name: rest[1],
                scopes: rest[2],
                expire: rest[3]
            };
        }
        const projectId = params.projectId;
        const keyId = params.keyId;
        const name = params.name;
        const scopes = params.scopes;
        const expire = params.expire;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof scopes === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scopes"');
        }
        const apiPath = '/projects/{projectId}/keys/{keyId}'.replace('{projectId}', projectId).replace('{keyId}', keyId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof scopes !== 'undefined') {
            payload['scopes'] = scopes;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteKey(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                keyId: rest[0]
            };
        }
        const projectId = params.projectId;
        const keyId = params.keyId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof keyId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "keyId"');
        }
        const apiPath = '/projects/{projectId}/keys/{keyId}'.replace('{projectId}', projectId).replace('{keyId}', keyId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateLabels(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                labels: rest[0]
            };
        }
        const projectId = params.projectId;
        const labels = params.labels;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof labels === 'undefined') {
            throw new AppwriteException('Missing required parameter: "labels"');
        }
        const apiPath = '/projects/{projectId}/labels'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof labels !== 'undefined') {
            payload['labels'] = labels;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateOAuth2(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                provider: rest[0],
                appId: rest[1],
                secret: rest[2],
                enabled: rest[3]
            };
        }
        const projectId = params.projectId;
        const provider = params.provider;
        const appId = params.appId;
        const secret = params.secret;
        const enabled = params.enabled;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof provider === 'undefined') {
            throw new AppwriteException('Missing required parameter: "provider"');
        }
        const apiPath = '/projects/{projectId}/oauth2'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof provider !== 'undefined') {
            payload['provider'] = provider;
        }
        if (typeof appId !== 'undefined') {
            payload['appId'] = appId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listPlatforms(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                total: rest[0]
            };
        }
        const projectId = params.projectId;
        const total = params.total;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}/platforms'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createPlatform(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                name: rest[1],
                key: rest[2],
                store: rest[3],
                hostname: rest[4]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const name = params.name;
        const key = params.key;
        const store = params.store;
        const hostname = params.hostname;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/projects/{projectId}/platforms'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof store !== 'undefined') {
            payload['store'] = store;
        }
        if (typeof hostname !== 'undefined') {
            payload['hostname'] = hostname;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getPlatform(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                platformId: rest[0]
            };
        }
        const projectId = params.projectId;
        const platformId = params.platformId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof platformId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "platformId"');
        }
        const apiPath = '/projects/{projectId}/platforms/{platformId}'.replace('{projectId}', projectId).replace('{platformId}', platformId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePlatform(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                platformId: rest[0],
                name: rest[1],
                key: rest[2],
                store: rest[3],
                hostname: rest[4]
            };
        }
        const projectId = params.projectId;
        const platformId = params.platformId;
        const name = params.name;
        const key = params.key;
        const store = params.store;
        const hostname = params.hostname;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof platformId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "platformId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/projects/{projectId}/platforms/{platformId}'.replace('{projectId}', projectId).replace('{platformId}', platformId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof store !== 'undefined') {
            payload['store'] = store;
        }
        if (typeof hostname !== 'undefined') {
            payload['hostname'] = hostname;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deletePlatform(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                platformId: rest[0]
            };
        }
        const projectId = params.projectId;
        const platformId = params.platformId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof platformId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "platformId"');
        }
        const apiPath = '/projects/{projectId}/platforms/{platformId}'.replace('{projectId}', projectId).replace('{platformId}', platformId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listSchedules(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const projectId = params.projectId;
        const queries = params.queries;
        const total = params.total;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}/schedules'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createSchedule(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                resourceType: rest[0],
                resourceId: rest[1],
                schedule: rest[2],
                active: rest[3],
                data: rest[4]
            };
        }
        const projectId = params.projectId;
        const resourceType = params.resourceType;
        const resourceId = params.resourceId;
        const schedule = params.schedule;
        const active = params.active;
        const data = params.data;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof resourceType === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resourceType"');
        }
        if (typeof resourceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resourceId"');
        }
        if (typeof schedule === 'undefined') {
            throw new AppwriteException('Missing required parameter: "schedule"');
        }
        const apiPath = '/projects/{projectId}/schedules'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof resourceType !== 'undefined') {
            payload['resourceType'] = resourceType;
        }
        if (typeof resourceId !== 'undefined') {
            payload['resourceId'] = resourceId;
        }
        if (typeof schedule !== 'undefined') {
            payload['schedule'] = schedule;
        }
        if (typeof active !== 'undefined') {
            payload['active'] = active;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getSchedule(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                scheduleId: rest[0]
            };
        }
        const projectId = params.projectId;
        const scheduleId = params.scheduleId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof scheduleId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "scheduleId"');
        }
        const apiPath = '/projects/{projectId}/schedules/{scheduleId}'.replace('{projectId}', projectId).replace('{scheduleId}', scheduleId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateServiceStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                service: rest[0],
                status: rest[1]
            };
        }
        const projectId = params.projectId;
        const service = params.service;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof service === 'undefined') {
            throw new AppwriteException('Missing required parameter: "service"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/service'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof service !== 'undefined') {
            payload['service'] = service;
        }
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateServiceStatusAll(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                status: rest[0]
            };
        }
        const projectId = params.projectId;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/service/all'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSmtp(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                enabled: rest[0],
                senderName: rest[1],
                senderEmail: rest[2],
                replyTo: rest[3],
                host: rest[4],
                port: rest[5],
                username: rest[6],
                password: rest[7],
                secure: rest[8]
            };
        }
        const projectId = params.projectId;
        const enabled = params.enabled;
        const senderName = params.senderName;
        const senderEmail = params.senderEmail;
        const replyTo = params.replyTo;
        const host = params.host;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const secure = params.secure;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof enabled === 'undefined') {
            throw new AppwriteException('Missing required parameter: "enabled"');
        }
        const apiPath = '/projects/{projectId}/smtp'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof senderName !== 'undefined') {
            payload['senderName'] = senderName;
        }
        if (typeof senderEmail !== 'undefined') {
            payload['senderEmail'] = senderEmail;
        }
        if (typeof replyTo !== 'undefined') {
            payload['replyTo'] = replyTo;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof secure !== 'undefined') {
            payload['secure'] = secure;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSMTP(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                enabled: rest[0],
                senderName: rest[1],
                senderEmail: rest[2],
                replyTo: rest[3],
                host: rest[4],
                port: rest[5],
                username: rest[6],
                password: rest[7],
                secure: rest[8]
            };
        }
        const projectId = params.projectId;
        const enabled = params.enabled;
        const senderName = params.senderName;
        const senderEmail = params.senderEmail;
        const replyTo = params.replyTo;
        const host = params.host;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const secure = params.secure;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof enabled === 'undefined') {
            throw new AppwriteException('Missing required parameter: "enabled"');
        }
        const apiPath = '/projects/{projectId}/smtp'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof senderName !== 'undefined') {
            payload['senderName'] = senderName;
        }
        if (typeof senderEmail !== 'undefined') {
            payload['senderEmail'] = senderEmail;
        }
        if (typeof replyTo !== 'undefined') {
            payload['replyTo'] = replyTo;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof secure !== 'undefined') {
            payload['secure'] = secure;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createSmtpTest(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                emails: rest[0],
                senderName: rest[1],
                senderEmail: rest[2],
                host: rest[3],
                replyTo: rest[4],
                port: rest[5],
                username: rest[6],
                password: rest[7],
                secure: rest[8]
            };
        }
        const projectId = params.projectId;
        const emails = params.emails;
        const senderName = params.senderName;
        const senderEmail = params.senderEmail;
        const host = params.host;
        const replyTo = params.replyTo;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const secure = params.secure;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof emails === 'undefined') {
            throw new AppwriteException('Missing required parameter: "emails"');
        }
        if (typeof senderName === 'undefined') {
            throw new AppwriteException('Missing required parameter: "senderName"');
        }
        if (typeof senderEmail === 'undefined') {
            throw new AppwriteException('Missing required parameter: "senderEmail"');
        }
        if (typeof host === 'undefined') {
            throw new AppwriteException('Missing required parameter: "host"');
        }
        const apiPath = '/projects/{projectId}/smtp/tests'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof emails !== 'undefined') {
            payload['emails'] = emails;
        }
        if (typeof senderName !== 'undefined') {
            payload['senderName'] = senderName;
        }
        if (typeof senderEmail !== 'undefined') {
            payload['senderEmail'] = senderEmail;
        }
        if (typeof replyTo !== 'undefined') {
            payload['replyTo'] = replyTo;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof secure !== 'undefined') {
            payload['secure'] = secure;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createSMTPTest(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                emails: rest[0],
                senderName: rest[1],
                senderEmail: rest[2],
                host: rest[3],
                replyTo: rest[4],
                port: rest[5],
                username: rest[6],
                password: rest[7],
                secure: rest[8]
            };
        }
        const projectId = params.projectId;
        const emails = params.emails;
        const senderName = params.senderName;
        const senderEmail = params.senderEmail;
        const host = params.host;
        const replyTo = params.replyTo;
        const port = params.port;
        const username = params.username;
        const password = params.password;
        const secure = params.secure;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof emails === 'undefined') {
            throw new AppwriteException('Missing required parameter: "emails"');
        }
        if (typeof senderName === 'undefined') {
            throw new AppwriteException('Missing required parameter: "senderName"');
        }
        if (typeof senderEmail === 'undefined') {
            throw new AppwriteException('Missing required parameter: "senderEmail"');
        }
        if (typeof host === 'undefined') {
            throw new AppwriteException('Missing required parameter: "host"');
        }
        const apiPath = '/projects/{projectId}/smtp/tests'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof emails !== 'undefined') {
            payload['emails'] = emails;
        }
        if (typeof senderName !== 'undefined') {
            payload['senderName'] = senderName;
        }
        if (typeof senderEmail !== 'undefined') {
            payload['senderEmail'] = senderEmail;
        }
        if (typeof replyTo !== 'undefined') {
            payload['replyTo'] = replyTo;
        }
        if (typeof host !== 'undefined') {
            payload['host'] = host;
        }
        if (typeof port !== 'undefined') {
            payload['port'] = port;
        }
        if (typeof username !== 'undefined') {
            payload['username'] = username;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof secure !== 'undefined') {
            payload['secure'] = secure;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                status: rest[0]
            };
        }
        const projectId = params.projectId;
        const status = params.status;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/projects/{projectId}/status'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateTeam(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                teamId: rest[0]
            };
        }
        const projectId = params.projectId;
        const teamId = params.teamId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/projects/{projectId}/team'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getEmailTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        const apiPath = '/projects/{projectId}/templates/email/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateEmailTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1],
                subject: rest[2],
                message: rest[3],
                senderName: rest[4],
                senderEmail: rest[5],
                replyTo: rest[6]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        const subject = params.subject;
        const message = params.message;
        const senderName = params.senderName;
        const senderEmail = params.senderEmail;
        const replyTo = params.replyTo;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        if (typeof subject === 'undefined') {
            throw new AppwriteException('Missing required parameter: "subject"');
        }
        if (typeof message === 'undefined') {
            throw new AppwriteException('Missing required parameter: "message"');
        }
        const apiPath = '/projects/{projectId}/templates/email/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        if (typeof subject !== 'undefined') {
            payload['subject'] = subject;
        }
        if (typeof message !== 'undefined') {
            payload['message'] = message;
        }
        if (typeof senderName !== 'undefined') {
            payload['senderName'] = senderName;
        }
        if (typeof senderEmail !== 'undefined') {
            payload['senderEmail'] = senderEmail;
        }
        if (typeof replyTo !== 'undefined') {
            payload['replyTo'] = replyTo;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteEmailTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        const apiPath = '/projects/{projectId}/templates/email/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getSmsTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        const apiPath = '/projects/{projectId}/templates/sms/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getSMSTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        const apiPath = '/projects/{projectId}/templates/sms/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateSmsTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1],
                message: rest[2]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        const message = params.message;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        if (typeof message === 'undefined') {
            throw new AppwriteException('Missing required parameter: "message"');
        }
        const apiPath = '/projects/{projectId}/templates/sms/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        if (typeof message !== 'undefined') {
            payload['message'] = message;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateSMSTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1],
                message: rest[2]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        const message = params.message;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        if (typeof message === 'undefined') {
            throw new AppwriteException('Missing required parameter: "message"');
        }
        const apiPath = '/projects/{projectId}/templates/sms/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        if (typeof message !== 'undefined') {
            payload['message'] = message;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteSmsTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        const apiPath = '/projects/{projectId}/templates/sms/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    deleteSMSTemplate(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                type: rest[0],
                locale: rest[1]
            };
        }
        const projectId = params.projectId;
        const type = params.type;
        const locale = params.locale;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof locale === 'undefined') {
            throw new AppwriteException('Missing required parameter: "locale"');
        }
        const apiPath = '/projects/{projectId}/templates/sms/{type}/{locale}'.replace('{projectId}', projectId).replace('{type}', type).replace('{locale}', locale);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listWebhooks(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                total: rest[0]
            };
        }
        const projectId = params.projectId;
        const total = params.total;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        const apiPath = '/projects/{projectId}/webhooks'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createWebhook(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                name: rest[0],
                events: rest[1],
                url: rest[2],
                security: rest[3],
                enabled: rest[4],
                httpUser: rest[5],
                httpPass: rest[6]
            };
        }
        const projectId = params.projectId;
        const name = params.name;
        const events = params.events;
        const url = params.url;
        const security = params.security;
        const enabled = params.enabled;
        const httpUser = params.httpUser;
        const httpPass = params.httpPass;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof events === 'undefined') {
            throw new AppwriteException('Missing required parameter: "events"');
        }
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        if (typeof security === 'undefined') {
            throw new AppwriteException('Missing required parameter: "security"');
        }
        const apiPath = '/projects/{projectId}/webhooks'.replace('{projectId}', projectId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof events !== 'undefined') {
            payload['events'] = events;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof security !== 'undefined') {
            payload['security'] = security;
        }
        if (typeof httpUser !== 'undefined') {
            payload['httpUser'] = httpUser;
        }
        if (typeof httpPass !== 'undefined') {
            payload['httpPass'] = httpPass;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getWebhook(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                webhookId: rest[0]
            };
        }
        const projectId = params.projectId;
        const webhookId = params.webhookId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof webhookId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "webhookId"');
        }
        const apiPath = '/projects/{projectId}/webhooks/{webhookId}'.replace('{projectId}', projectId).replace('{webhookId}', webhookId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateWebhook(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                webhookId: rest[0],
                name: rest[1],
                events: rest[2],
                url: rest[3],
                security: rest[4],
                enabled: rest[5],
                httpUser: rest[6],
                httpPass: rest[7]
            };
        }
        const projectId = params.projectId;
        const webhookId = params.webhookId;
        const name = params.name;
        const events = params.events;
        const url = params.url;
        const security = params.security;
        const enabled = params.enabled;
        const httpUser = params.httpUser;
        const httpPass = params.httpPass;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof webhookId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "webhookId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof events === 'undefined') {
            throw new AppwriteException('Missing required parameter: "events"');
        }
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        if (typeof security === 'undefined') {
            throw new AppwriteException('Missing required parameter: "security"');
        }
        const apiPath = '/projects/{projectId}/webhooks/{webhookId}'.replace('{projectId}', projectId).replace('{webhookId}', webhookId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof events !== 'undefined') {
            payload['events'] = events;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof security !== 'undefined') {
            payload['security'] = security;
        }
        if (typeof httpUser !== 'undefined') {
            payload['httpUser'] = httpUser;
        }
        if (typeof httpPass !== 'undefined') {
            payload['httpPass'] = httpPass;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteWebhook(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                webhookId: rest[0]
            };
        }
        const projectId = params.projectId;
        const webhookId = params.webhookId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof webhookId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "webhookId"');
        }
        const apiPath = '/projects/{projectId}/webhooks/{webhookId}'.replace('{projectId}', projectId).replace('{webhookId}', webhookId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateWebhookSignature(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                projectId: paramsOrFirst,
                webhookId: rest[0]
            };
        }
        const projectId = params.projectId;
        const webhookId = params.webhookId;
        if (typeof projectId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "projectId"');
        }
        if (typeof webhookId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "webhookId"');
        }
        const apiPath = '/projects/{projectId}/webhooks/{webhookId}/signature'.replace('{projectId}', projectId).replace('{webhookId}', webhookId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
}

class Proxy {
    constructor(client) {
        this.client = client;
    }
    listRules(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/proxy/rules';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createAPIRule(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst
            };
        }
        const domain = params.domain;
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        const apiPath = '/proxy/rules/api';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createFunctionRule(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst,
                functionId: rest[0],
                branch: rest[1]
            };
        }
        const domain = params.domain;
        const functionId = params.functionId;
        const branch = params.branch;
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        if (typeof functionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "functionId"');
        }
        const apiPath = '/proxy/rules/function';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof functionId !== 'undefined') {
            payload['functionId'] = functionId;
        }
        if (typeof branch !== 'undefined') {
            payload['branch'] = branch;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createRedirectRule(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst,
                url: rest[0],
                statusCode: rest[1],
                resourceId: rest[2],
                resourceType: rest[3]
            };
        }
        const domain = params.domain;
        const url = params.url;
        const statusCode = params.statusCode;
        const resourceId = params.resourceId;
        const resourceType = params.resourceType;
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        if (typeof url === 'undefined') {
            throw new AppwriteException('Missing required parameter: "url"');
        }
        if (typeof statusCode === 'undefined') {
            throw new AppwriteException('Missing required parameter: "statusCode"');
        }
        if (typeof resourceId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resourceId"');
        }
        if (typeof resourceType === 'undefined') {
            throw new AppwriteException('Missing required parameter: "resourceType"');
        }
        const apiPath = '/proxy/rules/redirect';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof statusCode !== 'undefined') {
            payload['statusCode'] = statusCode;
        }
        if (typeof resourceId !== 'undefined') {
            payload['resourceId'] = resourceId;
        }
        if (typeof resourceType !== 'undefined') {
            payload['resourceType'] = resourceType;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createSiteRule(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                domain: paramsOrFirst,
                siteId: rest[0],
                branch: rest[1]
            };
        }
        const domain = params.domain;
        const siteId = params.siteId;
        const branch = params.branch;
        if (typeof domain === 'undefined') {
            throw new AppwriteException('Missing required parameter: "domain"');
        }
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/proxy/rules/site';
        const payload = {};
        if (typeof domain !== 'undefined') {
            payload['domain'] = domain;
        }
        if (typeof siteId !== 'undefined') {
            payload['siteId'] = siteId;
        }
        if (typeof branch !== 'undefined') {
            payload['branch'] = branch;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getRule(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ruleId: paramsOrFirst
            };
        }
        const ruleId = params.ruleId;
        if (typeof ruleId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ruleId"');
        }
        const apiPath = '/proxy/rules/{ruleId}'.replace('{ruleId}', ruleId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteRule(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ruleId: paramsOrFirst
            };
        }
        const ruleId = params.ruleId;
        if (typeof ruleId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ruleId"');
        }
        const apiPath = '/proxy/rules/{ruleId}'.replace('{ruleId}', ruleId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateRuleVerification(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ruleId: paramsOrFirst
            };
        }
        const ruleId = params.ruleId;
        if (typeof ruleId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "ruleId"');
        }
        const apiPath = '/proxy/rules/{ruleId}/verification'.replace('{ruleId}', ruleId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
}

class Sites {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/sites';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                name: rest[0],
                framework: rest[1],
                buildRuntime: rest[2],
                enabled: rest[3],
                logging: rest[4],
                timeout: rest[5],
                installCommand: rest[6],
                buildCommand: rest[7],
                outputDirectory: rest[8],
                adapter: rest[9],
                installationId: rest[10],
                fallbackFile: rest[11],
                providerRepositoryId: rest[12],
                providerBranch: rest[13],
                providerSilentMode: rest[14],
                providerRootDirectory: rest[15],
                specification: rest[16]
            };
        }
        const siteId = params.siteId;
        const name = params.name;
        const framework = params.framework;
        const buildRuntime = params.buildRuntime;
        const enabled = params.enabled;
        const logging = params.logging;
        const timeout = params.timeout;
        const installCommand = params.installCommand;
        const buildCommand = params.buildCommand;
        const outputDirectory = params.outputDirectory;
        const adapter = params.adapter;
        const installationId = params.installationId;
        const fallbackFile = params.fallbackFile;
        const providerRepositoryId = params.providerRepositoryId;
        const providerBranch = params.providerBranch;
        const providerSilentMode = params.providerSilentMode;
        const providerRootDirectory = params.providerRootDirectory;
        const specification = params.specification;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof framework === 'undefined') {
            throw new AppwriteException('Missing required parameter: "framework"');
        }
        if (typeof buildRuntime === 'undefined') {
            throw new AppwriteException('Missing required parameter: "buildRuntime"');
        }
        const apiPath = '/sites';
        const payload = {};
        if (typeof siteId !== 'undefined') {
            payload['siteId'] = siteId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof framework !== 'undefined') {
            payload['framework'] = framework;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof logging !== 'undefined') {
            payload['logging'] = logging;
        }
        if (typeof timeout !== 'undefined') {
            payload['timeout'] = timeout;
        }
        if (typeof installCommand !== 'undefined') {
            payload['installCommand'] = installCommand;
        }
        if (typeof buildCommand !== 'undefined') {
            payload['buildCommand'] = buildCommand;
        }
        if (typeof outputDirectory !== 'undefined') {
            payload['outputDirectory'] = outputDirectory;
        }
        if (typeof buildRuntime !== 'undefined') {
            payload['buildRuntime'] = buildRuntime;
        }
        if (typeof adapter !== 'undefined') {
            payload['adapter'] = adapter;
        }
        if (typeof installationId !== 'undefined') {
            payload['installationId'] = installationId;
        }
        if (typeof fallbackFile !== 'undefined') {
            payload['fallbackFile'] = fallbackFile;
        }
        if (typeof providerRepositoryId !== 'undefined') {
            payload['providerRepositoryId'] = providerRepositoryId;
        }
        if (typeof providerBranch !== 'undefined') {
            payload['providerBranch'] = providerBranch;
        }
        if (typeof providerSilentMode !== 'undefined') {
            payload['providerSilentMode'] = providerSilentMode;
        }
        if (typeof providerRootDirectory !== 'undefined') {
            payload['providerRootDirectory'] = providerRootDirectory;
        }
        if (typeof specification !== 'undefined') {
            payload['specification'] = specification;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    /**
     * Get a list of all frameworks that are currently available on the server instance.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.FrameworkList>}
     */
    listFrameworks() {
        const apiPath = '/sites/frameworks';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    /**
     * List allowed site specifications for this instance.
     *
     * @throws {AppwriteException}
     * @returns {Promise<Models.SpecificationList>}
     */
    listSpecifications() {
        const apiPath = '/sites/specifications';
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listTemplates(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('frameworks' in paramsOrFirst || 'useCases' in paramsOrFirst || 'limit' in paramsOrFirst || 'offset' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                frameworks: paramsOrFirst,
                useCases: rest[0],
                limit: rest[1],
                offset: rest[2]
            };
        }
        const frameworks = params.frameworks;
        const useCases = params.useCases;
        const limit = params.limit;
        const offset = params.offset;
        const apiPath = '/sites/templates';
        const payload = {};
        if (typeof frameworks !== 'undefined') {
            payload['frameworks'] = frameworks;
        }
        if (typeof useCases !== 'undefined') {
            payload['useCases'] = useCases;
        }
        if (typeof limit !== 'undefined') {
            payload['limit'] = limit;
        }
        if (typeof offset !== 'undefined') {
            payload['offset'] = offset;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getTemplate(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                templateId: paramsOrFirst
            };
        }
        const templateId = params.templateId;
        if (typeof templateId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "templateId"');
        }
        const apiPath = '/sites/templates/{templateId}'.replace('{templateId}', templateId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('range' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                range: paramsOrFirst
            };
        }
        const range = params.range;
        const apiPath = '/sites/usage';
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst
            };
        }
        const siteId = params.siteId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/sites/{siteId}'.replace('{siteId}', siteId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                name: rest[0],
                framework: rest[1],
                enabled: rest[2],
                logging: rest[3],
                timeout: rest[4],
                installCommand: rest[5],
                buildCommand: rest[6],
                outputDirectory: rest[7],
                buildRuntime: rest[8],
                adapter: rest[9],
                fallbackFile: rest[10],
                installationId: rest[11],
                providerRepositoryId: rest[12],
                providerBranch: rest[13],
                providerSilentMode: rest[14],
                providerRootDirectory: rest[15],
                specification: rest[16]
            };
        }
        const siteId = params.siteId;
        const name = params.name;
        const framework = params.framework;
        const enabled = params.enabled;
        const logging = params.logging;
        const timeout = params.timeout;
        const installCommand = params.installCommand;
        const buildCommand = params.buildCommand;
        const outputDirectory = params.outputDirectory;
        const buildRuntime = params.buildRuntime;
        const adapter = params.adapter;
        const fallbackFile = params.fallbackFile;
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        const providerBranch = params.providerBranch;
        const providerSilentMode = params.providerSilentMode;
        const providerRootDirectory = params.providerRootDirectory;
        const specification = params.specification;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof framework === 'undefined') {
            throw new AppwriteException('Missing required parameter: "framework"');
        }
        const apiPath = '/sites/{siteId}'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof framework !== 'undefined') {
            payload['framework'] = framework;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof logging !== 'undefined') {
            payload['logging'] = logging;
        }
        if (typeof timeout !== 'undefined') {
            payload['timeout'] = timeout;
        }
        if (typeof installCommand !== 'undefined') {
            payload['installCommand'] = installCommand;
        }
        if (typeof buildCommand !== 'undefined') {
            payload['buildCommand'] = buildCommand;
        }
        if (typeof outputDirectory !== 'undefined') {
            payload['outputDirectory'] = outputDirectory;
        }
        if (typeof buildRuntime !== 'undefined') {
            payload['buildRuntime'] = buildRuntime;
        }
        if (typeof adapter !== 'undefined') {
            payload['adapter'] = adapter;
        }
        if (typeof fallbackFile !== 'undefined') {
            payload['fallbackFile'] = fallbackFile;
        }
        if (typeof installationId !== 'undefined') {
            payload['installationId'] = installationId;
        }
        if (typeof providerRepositoryId !== 'undefined') {
            payload['providerRepositoryId'] = providerRepositoryId;
        }
        if (typeof providerBranch !== 'undefined') {
            payload['providerBranch'] = providerBranch;
        }
        if (typeof providerSilentMode !== 'undefined') {
            payload['providerSilentMode'] = providerSilentMode;
        }
        if (typeof providerRootDirectory !== 'undefined') {
            payload['providerRootDirectory'] = providerRootDirectory;
        }
        if (typeof specification !== 'undefined') {
            payload['specification'] = specification;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst
            };
        }
        const siteId = params.siteId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/sites/{siteId}'.replace('{siteId}', siteId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateSiteDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const siteId = params.siteId;
        const deploymentId = params.deploymentId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/sites/{siteId}/deployment'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof deploymentId !== 'undefined') {
            payload['deploymentId'] = deploymentId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listDeployments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const siteId = params.siteId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/sites/{siteId}/deployments'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createDeployment(paramsOrFirst, ...rest) {
        let params;
        let onProgress;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
            onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;
        }
        else {
            params = {
                siteId: paramsOrFirst,
                code: rest[0],
                activate: rest[1],
                installCommand: rest[2],
                buildCommand: rest[3],
                outputDirectory: rest[4]
            };
            onProgress = rest[5];
        }
        const siteId = params.siteId;
        const code = params.code;
        const activate = params.activate;
        const installCommand = params.installCommand;
        const buildCommand = params.buildCommand;
        const outputDirectory = params.outputDirectory;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof code === 'undefined') {
            throw new AppwriteException('Missing required parameter: "code"');
        }
        if (typeof activate === 'undefined') {
            throw new AppwriteException('Missing required parameter: "activate"');
        }
        const apiPath = '/sites/{siteId}/deployments'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof installCommand !== 'undefined') {
            payload['installCommand'] = installCommand;
        }
        if (typeof buildCommand !== 'undefined') {
            payload['buildCommand'] = buildCommand;
        }
        if (typeof outputDirectory !== 'undefined') {
            payload['outputDirectory'] = outputDirectory;
        }
        if (typeof code !== 'undefined') {
            payload['code'] = code;
        }
        if (typeof activate !== 'undefined') {
            payload['activate'] = activate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'multipart/form-data',
        };
        return this.client.chunkedUpload('post', uri, apiHeaders, payload, onProgress);
    }
    createDuplicateDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const siteId = params.siteId;
        const deploymentId = params.deploymentId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/sites/{siteId}/deployments/duplicate'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof deploymentId !== 'undefined') {
            payload['deploymentId'] = deploymentId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createTemplateDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                repository: rest[0],
                owner: rest[1],
                rootDirectory: rest[2],
                type: rest[3],
                reference: rest[4],
                activate: rest[5]
            };
        }
        const siteId = params.siteId;
        const repository = params.repository;
        const owner = params.owner;
        const rootDirectory = params.rootDirectory;
        const type = params.type;
        const reference = params.reference;
        const activate = params.activate;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof repository === 'undefined') {
            throw new AppwriteException('Missing required parameter: "repository"');
        }
        if (typeof owner === 'undefined') {
            throw new AppwriteException('Missing required parameter: "owner"');
        }
        if (typeof rootDirectory === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rootDirectory"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof reference === 'undefined') {
            throw new AppwriteException('Missing required parameter: "reference"');
        }
        const apiPath = '/sites/{siteId}/deployments/template'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof repository !== 'undefined') {
            payload['repository'] = repository;
        }
        if (typeof owner !== 'undefined') {
            payload['owner'] = owner;
        }
        if (typeof rootDirectory !== 'undefined') {
            payload['rootDirectory'] = rootDirectory;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof reference !== 'undefined') {
            payload['reference'] = reference;
        }
        if (typeof activate !== 'undefined') {
            payload['activate'] = activate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createVcsDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                type: rest[0],
                reference: rest[1],
                activate: rest[2]
            };
        }
        const siteId = params.siteId;
        const type = params.type;
        const reference = params.reference;
        const activate = params.activate;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof reference === 'undefined') {
            throw new AppwriteException('Missing required parameter: "reference"');
        }
        const apiPath = '/sites/{siteId}/deployments/vcs'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof reference !== 'undefined') {
            payload['reference'] = reference;
        }
        if (typeof activate !== 'undefined') {
            payload['activate'] = activate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const siteId = params.siteId;
        const deploymentId = params.deploymentId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/sites/{siteId}/deployments/{deploymentId}'.replace('{siteId}', siteId).replace('{deploymentId}', deploymentId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteDeployment(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const siteId = params.siteId;
        const deploymentId = params.deploymentId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/sites/{siteId}/deployments/{deploymentId}'.replace('{siteId}', siteId).replace('{deploymentId}', deploymentId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getDeploymentDownload(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                deploymentId: rest[0],
                type: rest[1]
            };
        }
        const siteId = params.siteId;
        const deploymentId = params.deploymentId;
        const type = params.type;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/sites/{siteId}/deployments/{deploymentId}/download'.replace('{siteId}', siteId).replace('{deploymentId}', deploymentId);
        const payload = {};
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    updateDeploymentStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                deploymentId: rest[0]
            };
        }
        const siteId = params.siteId;
        const deploymentId = params.deploymentId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof deploymentId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "deploymentId"');
        }
        const apiPath = '/sites/{siteId}/deployments/{deploymentId}/status'.replace('{siteId}', siteId).replace('{deploymentId}', deploymentId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const siteId = params.siteId;
        const queries = params.queries;
        const total = params.total;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/sites/{siteId}/logs'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getLog(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                logId: rest[0]
            };
        }
        const siteId = params.siteId;
        const logId = params.logId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof logId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "logId"');
        }
        const apiPath = '/sites/{siteId}/logs/{logId}'.replace('{siteId}', siteId).replace('{logId}', logId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteLog(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                logId: rest[0]
            };
        }
        const siteId = params.siteId;
        const logId = params.logId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof logId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "logId"');
        }
        const apiPath = '/sites/{siteId}/logs/{logId}'.replace('{siteId}', siteId).replace('{logId}', logId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                range: rest[0]
            };
        }
        const siteId = params.siteId;
        const range = params.range;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/sites/{siteId}/usage'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listVariables(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst
            };
        }
        const siteId = params.siteId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        const apiPath = '/sites/{siteId}/variables'.replace('{siteId}', siteId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                key: rest[0],
                value: rest[1],
                secret: rest[2]
            };
        }
        const siteId = params.siteId;
        const key = params.key;
        const value = params.value;
        const secret = params.secret;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof value === 'undefined') {
            throw new AppwriteException('Missing required parameter: "value"');
        }
        const apiPath = '/sites/{siteId}/variables'.replace('{siteId}', siteId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                variableId: rest[0]
            };
        }
        const siteId = params.siteId;
        const variableId = params.variableId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        const apiPath = '/sites/{siteId}/variables/{variableId}'.replace('{siteId}', siteId).replace('{variableId}', variableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                variableId: rest[0],
                key: rest[1],
                value: rest[2],
                secret: rest[3]
            };
        }
        const siteId = params.siteId;
        const variableId = params.variableId;
        const key = params.key;
        const value = params.value;
        const secret = params.secret;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/sites/{siteId}/variables/{variableId}'.replace('{siteId}', siteId).replace('{variableId}', variableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteVariable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                siteId: paramsOrFirst,
                variableId: rest[0]
            };
        }
        const siteId = params.siteId;
        const variableId = params.variableId;
        if (typeof siteId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "siteId"');
        }
        if (typeof variableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "variableId"');
        }
        const apiPath = '/sites/{siteId}/variables/{variableId}'.replace('{siteId}', siteId).replace('{variableId}', variableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

class Storage {
    constructor(client) {
        this.client = client;
    }
    listBuckets(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/storage/buckets';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createBucket(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                name: rest[0],
                permissions: rest[1],
                fileSecurity: rest[2],
                enabled: rest[3],
                maximumFileSize: rest[4],
                allowedFileExtensions: rest[5],
                compression: rest[6],
                encryption: rest[7],
                antivirus: rest[8],
                transformations: rest[9]
            };
        }
        const bucketId = params.bucketId;
        const name = params.name;
        const permissions = params.permissions;
        const fileSecurity = params.fileSecurity;
        const enabled = params.enabled;
        const maximumFileSize = params.maximumFileSize;
        const allowedFileExtensions = params.allowedFileExtensions;
        const compression = params.compression;
        const encryption = params.encryption;
        const antivirus = params.antivirus;
        const transformations = params.transformations;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/storage/buckets';
        const payload = {};
        if (typeof bucketId !== 'undefined') {
            payload['bucketId'] = bucketId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof fileSecurity !== 'undefined') {
            payload['fileSecurity'] = fileSecurity;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof maximumFileSize !== 'undefined') {
            payload['maximumFileSize'] = maximumFileSize;
        }
        if (typeof allowedFileExtensions !== 'undefined') {
            payload['allowedFileExtensions'] = allowedFileExtensions;
        }
        if (typeof compression !== 'undefined') {
            payload['compression'] = compression;
        }
        if (typeof encryption !== 'undefined') {
            payload['encryption'] = encryption;
        }
        if (typeof antivirus !== 'undefined') {
            payload['antivirus'] = antivirus;
        }
        if (typeof transformations !== 'undefined') {
            payload['transformations'] = transformations;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getBucket(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst
            };
        }
        const bucketId = params.bucketId;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateBucket(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                name: rest[0],
                permissions: rest[1],
                fileSecurity: rest[2],
                enabled: rest[3],
                maximumFileSize: rest[4],
                allowedFileExtensions: rest[5],
                compression: rest[6],
                encryption: rest[7],
                antivirus: rest[8],
                transformations: rest[9]
            };
        }
        const bucketId = params.bucketId;
        const name = params.name;
        const permissions = params.permissions;
        const fileSecurity = params.fileSecurity;
        const enabled = params.enabled;
        const maximumFileSize = params.maximumFileSize;
        const allowedFileExtensions = params.allowedFileExtensions;
        const compression = params.compression;
        const encryption = params.encryption;
        const antivirus = params.antivirus;
        const transformations = params.transformations;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof fileSecurity !== 'undefined') {
            payload['fileSecurity'] = fileSecurity;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof maximumFileSize !== 'undefined') {
            payload['maximumFileSize'] = maximumFileSize;
        }
        if (typeof allowedFileExtensions !== 'undefined') {
            payload['allowedFileExtensions'] = allowedFileExtensions;
        }
        if (typeof compression !== 'undefined') {
            payload['compression'] = compression;
        }
        if (typeof encryption !== 'undefined') {
            payload['encryption'] = encryption;
        }
        if (typeof antivirus !== 'undefined') {
            payload['antivirus'] = antivirus;
        }
        if (typeof transformations !== 'undefined') {
            payload['transformations'] = transformations;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteBucket(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst
            };
        }
        const bucketId = params.bucketId;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        const apiPath = '/storage/buckets/{bucketId}'.replace('{bucketId}', bucketId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listFiles(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const bucketId = params.bucketId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createFile(paramsOrFirst, ...rest) {
        let params;
        let onProgress;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
            onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                file: rest[1],
                permissions: rest[2]
            };
            onProgress = rest[3];
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const file = params.file;
        const permissions = params.permissions;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        if (typeof file === 'undefined') {
            throw new AppwriteException('Missing required parameter: "file"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);
        const payload = {};
        if (typeof fileId !== 'undefined') {
            payload['fileId'] = fileId;
        }
        if (typeof file !== 'undefined') {
            payload['file'] = file;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'multipart/form-data',
        };
        return this.client.chunkedUpload('post', uri, apiHeaders, payload, onProgress);
    }
    getFile(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateFile(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                name: rest[1],
                permissions: rest[2]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const name = params.name;
        const permissions = params.permissions;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteFile(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getFileDownload(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                token: rest[1]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const token = params.token;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getFilePreview(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                width: rest[1],
                height: rest[2],
                gravity: rest[3],
                quality: rest[4],
                borderWidth: rest[5],
                borderColor: rest[6],
                borderRadius: rest[7],
                opacity: rest[8],
                rotation: rest[9],
                background: rest[10],
                output: rest[11],
                token: rest[12]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const width = params.width;
        const height = params.height;
        const gravity = params.gravity;
        const quality = params.quality;
        const borderWidth = params.borderWidth;
        const borderColor = params.borderColor;
        const borderRadius = params.borderRadius;
        const opacity = params.opacity;
        const rotation = params.rotation;
        const background = params.background;
        const output = params.output;
        const token = params.token;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof width !== 'undefined') {
            payload['width'] = width;
        }
        if (typeof height !== 'undefined') {
            payload['height'] = height;
        }
        if (typeof gravity !== 'undefined') {
            payload['gravity'] = gravity;
        }
        if (typeof quality !== 'undefined') {
            payload['quality'] = quality;
        }
        if (typeof borderWidth !== 'undefined') {
            payload['borderWidth'] = borderWidth;
        }
        if (typeof borderColor !== 'undefined') {
            payload['borderColor'] = borderColor;
        }
        if (typeof borderRadius !== 'undefined') {
            payload['borderRadius'] = borderRadius;
        }
        if (typeof opacity !== 'undefined') {
            payload['opacity'] = opacity;
        }
        if (typeof rotation !== 'undefined') {
            payload['rotation'] = rotation;
        }
        if (typeof background !== 'undefined') {
            payload['background'] = background;
        }
        if (typeof output !== 'undefined') {
            payload['output'] = output;
        }
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getFileView(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                token: rest[1]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const token = params.token;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof token !== 'undefined') {
            payload['token'] = token;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        payload['project'] = this.client.config.project;
        for (const [key, value] of Object.entries(Service.flatten(payload))) {
            uri.searchParams.append(key, value);
        }
        return uri.toString();
    }
    getUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('range' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                range: paramsOrFirst
            };
        }
        const range = params.range;
        const apiPath = '/storage/usage';
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getBucketUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                range: rest[0]
            };
        }
        const bucketId = params.bucketId;
        const range = params.range;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        const apiPath = '/storage/{bucketId}/usage'.replace('{bucketId}', bucketId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class TablesDB {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/tablesdb';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const name = params.name;
        const enabled = params.enabled;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/tablesdb';
        const payload = {};
        if (typeof databaseId !== 'undefined') {
            payload['databaseId'] = databaseId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listTransactions(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst
            };
        }
        const queries = params.queries;
        const apiPath = '/tablesdb/transactions';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createTransaction(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                ttl: paramsOrFirst
            };
        }
        const ttl = params.ttl;
        const apiPath = '/tablesdb/transactions';
        const payload = {};
        if (typeof ttl !== 'undefined') {
            payload['ttl'] = ttl;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateTransaction(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                commit: rest[0],
                rollback: rest[1]
            };
        }
        const transactionId = params.transactionId;
        const commit = params.commit;
        const rollback = params.rollback;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof commit !== 'undefined') {
            payload['commit'] = commit;
        }
        if (typeof rollback !== 'undefined') {
            payload['rollback'] = rollback;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteTransaction(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst
            };
        }
        const transactionId = params.transactionId;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createOperations(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                transactionId: paramsOrFirst,
                operations: rest[0]
            };
        }
        const transactionId = params.transactionId;
        const operations = params.operations;
        if (typeof transactionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "transactionId"');
        }
        const apiPath = '/tablesdb/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);
        const payload = {};
        if (typeof operations !== 'undefined') {
            payload['operations'] = operations;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('range' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                range: paramsOrFirst
            };
        }
        const range = params.range;
        const apiPath = '/tablesdb/usage';
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst
            };
        }
        const databaseId = params.databaseId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/tablesdb/{databaseId}'.replace('{databaseId}', databaseId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                name: rest[0],
                enabled: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const name = params.name;
        const enabled = params.enabled;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/tablesdb/{databaseId}'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst
            };
        }
        const databaseId = params.databaseId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/tablesdb/{databaseId}'.replace('{databaseId}', databaseId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listTables(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createTable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                name: rest[1],
                permissions: rest[2],
                rowSecurity: rest[3],
                enabled: rest[4],
                columns: rest[5],
                indexes: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const name = params.name;
        const permissions = params.permissions;
        const rowSecurity = params.rowSecurity;
        const enabled = params.enabled;
        const columns = params.columns;
        const indexes = params.indexes;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof tableId !== 'undefined') {
            payload['tableId'] = tableId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof rowSecurity !== 'undefined') {
            payload['rowSecurity'] = rowSecurity;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        if (typeof columns !== 'undefined') {
            payload['columns'] = columns;
        }
        if (typeof indexes !== 'undefined') {
            payload['indexes'] = indexes;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getTable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateTable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                name: rest[1],
                permissions: rest[2],
                rowSecurity: rest[3],
                enabled: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const name = params.name;
        const permissions = params.permissions;
        const rowSecurity = params.rowSecurity;
        const enabled = params.enabled;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof rowSecurity !== 'undefined') {
            payload['rowSecurity'] = rowSecurity;
        }
        if (typeof enabled !== 'undefined') {
            payload['enabled'] = enabled;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    deleteTable(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listColumns(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                queries: rest[1],
                total: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const queries = params.queries;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createBooleanColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/boolean'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateBooleanColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/boolean/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createDatetimeColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/datetime'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateDatetimeColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/datetime/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createEmailColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/email'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEmailColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/email/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createEnumColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                elements: rest[2],
                required: rest[3],
                xdefault: rest[4],
                array: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const elements = params.elements;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof elements === 'undefined') {
            throw new AppwriteException('Missing required parameter: "elements"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/enum'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof elements !== 'undefined') {
            payload['elements'] = elements;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEnumColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                elements: rest[2],
                required: rest[3],
                xdefault: rest[4],
                newKey: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const elements = params.elements;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof elements === 'undefined') {
            throw new AppwriteException('Missing required parameter: "elements"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/enum/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof elements !== 'undefined') {
            payload['elements'] = elements;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createFloatColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                min: rest[3],
                max: rest[4],
                xdefault: rest[5],
                array: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const min = params.min;
        const max = params.max;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/float'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateFloatColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                min: rest[4],
                max: rest[5],
                newKey: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const min = params.min;
        const max = params.max;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/float/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createIntegerColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                min: rest[3],
                max: rest[4],
                xdefault: rest[5],
                array: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const min = params.min;
        const max = params.max;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/integer'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateIntegerColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                min: rest[4],
                max: rest[5],
                newKey: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const min = params.min;
        const max = params.max;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/integer/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createIpColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/ip'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateIpColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/ip/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createLineColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/line'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateLineColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/line/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createLongtextColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4],
                encrypt: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/longtext'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateLongtextColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/longtext/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createMediumtextColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4],
                encrypt: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/mediumtext'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateMediumtextColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/mediumtext/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createPointColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/point'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePointColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/point/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createPolygonColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/polygon'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updatePolygonColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/polygon/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createRelationshipColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                relatedTableId: rest[1],
                type: rest[2],
                twoWay: rest[3],
                key: rest[4],
                twoWayKey: rest[5],
                onDelete: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const relatedTableId = params.relatedTableId;
        const type = params.type;
        const twoWay = params.twoWay;
        const key = params.key;
        const twoWayKey = params.twoWayKey;
        const onDelete = params.onDelete;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof relatedTableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "relatedTableId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/relationship'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof relatedTableId !== 'undefined') {
            payload['relatedTableId'] = relatedTableId;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof twoWay !== 'undefined') {
            payload['twoWay'] = twoWay;
        }
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof twoWayKey !== 'undefined') {
            payload['twoWayKey'] = twoWayKey;
        }
        if (typeof onDelete !== 'undefined') {
            payload['onDelete'] = onDelete;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createStringColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                size: rest[2],
                required: rest[3],
                xdefault: rest[4],
                array: rest[5],
                encrypt: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const size = params.size;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof size === 'undefined') {
            throw new AppwriteException('Missing required parameter: "size"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/string'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateStringColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                size: rest[4],
                newKey: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const size = params.size;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/string/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createTextColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4],
                encrypt: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/text'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateTextColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/text/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createUrlColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                array: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/url'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateUrlColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                newKey: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/url/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createVarcharColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                size: rest[2],
                required: rest[3],
                xdefault: rest[4],
                array: rest[5],
                encrypt: rest[6]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const size = params.size;
        const required = params.required;
        const xdefault = params.xdefault;
        const array = params.array;
        const encrypt = params.encrypt;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof size === 'undefined') {
            throw new AppwriteException('Missing required parameter: "size"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/varchar'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof array !== 'undefined') {
            payload['array'] = array;
        }
        if (typeof encrypt !== 'undefined') {
            payload['encrypt'] = encrypt;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateVarcharColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                required: rest[2],
                xdefault: rest[3],
                size: rest[4],
                newKey: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const required = params.required;
        const xdefault = params.xdefault;
        const size = params.size;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof required === 'undefined') {
            throw new AppwriteException('Missing required parameter: "required"');
        }
        if (typeof xdefault === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xdefault"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/varchar/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof required !== 'undefined') {
            payload['required'] = required;
        }
        if (typeof xdefault !== 'undefined') {
            payload['default'] = xdefault;
        }
        if (typeof size !== 'undefined') {
            payload['size'] = size;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateRelationshipColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                onDelete: rest[2],
                newKey: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const onDelete = params.onDelete;
        const newKey = params.newKey;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/columns/{key}/relationship'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        if (typeof onDelete !== 'undefined') {
            payload['onDelete'] = onDelete;
        }
        if (typeof newKey !== 'undefined') {
            payload['newKey'] = newKey;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listIndexes(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                queries: rest[1],
                total: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const queries = params.queries;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/indexes'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createIndex(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1],
                type: rest[2],
                columns: rest[3],
                orders: rest[4],
                lengths: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        const type = params.type;
        const columns = params.columns;
        const orders = params.orders;
        const lengths = params.lengths;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        if (typeof columns === 'undefined') {
            throw new AppwriteException('Missing required parameter: "columns"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/indexes'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof key !== 'undefined') {
            payload['key'] = key;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof columns !== 'undefined') {
            payload['columns'] = columns;
        }
        if (typeof orders !== 'undefined') {
            payload['orders'] = orders;
        }
        if (typeof lengths !== 'undefined') {
            payload['lengths'] = lengths;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getIndex(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteIndex(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                key: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const key = params.key;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof key === 'undefined') {
            throw new AppwriteException('Missing required parameter: "key"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/indexes/{key}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{key}', key);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listTableLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                queries: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const queries = params.queries;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/logs'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listRows(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                queries: rest[1],
                transactionId: rest[2],
                total: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        const total = params.total;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        if (typeof data === 'undefined') {
            throw new AppwriteException('Missing required parameter: "data"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof rowId !== 'undefined') {
            payload['rowId'] = rowId;
        }
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createRows(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rows: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rows = params.rows;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rows === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rows"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof rows !== 'undefined') {
            payload['rows'] = rows;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    upsertRows(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rows: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rows = params.rows;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rows === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rows"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof rows !== 'undefined') {
            payload['rows'] = rows;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateRows(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                data: rest[1],
                queries: rest[2],
                transactionId: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const data = params.data;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteRows(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                queries: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    getRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                queries: rest[2],
                transactionId: rest[3]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const queries = params.queries;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    upsertRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                data: rest[2],
                permissions: rest[3],
                transactionId: rest[4]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const data = params.data;
        const permissions = params.permissions;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof data !== 'undefined') {
            payload['data'] = data;
        }
        if (typeof permissions !== 'undefined') {
            payload['permissions'] = permissions;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteRow(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                transactionId: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listRowLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                queries: rest[2]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const queries = params.queries;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/logs'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    decrementRowColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                column: rest[2],
                value: rest[3],
                min: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const column = params.column;
        const value = params.value;
        const min = params.min;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        if (typeof column === 'undefined') {
            throw new AppwriteException('Missing required parameter: "column"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof min !== 'undefined') {
            payload['min'] = min;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    incrementRowColumn(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                rowId: rest[1],
                column: rest[2],
                value: rest[3],
                max: rest[4],
                transactionId: rest[5]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const rowId = params.rowId;
        const column = params.column;
        const value = params.value;
        const max = params.max;
        const transactionId = params.transactionId;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        if (typeof rowId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "rowId"');
        }
        if (typeof column === 'undefined') {
            throw new AppwriteException('Missing required parameter: "column"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);
        const payload = {};
        if (typeof value !== 'undefined') {
            payload['value'] = value;
        }
        if (typeof max !== 'undefined') {
            payload['max'] = max;
        }
        if (typeof transactionId !== 'undefined') {
            payload['transactionId'] = transactionId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getTableUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                tableId: rest[0],
                range: rest[1]
            };
        }
        const databaseId = params.databaseId;
        const tableId = params.tableId;
        const range = params.range;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        if (typeof tableId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tableId"');
        }
        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/usage'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getUsage(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                databaseId: paramsOrFirst,
                range: rest[0]
            };
        }
        const databaseId = params.databaseId;
        const range = params.range;
        if (typeof databaseId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "databaseId"');
        }
        const apiPath = '/tablesdb/{databaseId}/usage'.replace('{databaseId}', databaseId);
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
}

class Teams {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/teams';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                name: rest[0],
                roles: rest[1]
            };
        }
        const teamId = params.teamId;
        const name = params.name;
        const roles = params.roles;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/teams';
        const payload = {};
        if (typeof teamId !== 'undefined') {
            payload['teamId'] = teamId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof roles !== 'undefined') {
            payload['roles'] = roles;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst
            };
        }
        const teamId = params.teamId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateName(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                name: rest[0]
            };
        }
        const teamId = params.teamId;
        const name = params.name;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst
            };
        }
        const teamId = params.teamId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const teamId = params.teamId;
        const queries = params.queries;
        const total = params.total;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}/logs'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listMemberships(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const teamId = params.teamId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                roles: rest[0],
                email: rest[1],
                userId: rest[2],
                phone: rest[3],
                url: rest[4],
                name: rest[5]
            };
        }
        const teamId = params.teamId;
        const roles = params.roles;
        const email = params.email;
        const userId = params.userId;
        const phone = params.phone;
        const url = params.url;
        const name = params.name;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof roles === 'undefined') {
            throw new AppwriteException('Missing required parameter: "roles"');
        }
        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        if (typeof roles !== 'undefined') {
            payload['roles'] = roles;
        }
        if (typeof url !== 'undefined') {
            payload['url'] = url;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0],
                roles: rest[1]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        const roles = params.roles;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        if (typeof roles === 'undefined') {
            throw new AppwriteException('Missing required parameter: "roles"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        if (typeof roles !== 'undefined') {
            payload['roles'] = roles;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteMembership(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateMembershipStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                membershipId: rest[0],
                userId: rest[1],
                secret: rest[2]
            };
        }
        const teamId = params.teamId;
        const membershipId = params.membershipId;
        const userId = params.userId;
        const secret = params.secret;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof membershipId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "membershipId"');
        }
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof secret === 'undefined') {
            throw new AppwriteException('Missing required parameter: "secret"');
        }
        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof secret !== 'undefined') {
            payload['secret'] = secret;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getPrefs(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst
            };
        }
        const teamId = params.teamId;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePrefs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                teamId: paramsOrFirst,
                prefs: rest[0]
            };
        }
        const teamId = params.teamId;
        const prefs = params.prefs;
        if (typeof teamId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "teamId"');
        }
        if (typeof prefs === 'undefined') {
            throw new AppwriteException('Missing required parameter: "prefs"');
        }
        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);
        const payload = {};
        if (typeof prefs !== 'undefined') {
            payload['prefs'] = prefs;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
}

class Tokens {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                queries: rest[1],
                total: rest[2]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const queries = params.queries;
        const total = params.total;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/tokens/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createFileToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                bucketId: paramsOrFirst,
                fileId: rest[0],
                expire: rest[1]
            };
        }
        const bucketId = params.bucketId;
        const fileId = params.fileId;
        const expire = params.expire;
        if (typeof bucketId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "bucketId"');
        }
        if (typeof fileId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "fileId"');
        }
        const apiPath = '/tokens/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);
        const payload = {};
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                tokenId: paramsOrFirst
            };
        }
        const tokenId = params.tokenId;
        if (typeof tokenId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tokenId"');
        }
        const apiPath = '/tokens/{tokenId}'.replace('{tokenId}', tokenId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    update(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                tokenId: paramsOrFirst,
                expire: rest[0]
            };
        }
        const tokenId = params.tokenId;
        const expire = params.expire;
        if (typeof tokenId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tokenId"');
        }
        const apiPath = '/tokens/{tokenId}'.replace('{tokenId}', tokenId);
        const payload = {};
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                tokenId: paramsOrFirst
            };
        }
        const tokenId = params.tokenId;
        if (typeof tokenId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "tokenId"');
        }
        const apiPath = '/tokens/{tokenId}'.replace('{tokenId}', tokenId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

class Users {
    constructor(client) {
        this.client = client;
    }
    list(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/users';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    create(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                phone: rest[1],
                password: rest[2],
                name: rest[3]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const phone = params.phone;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof phone !== 'undefined') {
            payload['phone'] = phone;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createArgon2User(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                name: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/users/argon2';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createBcryptUser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                name: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/users/bcrypt';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listIdentities(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/users/identities';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteIdentity(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                identityId: paramsOrFirst
            };
        }
        const identityId = params.identityId;
        if (typeof identityId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identityId"');
        }
        const apiPath = '/users/identities/{identityId}'.replace('{identityId}', identityId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createMD5User(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                name: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/users/md5';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createPHPassUser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                name: rest[2]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/users/phpass';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createScryptUser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                passwordSalt: rest[2],
                passwordCpu: rest[3],
                passwordMemory: rest[4],
                passwordParallel: rest[5],
                passwordLength: rest[6],
                name: rest[7]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const passwordSalt = params.passwordSalt;
        const passwordCpu = params.passwordCpu;
        const passwordMemory = params.passwordMemory;
        const passwordParallel = params.passwordParallel;
        const passwordLength = params.passwordLength;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        if (typeof passwordSalt === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordSalt"');
        }
        if (typeof passwordCpu === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordCpu"');
        }
        if (typeof passwordMemory === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordMemory"');
        }
        if (typeof passwordParallel === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordParallel"');
        }
        if (typeof passwordLength === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordLength"');
        }
        const apiPath = '/users/scrypt';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof passwordSalt !== 'undefined') {
            payload['passwordSalt'] = passwordSalt;
        }
        if (typeof passwordCpu !== 'undefined') {
            payload['passwordCpu'] = passwordCpu;
        }
        if (typeof passwordMemory !== 'undefined') {
            payload['passwordMemory'] = passwordMemory;
        }
        if (typeof passwordParallel !== 'undefined') {
            payload['passwordParallel'] = passwordParallel;
        }
        if (typeof passwordLength !== 'undefined') {
            payload['passwordLength'] = passwordLength;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createScryptModifiedUser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                passwordSalt: rest[2],
                passwordSaltSeparator: rest[3],
                passwordSignerKey: rest[4],
                name: rest[5]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const passwordSalt = params.passwordSalt;
        const passwordSaltSeparator = params.passwordSaltSeparator;
        const passwordSignerKey = params.passwordSignerKey;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        if (typeof passwordSalt === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordSalt"');
        }
        if (typeof passwordSaltSeparator === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordSaltSeparator"');
        }
        if (typeof passwordSignerKey === 'undefined') {
            throw new AppwriteException('Missing required parameter: "passwordSignerKey"');
        }
        const apiPath = '/users/scrypt-modified';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof passwordSalt !== 'undefined') {
            payload['passwordSalt'] = passwordSalt;
        }
        if (typeof passwordSaltSeparator !== 'undefined') {
            payload['passwordSaltSeparator'] = passwordSaltSeparator;
        }
        if (typeof passwordSignerKey !== 'undefined') {
            payload['passwordSignerKey'] = passwordSignerKey;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    createSHAUser(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0],
                password: rest[1],
                passwordVersion: rest[2],
                name: rest[3]
            };
        }
        const userId = params.userId;
        const email = params.email;
        const password = params.password;
        const passwordVersion = params.passwordVersion;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/users/sha';
        const payload = {};
        if (typeof userId !== 'undefined') {
            payload['userId'] = userId;
        }
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        if (typeof passwordVersion !== 'undefined') {
            payload['passwordVersion'] = passwordVersion;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getUsage(paramsOrFirst) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && ('range' in paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                range: paramsOrFirst
            };
        }
        const range = params.range;
        const apiPath = '/users/usage';
        const payload = {};
        if (typeof range !== 'undefined') {
            payload['range'] = range;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    get(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    delete(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateEmail(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                email: rest[0]
            };
        }
        const userId = params.userId;
        const email = params.email;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof email === 'undefined') {
            throw new AppwriteException('Missing required parameter: "email"');
        }
        const apiPath = '/users/{userId}/email'.replace('{userId}', userId);
        const payload = {};
        if (typeof email !== 'undefined') {
            payload['email'] = email;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createJWT(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                sessionId: rest[0],
                duration: rest[1]
            };
        }
        const userId = params.userId;
        const sessionId = params.sessionId;
        const duration = params.duration;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/jwts'.replace('{userId}', userId);
        const payload = {};
        if (typeof sessionId !== 'undefined') {
            payload['sessionId'] = sessionId;
        }
        if (typeof duration !== 'undefined') {
            payload['duration'] = duration;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateLabels(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                labels: rest[0]
            };
        }
        const userId = params.userId;
        const labels = params.labels;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof labels === 'undefined') {
            throw new AppwriteException('Missing required parameter: "labels"');
        }
        const apiPath = '/users/{userId}/labels'.replace('{userId}', userId);
        const payload = {};
        if (typeof labels !== 'undefined') {
            payload['labels'] = labels;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    listLogs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const userId = params.userId;
        const queries = params.queries;
        const total = params.total;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/logs'.replace('{userId}', userId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listMemberships(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                queries: rest[0],
                search: rest[1],
                total: rest[2]
            };
        }
        const userId = params.userId;
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/memberships'.replace('{userId}', userId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateMfa(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                mfa: rest[0]
            };
        }
        const userId = params.userId;
        const mfa = params.mfa;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof mfa === 'undefined') {
            throw new AppwriteException('Missing required parameter: "mfa"');
        }
        const apiPath = '/users/{userId}/mfa'.replace('{userId}', userId);
        const payload = {};
        if (typeof mfa !== 'undefined') {
            payload['mfa'] = mfa;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateMFA(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                mfa: rest[0]
            };
        }
        const userId = params.userId;
        const mfa = params.mfa;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof mfa === 'undefined') {
            throw new AppwriteException('Missing required parameter: "mfa"');
        }
        const apiPath = '/users/{userId}/mfa'.replace('{userId}', userId);
        const payload = {};
        if (typeof mfa !== 'undefined') {
            payload['mfa'] = mfa;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteMfaAuthenticator(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                type: rest[0]
            };
        }
        const userId = params.userId;
        const type = params.type;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/users/{userId}/mfa/authenticators/{type}'.replace('{userId}', userId).replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    deleteMFAAuthenticator(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                type: rest[0]
            };
        }
        const userId = params.userId;
        const type = params.type;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/users/{userId}/mfa/authenticators/{type}'.replace('{userId}', userId).replace('{type}', type);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    listMfaFactors(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/factors'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listMFAFactors(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/factors'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getMfaRecoveryCodes(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getMFARecoveryCodes(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateMfaRecoveryCodes(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    updateMFARecoveryCodes(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('put', uri, apiHeaders, payload);
    }
    createMfaRecoveryCodes(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    createMFARecoveryCodes(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/mfa/recovery-codes'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updateName(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                name: rest[0]
            };
        }
        const userId = params.userId;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        const apiPath = '/users/{userId}/name'.replace('{userId}', userId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePassword(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                password: rest[0]
            };
        }
        const userId = params.userId;
        const password = params.password;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof password === 'undefined') {
            throw new AppwriteException('Missing required parameter: "password"');
        }
        const apiPath = '/users/{userId}/password'.replace('{userId}', userId);
        const payload = {};
        if (typeof password !== 'undefined') {
            payload['password'] = password;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePhone(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                number: rest[0]
            };
        }
        const userId = params.userId;
        const number = params.number;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof number === 'undefined') {
            throw new AppwriteException('Missing required parameter: "number"');
        }
        const apiPath = '/users/{userId}/phone'.replace('{userId}', userId);
        const payload = {};
        if (typeof number !== 'undefined') {
            payload['number'] = number;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    getPrefs(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/prefs'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updatePrefs(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                prefs: rest[0]
            };
        }
        const userId = params.userId;
        const prefs = params.prefs;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof prefs === 'undefined') {
            throw new AppwriteException('Missing required parameter: "prefs"');
        }
        const apiPath = '/users/{userId}/prefs'.replace('{userId}', userId);
        const payload = {};
        if (typeof prefs !== 'undefined') {
            payload['prefs'] = prefs;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listSessions(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                total: rest[0]
            };
        }
        const userId = params.userId;
        const total = params.total;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);
        const payload = {};
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createSession(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    deleteSessions(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst
            };
        }
        const userId = params.userId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/sessions'.replace('{userId}', userId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    deleteSession(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                sessionId: rest[0]
            };
        }
        const userId = params.userId;
        const sessionId = params.sessionId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof sessionId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "sessionId"');
        }
        const apiPath = '/users/{userId}/sessions/{sessionId}'.replace('{userId}', userId).replace('{sessionId}', sessionId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    updateStatus(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                status: rest[0]
            };
        }
        const userId = params.userId;
        const status = params.status;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof status === 'undefined') {
            throw new AppwriteException('Missing required parameter: "status"');
        }
        const apiPath = '/users/{userId}/status'.replace('{userId}', userId);
        const payload = {};
        if (typeof status !== 'undefined') {
            payload['status'] = status;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listTargets(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                queries: rest[0],
                total: rest[1]
            };
        }
        const userId = params.userId;
        const queries = params.queries;
        const total = params.total;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/targets'.replace('{userId}', userId);
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                targetId: rest[0],
                providerType: rest[1],
                identifier: rest[2],
                providerId: rest[3],
                name: rest[4]
            };
        }
        const userId = params.userId;
        const targetId = params.targetId;
        const providerType = params.providerType;
        const identifier = params.identifier;
        const providerId = params.providerId;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        if (typeof providerType === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerType"');
        }
        if (typeof identifier === 'undefined') {
            throw new AppwriteException('Missing required parameter: "identifier"');
        }
        const apiPath = '/users/{userId}/targets'.replace('{userId}', userId);
        const payload = {};
        if (typeof targetId !== 'undefined') {
            payload['targetId'] = targetId;
        }
        if (typeof providerType !== 'undefined') {
            payload['providerType'] = providerType;
        }
        if (typeof identifier !== 'undefined') {
            payload['identifier'] = identifier;
        }
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                targetId: rest[0]
            };
        }
        const userId = params.userId;
        const targetId = params.targetId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                targetId: rest[0],
                identifier: rest[1],
                providerId: rest[2],
                name: rest[3]
            };
        }
        const userId = params.userId;
        const targetId = params.targetId;
        const identifier = params.identifier;
        const providerId = params.providerId;
        const name = params.name;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);
        const payload = {};
        if (typeof identifier !== 'undefined') {
            payload['identifier'] = identifier;
        }
        if (typeof providerId !== 'undefined') {
            payload['providerId'] = providerId;
        }
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    deleteTarget(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                targetId: rest[0]
            };
        }
        const userId = params.userId;
        const targetId = params.targetId;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof targetId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "targetId"');
        }
        const apiPath = '/users/{userId}/targets/{targetId}'.replace('{userId}', userId).replace('{targetId}', targetId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
    createToken(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                length: rest[0],
                expire: rest[1]
            };
        }
        const userId = params.userId;
        const length = params.length;
        const expire = params.expire;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        const apiPath = '/users/{userId}/tokens'.replace('{userId}', userId);
        const payload = {};
        if (typeof length !== 'undefined') {
            payload['length'] = length;
        }
        if (typeof expire !== 'undefined') {
            payload['expire'] = expire;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    updateEmailVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                emailVerification: rest[0]
            };
        }
        const userId = params.userId;
        const emailVerification = params.emailVerification;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof emailVerification === 'undefined') {
            throw new AppwriteException('Missing required parameter: "emailVerification"');
        }
        const apiPath = '/users/{userId}/verification'.replace('{userId}', userId);
        const payload = {};
        if (typeof emailVerification !== 'undefined') {
            payload['emailVerification'] = emailVerification;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    updatePhoneVerification(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                userId: paramsOrFirst,
                phoneVerification: rest[0]
            };
        }
        const userId = params.userId;
        const phoneVerification = params.phoneVerification;
        if (typeof userId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "userId"');
        }
        if (typeof phoneVerification === 'undefined') {
            throw new AppwriteException('Missing required parameter: "phoneVerification"');
        }
        const apiPath = '/users/{userId}/verification/phone'.replace('{userId}', userId);
        const payload = {};
        if (typeof phoneVerification !== 'undefined') {
            payload['phoneVerification'] = phoneVerification;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
}

class Vcs {
    constructor(client) {
        this.client = client;
    }
    createRepositoryDetection(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                providerRepositoryId: rest[0],
                type: rest[1],
                providerRootDirectory: rest[2]
            };
        }
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        const type = params.type;
        const providerRootDirectory = params.providerRootDirectory;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof providerRepositoryId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerRepositoryId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/detections'.replace('{installationId}', installationId);
        const payload = {};
        if (typeof providerRepositoryId !== 'undefined') {
            payload['providerRepositoryId'] = providerRepositoryId;
        }
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof providerRootDirectory !== 'undefined') {
            payload['providerRootDirectory'] = providerRootDirectory;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    listRepositories(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                type: rest[0],
                search: rest[1],
                queries: rest[2]
            };
        }
        const installationId = params.installationId;
        const type = params.type;
        const search = params.search;
        const queries = params.queries;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof type === 'undefined') {
            throw new AppwriteException('Missing required parameter: "type"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/providerRepositories'.replace('{installationId}', installationId);
        const payload = {};
        if (typeof type !== 'undefined') {
            payload['type'] = type;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    createRepository(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                name: rest[0],
                xprivate: rest[1]
            };
        }
        const installationId = params.installationId;
        const name = params.name;
        const xprivate = params.xprivate;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof name === 'undefined') {
            throw new AppwriteException('Missing required parameter: "name"');
        }
        if (typeof xprivate === 'undefined') {
            throw new AppwriteException('Missing required parameter: "xprivate"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/providerRepositories'.replace('{installationId}', installationId);
        const payload = {};
        if (typeof name !== 'undefined') {
            payload['name'] = name;
        }
        if (typeof xprivate !== 'undefined') {
            payload['private'] = xprivate;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('post', uri, apiHeaders, payload);
    }
    getRepository(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                providerRepositoryId: rest[0]
            };
        }
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof providerRepositoryId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerRepositoryId"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/providerRepositories/{providerRepositoryId}'.replace('{installationId}', installationId).replace('{providerRepositoryId}', providerRepositoryId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    listRepositoryBranches(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                providerRepositoryId: rest[0]
            };
        }
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof providerRepositoryId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerRepositoryId"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/providerRepositories/{providerRepositoryId}/branches'.replace('{installationId}', installationId).replace('{providerRepositoryId}', providerRepositoryId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getRepositoryContents(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                providerRepositoryId: rest[0],
                providerRootDirectory: rest[1],
                providerReference: rest[2]
            };
        }
        const installationId = params.installationId;
        const providerRepositoryId = params.providerRepositoryId;
        const providerRootDirectory = params.providerRootDirectory;
        const providerReference = params.providerReference;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof providerRepositoryId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerRepositoryId"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/providerRepositories/{providerRepositoryId}/contents'.replace('{installationId}', installationId).replace('{providerRepositoryId}', providerRepositoryId);
        const payload = {};
        if (typeof providerRootDirectory !== 'undefined') {
            payload['providerRootDirectory'] = providerRootDirectory;
        }
        if (typeof providerReference !== 'undefined') {
            payload['providerReference'] = providerReference;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    updateExternalDeployments(paramsOrFirst, ...rest) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst,
                repositoryId: rest[0],
                providerPullRequestId: rest[1]
            };
        }
        const installationId = params.installationId;
        const repositoryId = params.repositoryId;
        const providerPullRequestId = params.providerPullRequestId;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        if (typeof repositoryId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "repositoryId"');
        }
        if (typeof providerPullRequestId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "providerPullRequestId"');
        }
        const apiPath = '/vcs/github/installations/{installationId}/repositories/{repositoryId}'.replace('{installationId}', installationId).replace('{repositoryId}', repositoryId);
        const payload = {};
        if (typeof providerPullRequestId !== 'undefined') {
            payload['providerPullRequestId'] = providerPullRequestId;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('patch', uri, apiHeaders, payload);
    }
    listInstallations(paramsOrFirst, ...rest) {
        let params;
        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                queries: paramsOrFirst,
                search: rest[0],
                total: rest[1]
            };
        }
        const queries = params.queries;
        const search = params.search;
        const total = params.total;
        const apiPath = '/vcs/installations';
        const payload = {};
        if (typeof queries !== 'undefined') {
            payload['queries'] = queries;
        }
        if (typeof search !== 'undefined') {
            payload['search'] = search;
        }
        if (typeof total !== 'undefined') {
            payload['total'] = total;
        }
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    getInstallation(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst
            };
        }
        const installationId = params.installationId;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        const apiPath = '/vcs/installations/{installationId}'.replace('{installationId}', installationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {};
        return this.client.call('get', uri, apiHeaders, payload);
    }
    deleteInstallation(paramsOrFirst) {
        let params;
        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {
            params = (paramsOrFirst || {});
        }
        else {
            params = {
                installationId: paramsOrFirst
            };
        }
        const installationId = params.installationId;
        if (typeof installationId === 'undefined') {
            throw new AppwriteException('Missing required parameter: "installationId"');
        }
        const apiPath = '/vcs/installations/{installationId}'.replace('{installationId}', installationId);
        const payload = {};
        const uri = new URL(this.client.config.endpoint + apiPath);
        const apiHeaders = {
            'content-type': 'application/json',
        };
        return this.client.call('delete', uri, apiHeaders, payload);
    }
}

var RealtimeCode;
(function (RealtimeCode) {
    RealtimeCode[RealtimeCode["NORMAL_CLOSURE"] = 1000] = "NORMAL_CLOSURE";
    RealtimeCode[RealtimeCode["POLICY_VIOLATION"] = 1008] = "POLICY_VIOLATION";
    RealtimeCode[RealtimeCode["UNKNOWN_ERROR"] = -1] = "UNKNOWN_ERROR";
})(RealtimeCode || (RealtimeCode = {}));
class Realtime {
    constructor(client) {
        this.TYPE_ERROR = 'error';
        this.TYPE_EVENT = 'event';
        this.TYPE_PONG = 'pong';
        this.TYPE_CONNECTED = 'connected';
        this.DEBOUNCE_MS = 1;
        this.HEARTBEAT_INTERVAL = 20000; // 20 seconds in milliseconds
        // Slot-centric state: Map<slot, { channels: Set<string>, queries: string[], callback: Function }>
        this.activeSubscriptions = new Map();
        // Map slot index -> subscriptionId (from backend)
        this.slotToSubscriptionId = new Map();
        // Inverse map: subscriptionId -> slot index (for O(1) lookup)
        this.subscriptionIdToSlot = new Map();
        this.subCallDepth = 0;
        this.reconnectAttempts = 0;
        this.subscriptionsCounter = 0;
        this.connectionId = 0;
        this.reconnect = true;
        this.onErrorCallbacks = [];
        this.onCloseCallbacks = [];
        this.onOpenCallbacks = [];
        this.client = client;
    }
    /**
     * Register a callback function to be called when an error occurs
     *
     * @param {Function} callback - Callback function to handle errors
     * @returns {void}
     */
    onError(callback) {
        this.onErrorCallbacks.push(callback);
    }
    /**
     * Register a callback function to be called when the connection closes
     *
     * @param {Function} callback - Callback function to handle connection close
     * @returns {void}
     */
    onClose(callback) {
        this.onCloseCallbacks.push(callback);
    }
    /**
     * Register a callback function to be called when the connection opens
     *
     * @param {Function} callback - Callback function to handle connection open
     * @returns {void}
     */
    onOpen(callback) {
        this.onOpenCallbacks.push(callback);
    }
    startHeartbeat() {
        this.stopHeartbeat();
        this.heartbeatTimer = window.setInterval(() => {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify({ type: 'ping' }));
            }
        }, this.HEARTBEAT_INTERVAL);
    }
    stopHeartbeat() {
        if (this.heartbeatTimer) {
            window.clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = undefined;
        }
    }
    createSocket() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeSubscriptions.size === 0) {
                this.reconnect = false;
                yield this.closeSocket();
                return;
            }
            const projectId = this.client.config.project;
            if (!projectId) {
                throw new AppwriteException('Missing project ID');
            }
            // Collect all unique channels from all slots
            const allChannels = new Set();
            for (const subscription of this.activeSubscriptions.values()) {
                for (const channel of subscription.channels) {
                    allChannels.add(channel);
                }
            }
            let queryParams = `project=${projectId}`;
            for (const channel of allChannels) {
                queryParams += `&channels[]=${encodeURIComponent(channel)}`;
            }
            // Build query string from slots  channels  queries
            // Format: channel[slot][]=query
            // For each slot, repeat its queries under each channel it subscribes to
            // Example: slot 1  channels [tests, prod], queries [q1, q2]
            //   Produces: tests[1][]=q1&tests[1][]=q2&prod[1][]=q1&prod[1][]=q2
            const selectAllQuery = Query.select(['*']).toString();
            for (const [slot, subscription] of this.activeSubscriptions) {
                // queries is string[] - iterate over each query string
                const queries = subscription.queries.length === 0
                    ? [selectAllQuery]
                    : subscription.queries;
                // Repeat this slot's queries under each channel it subscribes to
                // Each query is sent as a separate parameter: channel[slot][]=q1&channel[slot][]=q2
                for (const channel of subscription.channels) {
                    for (const query of queries) {
                        queryParams += `&${encodeURIComponent(channel)}[${slot}][]=${encodeURIComponent(query)}`;
                    }
                }
            }
            const endpoint = this.client.config.endpointRealtime !== ''
                ? this.client.config.endpointRealtime
                : this.client.config.endpoint || '';
            const realtimeEndpoint = endpoint
                .replace('https://', 'wss://')
                .replace('http://', 'ws://');
            const url = `${realtimeEndpoint}/realtime?${queryParams}`;
            if (this.socket) {
                this.reconnect = false;
                if (this.socket.readyState < WebSocket.CLOSING) {
                    yield this.closeSocket();
                }
                // Ensure reconnect isn't stuck false if close event was missed.
                this.reconnect = true;
            }
            return new Promise((resolve, reject) => {
                try {
                    const connectionId = ++this.connectionId;
                    const socket = (this.socket = new WebSocket(url));
                    socket.addEventListener('open', () => {
                        if (connectionId !== this.connectionId) {
                            return;
                        }
                        this.reconnectAttempts = 0;
                        this.onOpenCallbacks.forEach(callback => callback());
                        this.startHeartbeat();
                        resolve();
                    });
                    socket.addEventListener('message', (event) => {
                        if (connectionId !== this.connectionId) {
                            return;
                        }
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        }
                        catch (error) {
                            console.error('Failed to parse message:', error);
                        }
                    });
                    socket.addEventListener('close', (event) => __awaiter(this, void 0, void 0, function* () {
                        if (connectionId !== this.connectionId || socket !== this.socket) {
                            return;
                        }
                        this.stopHeartbeat();
                        this.onCloseCallbacks.forEach(callback => callback());
                        if (!this.reconnect || event.code === RealtimeCode.POLICY_VIOLATION) {
                            this.reconnect = true;
                            return;
                        }
                        const timeout = this.getTimeout();
                        console.log(`Realtime disconnected. Re-connecting in ${timeout / 1000} seconds.`);
                        yield this.sleep(timeout);
                        this.reconnectAttempts++;
                        try {
                            yield this.createSocket();
                        }
                        catch (error) {
                            console.error('Failed to reconnect:', error);
                        }
                    }));
                    socket.addEventListener('error', (event) => {
                        if (connectionId !== this.connectionId || socket !== this.socket) {
                            return;
                        }
                        this.stopHeartbeat();
                        const error = new Error('WebSocket error');
                        console.error('WebSocket error:', error.message);
                        this.onErrorCallbacks.forEach(callback => callback(error));
                        reject(error);
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    closeSocket() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopHeartbeat();
            if (this.socket) {
                return new Promise((resolve) => {
                    if (!this.socket) {
                        resolve();
                        return;
                    }
                    if (this.socket.readyState === WebSocket.OPEN ||
                        this.socket.readyState === WebSocket.CONNECTING) {
                        this.socket.addEventListener('close', () => {
                            resolve();
                        }, { once: true });
                        this.socket.close(RealtimeCode.NORMAL_CLOSURE);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    }
    getTimeout() {
        if (this.reconnectAttempts < 5) {
            return 1000;
        }
        else if (this.reconnectAttempts < 15) {
            return 5000;
        }
        else if (this.reconnectAttempts < 100) {
            return 10000;
        }
        else {
            return 60000;
        }
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    /**
     * Convert a channel value to a string
     *
     * @private
     * @param {string | Channel<any> | ActionableChannel | ResolvedChannel} channel - Channel value (string or Channel builder instance)
     * @returns {string} Channel string representation
     */
    channelToString(channel) {
        if (typeof channel === 'string') {
            return channel;
        }
        // All Channel instances have toString() method
        if (channel && typeof channel.toString === 'function') {
            return channel.toString();
        }
        return String(channel);
    }
    subscribe(channelsOrChannel, callback, queries = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelArray = Array.isArray(channelsOrChannel)
                ? channelsOrChannel
                : [channelsOrChannel];
            // Convert all channels to strings
            const channelStrings = channelArray.map(ch => this.channelToString(ch));
            const channels = new Set(channelStrings);
            // Convert queries to array of strings
            // Ensure each query is a separate string in the array
            const queryStrings = [];
            for (const q of (queries !== null && queries !== void 0 ? queries : [])) {
                if (Array.isArray(q)) {
                    // Handle nested arrays: [[q1, q2]] -> [q1, q2]
                    for (const inner of q) {
                        queryStrings.push(typeof inner === 'string' ? inner : inner.toString());
                    }
                }
                else {
                    queryStrings.push(typeof q === 'string' ? q : q.toString());
                }
            }
            // Allocate a new slot index
            this.subscriptionsCounter++;
            const slot = this.subscriptionsCounter;
            // Store slot-centric data: channels, queries, and callback belong to the slot
            // queries is stored as string[] (array of query strings)
            // No channel mutation occurs here - channels are derived from slots in createSocket()
            this.activeSubscriptions.set(slot, {
                channels,
                queries: queryStrings,
                callback
            });
            this.subCallDepth++;
            yield this.sleep(this.DEBOUNCE_MS);
            if (this.subCallDepth === 1) {
                yield this.createSocket();
            }
            this.subCallDepth--;
            return {
                close: () => __awaiter(this, void 0, void 0, function* () {
                    const subscriptionId = this.slotToSubscriptionId.get(slot);
                    this.activeSubscriptions.delete(slot);
                    this.slotToSubscriptionId.delete(slot);
                    if (subscriptionId) {
                        this.subscriptionIdToSlot.delete(subscriptionId);
                    }
                    yield this.createSocket();
                })
            };
        });
    }
    // cleanUp is no longer needed - slots are removed directly in subscribe().close()
    // Channels are automatically rebuilt from remaining slots in createSocket()
    handleMessage(message) {
        if (!message.type) {
            return;
        }
        switch (message.type) {
            case this.TYPE_CONNECTED:
                this.handleResponseConnected(message);
                break;
            case this.TYPE_ERROR:
                this.handleResponseError(message);
                break;
            case this.TYPE_EVENT:
                this.handleResponseEvent(message);
                break;
            case this.TYPE_PONG:
                // Handle pong response if needed
                break;
        }
    }
    handleResponseConnected(message) {
        var _a, _b;
        if (!message.data) {
            return;
        }
        const messageData = message.data;
        // Store subscription ID mappings from backend
        // Format: { "0": "sub_a1f9", "1": "sub_b83c", ... }
        if (messageData.subscriptions) {
            this.slotToSubscriptionId.clear();
            this.subscriptionIdToSlot.clear();
            for (const [slotStr, subscriptionId] of Object.entries(messageData.subscriptions)) {
                const slot = Number(slotStr);
                if (!isNaN(slot)) {
                    this.slotToSubscriptionId.set(slot, subscriptionId);
                    this.subscriptionIdToSlot.set(subscriptionId, slot);
                }
            }
        }
        let session = this.client.config.session;
        if (!session) {
            try {
                const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');
                session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.client.config.project}`];
            }
            catch (error) {
                console.error('Failed to parse cookie fallback:', error);
            }
        }
        if (session && !messageData.user) {
            (_b = this.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({
                type: 'authentication',
                data: {
                    session
                }
            }));
        }
    }
    handleResponseError(message) {
        var _a, _b;
        const error = new AppwriteException(((_a = message.data) === null || _a === void 0 ? void 0 : _a.message) || 'Unknown error');
        const statusCode = (_b = message.data) === null || _b === void 0 ? void 0 : _b.code;
        this.onErrorCallbacks.forEach(callback => callback(error, statusCode));
    }
    handleResponseEvent(message) {
        const data = message.data;
        if (!data) {
            return;
        }
        const channels = data.channels;
        const events = data.events;
        const payload = data.payload;
        const timestamp = data.timestamp;
        const subscriptions = data.subscriptions;
        if (!channels || !events || !payload || !subscriptions || subscriptions.length === 0) {
            return;
        }
        // Iterate over all matching subscriptionIds and call callback for each
        for (const subscriptionId of subscriptions) {
            // O(1) lookup using subscriptionId
            const slot = this.subscriptionIdToSlot.get(subscriptionId);
            if (slot !== undefined) {
                const subscription = this.activeSubscriptions.get(slot);
                if (subscription) {
                    const response = {
                        events,
                        channels,
                        timestamp,
                        payload,
                        subscriptions
                    };
                    subscription.callback(response);
                }
            }
        }
    }
}

/**
 * Helper class to generate permission strings for resources.
 */
class Permission {
}
/**
 * Generate read permission string for the provided role.
 *
 * @param {string} role
 * @returns {string}
 */
Permission.read = (role) => {
    return `read("${role}")`;
};
/**
 * Generate write permission string for the provided role.
 *
 * This is an alias of update, delete, and possibly create.
 * Don't use write in combination with update, delete, or create.
 *
 * @param {string} role
 * @returns {string}
 */
Permission.write = (role) => {
    return `write("${role}")`;
};
/**
 * Generate create permission string for the provided role.
 *
 * @param {string} role
 * @returns {string}
 */
Permission.create = (role) => {
    return `create("${role}")`;
};
/**
 * Generate update permission string for the provided role.
 *
 * @param {string} role
 * @returns {string}
 */
Permission.update = (role) => {
    return `update("${role}")`;
};
/**
 * Generate delete permission string for the provided role.
 *
 * @param {string} role
 * @returns {string}
 */
Permission.delete = (role) => {
    return `delete("${role}")`;
};

/**
 * Helper class to generate role strings for `Permission`.
 */
class Role {
    /**
     * Grants access to anyone.
     *
     * This includes authenticated and unauthenticated users.
     *
     * @returns {string}
     */
    static any() {
        return 'any';
    }
    /**
     * Grants access to a specific user by user ID.
     *
     * You can optionally pass verified or unverified for
     * `status` to target specific types of users.
     *
     * @param {string} id
     * @param {string} status
     * @returns {string}
     */
    static user(id, status = '') {
        if (status === '') {
            return `user:${id}`;
        }
        return `user:${id}/${status}`;
    }
    /**
     * Grants access to any authenticated or anonymous user.
     *
     * You can optionally pass verified or unverified for
     * `status` to target specific types of users.
     *
     * @param {string} status
     * @returns {string}
     */
    static users(status = '') {
        if (status === '') {
            return 'users';
        }
        return `users/${status}`;
    }
    /**
     * Grants access to any guest user without a session.
     *
     * Authenticated users don't have access to this role.
     *
     * @returns {string}
     */
    static guests() {
        return 'guests';
    }
    /**
     * Grants access to a team by team ID.
     *
     * You can optionally pass a role for `role` to target
     * team members with the specified role.
     *
     * @param {string} id
     * @param {string} role
     * @returns {string}
     */
    static team(id, role = '') {
        if (role === '') {
            return `team:${id}`;
        }
        return `team:${id}/${role}`;
    }
    /**
     * Grants access to a specific member of a team.
     *
     * When the member is removed from the team, they will
     * no longer have access.
     *
     * @param {string} id
     * @returns {string}
     */
    static member(id) {
        return `member:${id}`;
    }
    /**
     * Grants access to a user with the specified label.
     *
     * @param {string} name
     * @returns  {string}
     */
    static label(name) {
        return `label:${name}`;
    }
}

var _a, _ID_hexTimestamp;
/**
 * Helper class to generate ID strings for resources.
 */
class ID {
    /**
     * Uses the provided ID as the ID for the resource.
     *
     * @param {string} id
     * @returns {string}
     */
    static custom(id) {
        return id;
    }
    /**
     * Have Appwrite generate a unique ID for you.
     *
     * @param {number} padding. Default is 7.
     * @returns {string}
     */
    static unique(padding = 7) {
        // Generate a unique ID with padding to have a longer ID
        const baseId = __classPrivateFieldGet(ID, _a, "m", _ID_hexTimestamp).call(ID);
        let randomPadding = '';
        for (let i = 0; i < padding; i++) {
            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);
            randomPadding += randomHexDigit;
        }
        return baseId + randomPadding;
    }
}
_a = ID, _ID_hexTimestamp = function _ID_hexTimestamp() {
    const now = new Date();
    const sec = Math.floor(now.getTime() / 1000);
    const msec = now.getMilliseconds();
    // Convert to hexadecimal
    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');
    return hexTimestamp;
};

function normalize(id) {
    const trimmed = id.trim();
    return trimmed === "" ? "*" : trimmed;
}
class Channel {
    constructor(segments) {
        this.segments = segments;
    }
    next(segment, id) {
        const segments = id === undefined
            ? [...this.segments, segment]
            : [...this.segments, segment, normalize(id)];
        return new Channel(segments);
    }
    resolve(action) {
        return new Channel([...this.segments, action]);
    }
    toString() {
        return this.segments.join(".");
    }
    // --- DATABASE ROUTE ---
    // Only available on Channel<Database>
    collection(id) {
        // Default: wildcard collection ID
        return this.next("collections", id !== null && id !== void 0 ? id : "*");
    }
    // Only available on Channel<Collection>
    document(id) {
        // Default: no document ID segment
        return this.next("documents", id);
    }
    // --- TABLESDB ROUTE ---
    table(id) {
        // Default: wildcard table ID
        return this.next("tables", id !== null && id !== void 0 ? id : "*");
    }
    row(id) {
        // Default: no row ID segment
        return this.next("rows", id);
    }
    // --- BUCKET ROUTE ---
    file(id) {
        // Default: no file ID segment
        return this.next("files", id);
    }
    // --- TERMINAL ACTIONS ---
    // Restricted to the Actionable union
    create() {
        return this.resolve("create");
    }
    upsert() {
        return this.resolve("upsert");
    }
    update() {
        return this.resolve("update");
    }
    delete() {
        return this.resolve("delete");
    }
    // --- ROOT FACTORIES ---
    static database(id = "*") {
        return new Channel(["databases", normalize(id)]);
    }
    static execution(id = "*") {
        return new Channel(["executions", normalize(id)]);
    }
    static tablesdb(id = "*") {
        return new Channel(["tablesdb", normalize(id)]);
    }
    static bucket(id = "*") {
        return new Channel(["buckets", normalize(id)]);
    }
    static function(id = "*") {
        return new Channel(["functions", normalize(id)]);
    }
    static team(id = "*") {
        return new Channel(["teams", normalize(id)]);
    }
    static membership(id = "*") {
        return new Channel(["memberships", normalize(id)]);
    }
    static account() {
        return "account";
    }
    // Global events
    static documents() {
        return "documents";
    }
    static rows() {
        return "rows";
    }
    static files() {
        return "files";
    }
    static executions() {
        return "executions";
    }
    static teams() {
        return "teams";
    }
    static memberships() {
        return "memberships";
    }
}

var Condition;
(function (Condition) {
    Condition["Equal"] = "equal";
    Condition["NotEqual"] = "notEqual";
    Condition["GreaterThan"] = "greaterThan";
    Condition["GreaterThanEqual"] = "greaterThanEqual";
    Condition["LessThan"] = "lessThan";
    Condition["LessThanEqual"] = "lessThanEqual";
    Condition["Contains"] = "contains";
    Condition["IsNull"] = "isNull";
    Condition["IsNotNull"] = "isNotNull";
})(Condition || (Condition = {}));
/**
 * Helper class to generate operator strings for atomic operations.
 */
class Operator {
    /**
     * Constructor for Operator class.
     *
     * @param {string} method
     * @param {OperatorValues} values
     */
    constructor(method, values) {
        this.method = method;
        if (values !== undefined) {
            if (Array.isArray(values)) {
                this.values = values;
            }
            else {
                this.values = [values];
            }
        }
    }
    /**
     * Convert the operator object to a JSON string.
     *
     * @returns {string}
     */
    toString() {
        return JSON.stringify({
            method: this.method,
            values: this.values,
        });
    }
}
/**
 * Increment a numeric attribute by a specified value.
 *
 * @param {number} value
 * @param {number} max
 * @returns {string}
 */
Operator.increment = (value = 1, max) => {
    if (isNaN(value) || !isFinite(value)) {
        throw new Error("Value cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
        throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [value];
    if (max !== undefined) {
        values.push(max);
    }
    return new Operator("increment", values).toString();
};
/**
 * Decrement a numeric attribute by a specified value.
 *
 * @param {number} value
 * @param {number} min
 * @returns {string}
 */
Operator.decrement = (value = 1, min) => {
    if (isNaN(value) || !isFinite(value)) {
        throw new Error("Value cannot be NaN or Infinity");
    }
    if (min !== undefined && (isNaN(min) || !isFinite(min))) {
        throw new Error("Min cannot be NaN or Infinity");
    }
    const values = [value];
    if (min !== undefined) {
        values.push(min);
    }
    return new Operator("decrement", values).toString();
};
/**
 * Multiply a numeric attribute by a specified factor.
 *
 * @param {number} factor
 * @param {number} max
 * @returns {string}
 */
Operator.multiply = (factor, max) => {
    if (isNaN(factor) || !isFinite(factor)) {
        throw new Error("Factor cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
        throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [factor];
    if (max !== undefined) {
        values.push(max);
    }
    return new Operator("multiply", values).toString();
};
/**
 * Divide a numeric attribute by a specified divisor.
 *
 * @param {number} divisor
 * @param {number} min
 * @returns {string}
 */
Operator.divide = (divisor, min) => {
    if (isNaN(divisor) || !isFinite(divisor)) {
        throw new Error("Divisor cannot be NaN or Infinity");
    }
    if (min !== undefined && (isNaN(min) || !isFinite(min))) {
        throw new Error("Min cannot be NaN or Infinity");
    }
    if (divisor === 0) {
        throw new Error("Divisor cannot be zero");
    }
    const values = [divisor];
    if (min !== undefined) {
        values.push(min);
    }
    return new Operator("divide", values).toString();
};
/**
 * Apply modulo operation on a numeric attribute.
 *
 * @param {number} divisor
 * @returns {string}
 */
Operator.modulo = (divisor) => {
    if (isNaN(divisor) || !isFinite(divisor)) {
        throw new Error("Divisor cannot be NaN or Infinity");
    }
    if (divisor === 0) {
        throw new Error("Divisor cannot be zero");
    }
    return new Operator("modulo", [divisor]).toString();
};
/**
 * Raise a numeric attribute to a specified power.
 *
 * @param {number} exponent
 * @param {number} max
 * @returns {string}
 */
Operator.power = (exponent, max) => {
    if (isNaN(exponent) || !isFinite(exponent)) {
        throw new Error("Exponent cannot be NaN or Infinity");
    }
    if (max !== undefined && (isNaN(max) || !isFinite(max))) {
        throw new Error("Max cannot be NaN or Infinity");
    }
    const values = [exponent];
    if (max !== undefined) {
        values.push(max);
    }
    return new Operator("power", values).toString();
};
/**
 * Append values to an array attribute.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayAppend = (values) => new Operator("arrayAppend", values).toString();
/**
 * Prepend values to an array attribute.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayPrepend = (values) => new Operator("arrayPrepend", values).toString();
/**
 * Insert a value at a specific index in an array attribute.
 *
 * @param {number} index
 * @param {any} value
 * @returns {string}
 */
Operator.arrayInsert = (index, value) => new Operator("arrayInsert", [index, value]).toString();
/**
 * Remove a value from an array attribute.
 *
 * @param {any} value
 * @returns {string}
 */
Operator.arrayRemove = (value) => new Operator("arrayRemove", [value]).toString();
/**
 * Remove duplicate values from an array attribute.
 *
 * @returns {string}
 */
Operator.arrayUnique = () => new Operator("arrayUnique", []).toString();
/**
 * Keep only values that exist in both the current array and the provided array.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayIntersect = (values) => new Operator("arrayIntersect", values).toString();
/**
 * Remove values from the array that exist in the provided array.
 *
 * @param {any[]} values
 * @returns {string}
 */
Operator.arrayDiff = (values) => new Operator("arrayDiff", values).toString();
/**
 * Filter array values based on a condition.
 *
 * @param {Condition} condition
 * @param {any} value
 * @returns {string}
 */
Operator.arrayFilter = (condition, value) => {
    const values = [condition, value === undefined ? null : value];
    return new Operator("arrayFilter", values).toString();
};
/**
 * Concatenate a value to a string or array attribute.
 *
 * @param {any} value
 * @returns {string}
 */
Operator.stringConcat = (value) => new Operator("stringConcat", [value]).toString();
/**
 * Replace occurrences of a search string with a replacement string.
 *
 * @param {string} search
 * @param {string} replace
 * @returns {string}
 */
Operator.stringReplace = (search, replace) => new Operator("stringReplace", [search, replace]).toString();
/**
 * Toggle a boolean attribute.
 *
 * @returns {string}
 */
Operator.toggle = () => new Operator("toggle", []).toString();
/**
 * Add days to a date attribute.
 *
 * @param {number} days
 * @returns {string}
 */
Operator.dateAddDays = (days) => new Operator("dateAddDays", [days]).toString();
/**
 * Subtract days from a date attribute.
 *
 * @param {number} days
 * @returns {string}
 */
Operator.dateSubDays = (days) => new Operator("dateSubDays", [days]).toString();
/**
 * Set a date attribute to the current date and time.
 *
 * @returns {string}
 */
Operator.dateSetNow = () => new Operator("dateSetNow", []).toString();

var Scopes;
(function (Scopes) {
    Scopes["Account"] = "account";
    Scopes["TeamsRead"] = "teams.read";
    Scopes["TeamsWrite"] = "teams.write";
    Scopes["SessionsWrite"] = "sessions.write";
    Scopes["UsersRead"] = "users.read";
    Scopes["UsersWrite"] = "users.write";
    Scopes["DatabasesRead"] = "databases.read";
    Scopes["DatabasesWrite"] = "databases.write";
    Scopes["CollectionsRead"] = "collections.read";
    Scopes["CollectionsWrite"] = "collections.write";
    Scopes["TablesRead"] = "tables.read";
    Scopes["TablesWrite"] = "tables.write";
    Scopes["AttributesRead"] = "attributes.read";
    Scopes["AttributesWrite"] = "attributes.write";
    Scopes["ColumnsRead"] = "columns.read";
    Scopes["ColumnsWrite"] = "columns.write";
    Scopes["IndexesRead"] = "indexes.read";
    Scopes["IndexesWrite"] = "indexes.write";
    Scopes["DocumentsRead"] = "documents.read";
    Scopes["DocumentsWrite"] = "documents.write";
    Scopes["RowsRead"] = "rows.read";
    Scopes["RowsWrite"] = "rows.write";
    Scopes["FilesRead"] = "files.read";
    Scopes["FilesWrite"] = "files.write";
    Scopes["BucketsRead"] = "buckets.read";
    Scopes["BucketsWrite"] = "buckets.write";
    Scopes["FunctionsRead"] = "functions.read";
    Scopes["FunctionsWrite"] = "functions.write";
    Scopes["SitesRead"] = "sites.read";
    Scopes["SitesWrite"] = "sites.write";
    Scopes["LogRead"] = "log.read";
    Scopes["LogWrite"] = "log.write";
    Scopes["ExecutionRead"] = "execution.read";
    Scopes["ExecutionWrite"] = "execution.write";
    Scopes["LocaleRead"] = "locale.read";
    Scopes["AvatarsRead"] = "avatars.read";
    Scopes["HealthRead"] = "health.read";
    Scopes["ProvidersRead"] = "providers.read";
    Scopes["ProvidersWrite"] = "providers.write";
    Scopes["MessagesRead"] = "messages.read";
    Scopes["MessagesWrite"] = "messages.write";
    Scopes["TopicsRead"] = "topics.read";
    Scopes["TopicsWrite"] = "topics.write";
    Scopes["SubscribersRead"] = "subscribers.read";
    Scopes["SubscribersWrite"] = "subscribers.write";
    Scopes["TargetsRead"] = "targets.read";
    Scopes["TargetsWrite"] = "targets.write";
    Scopes["RulesRead"] = "rules.read";
    Scopes["RulesWrite"] = "rules.write";
    Scopes["SchedulesRead"] = "schedules.read";
    Scopes["SchedulesWrite"] = "schedules.write";
    Scopes["MigrationsRead"] = "migrations.read";
    Scopes["MigrationsWrite"] = "migrations.write";
    Scopes["VcsRead"] = "vcs.read";
    Scopes["VcsWrite"] = "vcs.write";
    Scopes["AssistantRead"] = "assistant.read";
    Scopes["TokensRead"] = "tokens.read";
    Scopes["TokensWrite"] = "tokens.write";
    Scopes["PoliciesWrite"] = "policies.write";
    Scopes["PoliciesRead"] = "policies.read";
    Scopes["ArchivesRead"] = "archives.read";
    Scopes["ArchivesWrite"] = "archives.write";
    Scopes["RestorationsRead"] = "restorations.read";
    Scopes["RestorationsWrite"] = "restorations.write";
    Scopes["DomainsRead"] = "domains.read";
    Scopes["DomainsWrite"] = "domains.write";
    Scopes["EventsRead"] = "events.read";
    Scopes["PlatformsRead"] = "platforms.read";
    Scopes["PlatformsWrite"] = "platforms.write";
    Scopes["ProjectsRead"] = "projects.read";
    Scopes["ProjectsWrite"] = "projects.write";
    Scopes["KeysRead"] = "keys.read";
    Scopes["KeysWrite"] = "keys.write";
    Scopes["DevKeysRead"] = "devKeys.read";
    Scopes["DevKeysWrite"] = "devKeys.write";
    Scopes["WebhooksRead"] = "webhooks.read";
    Scopes["WebhooksWrite"] = "webhooks.write";
})(Scopes || (Scopes = {}));

var AuthenticatorType;
(function (AuthenticatorType) {
    AuthenticatorType["Totp"] = "totp";
})(AuthenticatorType || (AuthenticatorType = {}));

var AuthenticationFactor;
(function (AuthenticationFactor) {
    AuthenticationFactor["Email"] = "email";
    AuthenticationFactor["Phone"] = "phone";
    AuthenticationFactor["Totp"] = "totp";
    AuthenticationFactor["Recoverycode"] = "recoverycode";
})(AuthenticationFactor || (AuthenticationFactor = {}));

var OAuthProvider;
(function (OAuthProvider) {
    OAuthProvider["Amazon"] = "amazon";
    OAuthProvider["Apple"] = "apple";
    OAuthProvider["Auth0"] = "auth0";
    OAuthProvider["Authentik"] = "authentik";
    OAuthProvider["Autodesk"] = "autodesk";
    OAuthProvider["Bitbucket"] = "bitbucket";
    OAuthProvider["Bitly"] = "bitly";
    OAuthProvider["Box"] = "box";
    OAuthProvider["Dailymotion"] = "dailymotion";
    OAuthProvider["Discord"] = "discord";
    OAuthProvider["Disqus"] = "disqus";
    OAuthProvider["Dropbox"] = "dropbox";
    OAuthProvider["Etsy"] = "etsy";
    OAuthProvider["Facebook"] = "facebook";
    OAuthProvider["Figma"] = "figma";
    OAuthProvider["Github"] = "github";
    OAuthProvider["Gitlab"] = "gitlab";
    OAuthProvider["Google"] = "google";
    OAuthProvider["Linkedin"] = "linkedin";
    OAuthProvider["Microsoft"] = "microsoft";
    OAuthProvider["Notion"] = "notion";
    OAuthProvider["Oidc"] = "oidc";
    OAuthProvider["Okta"] = "okta";
    OAuthProvider["Paypal"] = "paypal";
    OAuthProvider["PaypalSandbox"] = "paypalSandbox";
    OAuthProvider["Podio"] = "podio";
    OAuthProvider["Salesforce"] = "salesforce";
    OAuthProvider["Slack"] = "slack";
    OAuthProvider["Spotify"] = "spotify";
    OAuthProvider["Stripe"] = "stripe";
    OAuthProvider["Tradeshift"] = "tradeshift";
    OAuthProvider["TradeshiftBox"] = "tradeshiftBox";
    OAuthProvider["Twitch"] = "twitch";
    OAuthProvider["Wordpress"] = "wordpress";
    OAuthProvider["Yahoo"] = "yahoo";
    OAuthProvider["Yammer"] = "yammer";
    OAuthProvider["Yandex"] = "yandex";
    OAuthProvider["Zoho"] = "zoho";
    OAuthProvider["Zoom"] = "zoom";
})(OAuthProvider || (OAuthProvider = {}));

var Browser;
(function (Browser) {
    Browser["AvantBrowser"] = "aa";
    Browser["AndroidWebViewBeta"] = "an";
    Browser["GoogleChrome"] = "ch";
    Browser["GoogleChromeIOS"] = "ci";
    Browser["GoogleChromeMobile"] = "cm";
    Browser["Chromium"] = "cr";
    Browser["MozillaFirefox"] = "ff";
    Browser["Safari"] = "sf";
    Browser["MobileSafari"] = "mf";
    Browser["MicrosoftEdge"] = "ps";
    Browser["MicrosoftEdgeIOS"] = "oi";
    Browser["OperaMini"] = "om";
    Browser["Opera"] = "op";
    Browser["OperaNext"] = "on";
})(Browser || (Browser = {}));

var CreditCard;
(function (CreditCard) {
    CreditCard["AmericanExpress"] = "amex";
    CreditCard["Argencard"] = "argencard";
    CreditCard["Cabal"] = "cabal";
    CreditCard["Cencosud"] = "cencosud";
    CreditCard["DinersClub"] = "diners";
    CreditCard["Discover"] = "discover";
    CreditCard["Elo"] = "elo";
    CreditCard["Hipercard"] = "hipercard";
    CreditCard["JCB"] = "jcb";
    CreditCard["Mastercard"] = "mastercard";
    CreditCard["Naranja"] = "naranja";
    CreditCard["TarjetaShopping"] = "targeta-shopping";
    CreditCard["UnionPay"] = "unionpay";
    CreditCard["Visa"] = "visa";
    CreditCard["MIR"] = "mir";
    CreditCard["Maestro"] = "maestro";
    CreditCard["Rupay"] = "rupay";
})(CreditCard || (CreditCard = {}));

var Flag;
(function (Flag) {
    Flag["Afghanistan"] = "af";
    Flag["Angola"] = "ao";
    Flag["Albania"] = "al";
    Flag["Andorra"] = "ad";
    Flag["UnitedArabEmirates"] = "ae";
    Flag["Argentina"] = "ar";
    Flag["Armenia"] = "am";
    Flag["AntiguaAndBarbuda"] = "ag";
    Flag["Australia"] = "au";
    Flag["Austria"] = "at";
    Flag["Azerbaijan"] = "az";
    Flag["Burundi"] = "bi";
    Flag["Belgium"] = "be";
    Flag["Benin"] = "bj";
    Flag["BurkinaFaso"] = "bf";
    Flag["Bangladesh"] = "bd";
    Flag["Bulgaria"] = "bg";
    Flag["Bahrain"] = "bh";
    Flag["Bahamas"] = "bs";
    Flag["BosniaAndHerzegovina"] = "ba";
    Flag["Belarus"] = "by";
    Flag["Belize"] = "bz";
    Flag["Bolivia"] = "bo";
    Flag["Brazil"] = "br";
    Flag["Barbados"] = "bb";
    Flag["BruneiDarussalam"] = "bn";
    Flag["Bhutan"] = "bt";
    Flag["Botswana"] = "bw";
    Flag["CentralAfricanRepublic"] = "cf";
    Flag["Canada"] = "ca";
    Flag["Switzerland"] = "ch";
    Flag["Chile"] = "cl";
    Flag["China"] = "cn";
    Flag["CoteDIvoire"] = "ci";
    Flag["Cameroon"] = "cm";
    Flag["DemocraticRepublicOfTheCongo"] = "cd";
    Flag["RepublicOfTheCongo"] = "cg";
    Flag["Colombia"] = "co";
    Flag["Comoros"] = "km";
    Flag["CapeVerde"] = "cv";
    Flag["CostaRica"] = "cr";
    Flag["Cuba"] = "cu";
    Flag["Cyprus"] = "cy";
    Flag["CzechRepublic"] = "cz";
    Flag["Germany"] = "de";
    Flag["Djibouti"] = "dj";
    Flag["Dominica"] = "dm";
    Flag["Denmark"] = "dk";
    Flag["DominicanRepublic"] = "do";
    Flag["Algeria"] = "dz";
    Flag["Ecuador"] = "ec";
    Flag["Egypt"] = "eg";
    Flag["Eritrea"] = "er";
    Flag["Spain"] = "es";
    Flag["Estonia"] = "ee";
    Flag["Ethiopia"] = "et";
    Flag["Finland"] = "fi";
    Flag["Fiji"] = "fj";
    Flag["France"] = "fr";
    Flag["MicronesiaFederatedStatesOf"] = "fm";
    Flag["Gabon"] = "ga";
    Flag["UnitedKingdom"] = "gb";
    Flag["Georgia"] = "ge";
    Flag["Ghana"] = "gh";
    Flag["Guinea"] = "gn";
    Flag["Gambia"] = "gm";
    Flag["GuineaBissau"] = "gw";
    Flag["EquatorialGuinea"] = "gq";
    Flag["Greece"] = "gr";
    Flag["Grenada"] = "gd";
    Flag["Guatemala"] = "gt";
    Flag["Guyana"] = "gy";
    Flag["Honduras"] = "hn";
    Flag["Croatia"] = "hr";
    Flag["Haiti"] = "ht";
    Flag["Hungary"] = "hu";
    Flag["Indonesia"] = "id";
    Flag["India"] = "in";
    Flag["Ireland"] = "ie";
    Flag["IranIslamicRepublicOf"] = "ir";
    Flag["Iraq"] = "iq";
    Flag["Iceland"] = "is";
    Flag["Israel"] = "il";
    Flag["Italy"] = "it";
    Flag["Jamaica"] = "jm";
    Flag["Jordan"] = "jo";
    Flag["Japan"] = "jp";
    Flag["Kazakhstan"] = "kz";
    Flag["Kenya"] = "ke";
    Flag["Kyrgyzstan"] = "kg";
    Flag["Cambodia"] = "kh";
    Flag["Kiribati"] = "ki";
    Flag["SaintKittsAndNevis"] = "kn";
    Flag["SouthKorea"] = "kr";
    Flag["Kuwait"] = "kw";
    Flag["LaoPeopleSDemocraticRepublic"] = "la";
    Flag["Lebanon"] = "lb";
    Flag["Liberia"] = "lr";
    Flag["Libya"] = "ly";
    Flag["SaintLucia"] = "lc";
    Flag["Liechtenstein"] = "li";
    Flag["SriLanka"] = "lk";
    Flag["Lesotho"] = "ls";
    Flag["Lithuania"] = "lt";
    Flag["Luxembourg"] = "lu";
    Flag["Latvia"] = "lv";
    Flag["Morocco"] = "ma";
    Flag["Monaco"] = "mc";
    Flag["Moldova"] = "md";
    Flag["Madagascar"] = "mg";
    Flag["Maldives"] = "mv";
    Flag["Mexico"] = "mx";
    Flag["MarshallIslands"] = "mh";
    Flag["NorthMacedonia"] = "mk";
    Flag["Mali"] = "ml";
    Flag["Malta"] = "mt";
    Flag["Myanmar"] = "mm";
    Flag["Montenegro"] = "me";
    Flag["Mongolia"] = "mn";
    Flag["Mozambique"] = "mz";
    Flag["Mauritania"] = "mr";
    Flag["Mauritius"] = "mu";
    Flag["Malawi"] = "mw";
    Flag["Malaysia"] = "my";
    Flag["Namibia"] = "na";
    Flag["Niger"] = "ne";
    Flag["Nigeria"] = "ng";
    Flag["Nicaragua"] = "ni";
    Flag["Netherlands"] = "nl";
    Flag["Norway"] = "no";
    Flag["Nepal"] = "np";
    Flag["Nauru"] = "nr";
    Flag["NewZealand"] = "nz";
    Flag["Oman"] = "om";
    Flag["Pakistan"] = "pk";
    Flag["Panama"] = "pa";
    Flag["Peru"] = "pe";
    Flag["Philippines"] = "ph";
    Flag["Palau"] = "pw";
    Flag["PapuaNewGuinea"] = "pg";
    Flag["Poland"] = "pl";
    Flag["FrenchPolynesia"] = "pf";
    Flag["NorthKorea"] = "kp";
    Flag["Portugal"] = "pt";
    Flag["Paraguay"] = "py";
    Flag["Qatar"] = "qa";
    Flag["Romania"] = "ro";
    Flag["Russia"] = "ru";
    Flag["Rwanda"] = "rw";
    Flag["SaudiArabia"] = "sa";
    Flag["Sudan"] = "sd";
    Flag["Senegal"] = "sn";
    Flag["Singapore"] = "sg";
    Flag["SolomonIslands"] = "sb";
    Flag["SierraLeone"] = "sl";
    Flag["ElSalvador"] = "sv";
    Flag["SanMarino"] = "sm";
    Flag["Somalia"] = "so";
    Flag["Serbia"] = "rs";
    Flag["SouthSudan"] = "ss";
    Flag["SaoTomeAndPrincipe"] = "st";
    Flag["Suriname"] = "sr";
    Flag["Slovakia"] = "sk";
    Flag["Slovenia"] = "si";
    Flag["Sweden"] = "se";
    Flag["Eswatini"] = "sz";
    Flag["Seychelles"] = "sc";
    Flag["Syria"] = "sy";
    Flag["Chad"] = "td";
    Flag["Togo"] = "tg";
    Flag["Thailand"] = "th";
    Flag["Tajikistan"] = "tj";
    Flag["Turkmenistan"] = "tm";
    Flag["TimorLeste"] = "tl";
    Flag["Tonga"] = "to";
    Flag["TrinidadAndTobago"] = "tt";
    Flag["Tunisia"] = "tn";
    Flag["Turkey"] = "tr";
    Flag["Tuvalu"] = "tv";
    Flag["Tanzania"] = "tz";
    Flag["Uganda"] = "ug";
    Flag["Ukraine"] = "ua";
    Flag["Uruguay"] = "uy";
    Flag["UnitedStates"] = "us";
    Flag["Uzbekistan"] = "uz";
    Flag["VaticanCity"] = "va";
    Flag["SaintVincentAndTheGrenadines"] = "vc";
    Flag["Venezuela"] = "ve";
    Flag["Vietnam"] = "vn";
    Flag["Vanuatu"] = "vu";
    Flag["Samoa"] = "ws";
    Flag["Yemen"] = "ye";
    Flag["SouthAfrica"] = "za";
    Flag["Zambia"] = "zm";
    Flag["Zimbabwe"] = "zw";
})(Flag || (Flag = {}));

var Theme;
(function (Theme) {
    Theme["Light"] = "light";
    Theme["Dark"] = "dark";
})(Theme || (Theme = {}));

var Timezone;
(function (Timezone) {
    Timezone["AfricaAbidjan"] = "africa/abidjan";
    Timezone["AfricaAccra"] = "africa/accra";
    Timezone["AfricaAddisAbaba"] = "africa/addis_ababa";
    Timezone["AfricaAlgiers"] = "africa/algiers";
    Timezone["AfricaAsmara"] = "africa/asmara";
    Timezone["AfricaBamako"] = "africa/bamako";
    Timezone["AfricaBangui"] = "africa/bangui";
    Timezone["AfricaBanjul"] = "africa/banjul";
    Timezone["AfricaBissau"] = "africa/bissau";
    Timezone["AfricaBlantyre"] = "africa/blantyre";
    Timezone["AfricaBrazzaville"] = "africa/brazzaville";
    Timezone["AfricaBujumbura"] = "africa/bujumbura";
    Timezone["AfricaCairo"] = "africa/cairo";
    Timezone["AfricaCasablanca"] = "africa/casablanca";
    Timezone["AfricaCeuta"] = "africa/ceuta";
    Timezone["AfricaConakry"] = "africa/conakry";
    Timezone["AfricaDakar"] = "africa/dakar";
    Timezone["AfricaDarEsSalaam"] = "africa/dar_es_salaam";
    Timezone["AfricaDjibouti"] = "africa/djibouti";
    Timezone["AfricaDouala"] = "africa/douala";
    Timezone["AfricaElAaiun"] = "africa/el_aaiun";
    Timezone["AfricaFreetown"] = "africa/freetown";
    Timezone["AfricaGaborone"] = "africa/gaborone";
    Timezone["AfricaHarare"] = "africa/harare";
    Timezone["AfricaJohannesburg"] = "africa/johannesburg";
    Timezone["AfricaJuba"] = "africa/juba";
    Timezone["AfricaKampala"] = "africa/kampala";
    Timezone["AfricaKhartoum"] = "africa/khartoum";
    Timezone["AfricaKigali"] = "africa/kigali";
    Timezone["AfricaKinshasa"] = "africa/kinshasa";
    Timezone["AfricaLagos"] = "africa/lagos";
    Timezone["AfricaLibreville"] = "africa/libreville";
    Timezone["AfricaLome"] = "africa/lome";
    Timezone["AfricaLuanda"] = "africa/luanda";
    Timezone["AfricaLubumbashi"] = "africa/lubumbashi";
    Timezone["AfricaLusaka"] = "africa/lusaka";
    Timezone["AfricaMalabo"] = "africa/malabo";
    Timezone["AfricaMaputo"] = "africa/maputo";
    Timezone["AfricaMaseru"] = "africa/maseru";
    Timezone["AfricaMbabane"] = "africa/mbabane";
    Timezone["AfricaMogadishu"] = "africa/mogadishu";
    Timezone["AfricaMonrovia"] = "africa/monrovia";
    Timezone["AfricaNairobi"] = "africa/nairobi";
    Timezone["AfricaNdjamena"] = "africa/ndjamena";
    Timezone["AfricaNiamey"] = "africa/niamey";
    Timezone["AfricaNouakchott"] = "africa/nouakchott";
    Timezone["AfricaOuagadougou"] = "africa/ouagadougou";
    Timezone["AfricaPortonovo"] = "africa/porto-novo";
    Timezone["AfricaSaoTome"] = "africa/sao_tome";
    Timezone["AfricaTripoli"] = "africa/tripoli";
    Timezone["AfricaTunis"] = "africa/tunis";
    Timezone["AfricaWindhoek"] = "africa/windhoek";
    Timezone["AmericaAdak"] = "america/adak";
    Timezone["AmericaAnchorage"] = "america/anchorage";
    Timezone["AmericaAnguilla"] = "america/anguilla";
    Timezone["AmericaAntigua"] = "america/antigua";
    Timezone["AmericaAraguaina"] = "america/araguaina";
    Timezone["AmericaArgentinaBuenosAires"] = "america/argentina/buenos_aires";
    Timezone["AmericaArgentinaCatamarca"] = "america/argentina/catamarca";
    Timezone["AmericaArgentinaCordoba"] = "america/argentina/cordoba";
    Timezone["AmericaArgentinaJujuy"] = "america/argentina/jujuy";
    Timezone["AmericaArgentinaLaRioja"] = "america/argentina/la_rioja";
    Timezone["AmericaArgentinaMendoza"] = "america/argentina/mendoza";
    Timezone["AmericaArgentinaRioGallegos"] = "america/argentina/rio_gallegos";
    Timezone["AmericaArgentinaSalta"] = "america/argentina/salta";
    Timezone["AmericaArgentinaSanJuan"] = "america/argentina/san_juan";
    Timezone["AmericaArgentinaSanLuis"] = "america/argentina/san_luis";
    Timezone["AmericaArgentinaTucuman"] = "america/argentina/tucuman";
    Timezone["AmericaArgentinaUshuaia"] = "america/argentina/ushuaia";
    Timezone["AmericaAruba"] = "america/aruba";
    Timezone["AmericaAsuncion"] = "america/asuncion";
    Timezone["AmericaAtikokan"] = "america/atikokan";
    Timezone["AmericaBahia"] = "america/bahia";
    Timezone["AmericaBahiaBanderas"] = "america/bahia_banderas";
    Timezone["AmericaBarbados"] = "america/barbados";
    Timezone["AmericaBelem"] = "america/belem";
    Timezone["AmericaBelize"] = "america/belize";
    Timezone["AmericaBlancsablon"] = "america/blanc-sablon";
    Timezone["AmericaBoaVista"] = "america/boa_vista";
    Timezone["AmericaBogota"] = "america/bogota";
    Timezone["AmericaBoise"] = "america/boise";
    Timezone["AmericaCambridgeBay"] = "america/cambridge_bay";
    Timezone["AmericaCampoGrande"] = "america/campo_grande";
    Timezone["AmericaCancun"] = "america/cancun";
    Timezone["AmericaCaracas"] = "america/caracas";
    Timezone["AmericaCayenne"] = "america/cayenne";
    Timezone["AmericaCayman"] = "america/cayman";
    Timezone["AmericaChicago"] = "america/chicago";
    Timezone["AmericaChihuahua"] = "america/chihuahua";
    Timezone["AmericaCiudadJuarez"] = "america/ciudad_juarez";
    Timezone["AmericaCostaRica"] = "america/costa_rica";
    Timezone["AmericaCoyhaique"] = "america/coyhaique";
    Timezone["AmericaCreston"] = "america/creston";
    Timezone["AmericaCuiaba"] = "america/cuiaba";
    Timezone["AmericaCuracao"] = "america/curacao";
    Timezone["AmericaDanmarkshavn"] = "america/danmarkshavn";
    Timezone["AmericaDawson"] = "america/dawson";
    Timezone["AmericaDawsonCreek"] = "america/dawson_creek";
    Timezone["AmericaDenver"] = "america/denver";
    Timezone["AmericaDetroit"] = "america/detroit";
    Timezone["AmericaDominica"] = "america/dominica";
    Timezone["AmericaEdmonton"] = "america/edmonton";
    Timezone["AmericaEirunepe"] = "america/eirunepe";
    Timezone["AmericaElSalvador"] = "america/el_salvador";
    Timezone["AmericaFortNelson"] = "america/fort_nelson";
    Timezone["AmericaFortaleza"] = "america/fortaleza";
    Timezone["AmericaGlaceBay"] = "america/glace_bay";
    Timezone["AmericaGooseBay"] = "america/goose_bay";
    Timezone["AmericaGrandTurk"] = "america/grand_turk";
    Timezone["AmericaGrenada"] = "america/grenada";
    Timezone["AmericaGuadeloupe"] = "america/guadeloupe";
    Timezone["AmericaGuatemala"] = "america/guatemala";
    Timezone["AmericaGuayaquil"] = "america/guayaquil";
    Timezone["AmericaGuyana"] = "america/guyana";
    Timezone["AmericaHalifax"] = "america/halifax";
    Timezone["AmericaHavana"] = "america/havana";
    Timezone["AmericaHermosillo"] = "america/hermosillo";
    Timezone["AmericaIndianaIndianapolis"] = "america/indiana/indianapolis";
    Timezone["AmericaIndianaKnox"] = "america/indiana/knox";
    Timezone["AmericaIndianaMarengo"] = "america/indiana/marengo";
    Timezone["AmericaIndianaPetersburg"] = "america/indiana/petersburg";
    Timezone["AmericaIndianaTellCity"] = "america/indiana/tell_city";
    Timezone["AmericaIndianaVevay"] = "america/indiana/vevay";
    Timezone["AmericaIndianaVincennes"] = "america/indiana/vincennes";
    Timezone["AmericaIndianaWinamac"] = "america/indiana/winamac";
    Timezone["AmericaInuvik"] = "america/inuvik";
    Timezone["AmericaIqaluit"] = "america/iqaluit";
    Timezone["AmericaJamaica"] = "america/jamaica";
    Timezone["AmericaJuneau"] = "america/juneau";
    Timezone["AmericaKentuckyLouisville"] = "america/kentucky/louisville";
    Timezone["AmericaKentuckyMonticello"] = "america/kentucky/monticello";
    Timezone["AmericaKralendijk"] = "america/kralendijk";
    Timezone["AmericaLaPaz"] = "america/la_paz";
    Timezone["AmericaLima"] = "america/lima";
    Timezone["AmericaLosAngeles"] = "america/los_angeles";
    Timezone["AmericaLowerPrinces"] = "america/lower_princes";
    Timezone["AmericaMaceio"] = "america/maceio";
    Timezone["AmericaManagua"] = "america/managua";
    Timezone["AmericaManaus"] = "america/manaus";
    Timezone["AmericaMarigot"] = "america/marigot";
    Timezone["AmericaMartinique"] = "america/martinique";
    Timezone["AmericaMatamoros"] = "america/matamoros";
    Timezone["AmericaMazatlan"] = "america/mazatlan";
    Timezone["AmericaMenominee"] = "america/menominee";
    Timezone["AmericaMerida"] = "america/merida";
    Timezone["AmericaMetlakatla"] = "america/metlakatla";
    Timezone["AmericaMexicoCity"] = "america/mexico_city";
    Timezone["AmericaMiquelon"] = "america/miquelon";
    Timezone["AmericaMoncton"] = "america/moncton";
    Timezone["AmericaMonterrey"] = "america/monterrey";
    Timezone["AmericaMontevideo"] = "america/montevideo";
    Timezone["AmericaMontserrat"] = "america/montserrat";
    Timezone["AmericaNassau"] = "america/nassau";
    Timezone["AmericaNewYork"] = "america/new_york";
    Timezone["AmericaNome"] = "america/nome";
    Timezone["AmericaNoronha"] = "america/noronha";
    Timezone["AmericaNorthDakotaBeulah"] = "america/north_dakota/beulah";
    Timezone["AmericaNorthDakotaCenter"] = "america/north_dakota/center";
    Timezone["AmericaNorthDakotaNewSalem"] = "america/north_dakota/new_salem";
    Timezone["AmericaNuuk"] = "america/nuuk";
    Timezone["AmericaOjinaga"] = "america/ojinaga";
    Timezone["AmericaPanama"] = "america/panama";
    Timezone["AmericaParamaribo"] = "america/paramaribo";
    Timezone["AmericaPhoenix"] = "america/phoenix";
    Timezone["AmericaPortauprince"] = "america/port-au-prince";
    Timezone["AmericaPortOfSpain"] = "america/port_of_spain";
    Timezone["AmericaPortoVelho"] = "america/porto_velho";
    Timezone["AmericaPuertoRico"] = "america/puerto_rico";
    Timezone["AmericaPuntaArenas"] = "america/punta_arenas";
    Timezone["AmericaRankinInlet"] = "america/rankin_inlet";
    Timezone["AmericaRecife"] = "america/recife";
    Timezone["AmericaRegina"] = "america/regina";
    Timezone["AmericaResolute"] = "america/resolute";
    Timezone["AmericaRioBranco"] = "america/rio_branco";
    Timezone["AmericaSantarem"] = "america/santarem";
    Timezone["AmericaSantiago"] = "america/santiago";
    Timezone["AmericaSantoDomingo"] = "america/santo_domingo";
    Timezone["AmericaSaoPaulo"] = "america/sao_paulo";
    Timezone["AmericaScoresbysund"] = "america/scoresbysund";
    Timezone["AmericaSitka"] = "america/sitka";
    Timezone["AmericaStBarthelemy"] = "america/st_barthelemy";
    Timezone["AmericaStJohns"] = "america/st_johns";
    Timezone["AmericaStKitts"] = "america/st_kitts";
    Timezone["AmericaStLucia"] = "america/st_lucia";
    Timezone["AmericaStThomas"] = "america/st_thomas";
    Timezone["AmericaStVincent"] = "america/st_vincent";
    Timezone["AmericaSwiftCurrent"] = "america/swift_current";
    Timezone["AmericaTegucigalpa"] = "america/tegucigalpa";
    Timezone["AmericaThule"] = "america/thule";
    Timezone["AmericaTijuana"] = "america/tijuana";
    Timezone["AmericaToronto"] = "america/toronto";
    Timezone["AmericaTortola"] = "america/tortola";
    Timezone["AmericaVancouver"] = "america/vancouver";
    Timezone["AmericaWhitehorse"] = "america/whitehorse";
    Timezone["AmericaWinnipeg"] = "america/winnipeg";
    Timezone["AmericaYakutat"] = "america/yakutat";
    Timezone["AntarcticaCasey"] = "antarctica/casey";
    Timezone["AntarcticaDavis"] = "antarctica/davis";
    Timezone["AntarcticaDumontdurville"] = "antarctica/dumontdurville";
    Timezone["AntarcticaMacquarie"] = "antarctica/macquarie";
    Timezone["AntarcticaMawson"] = "antarctica/mawson";
    Timezone["AntarcticaMcmurdo"] = "antarctica/mcmurdo";
    Timezone["AntarcticaPalmer"] = "antarctica/palmer";
    Timezone["AntarcticaRothera"] = "antarctica/rothera";
    Timezone["AntarcticaSyowa"] = "antarctica/syowa";
    Timezone["AntarcticaTroll"] = "antarctica/troll";
    Timezone["AntarcticaVostok"] = "antarctica/vostok";
    Timezone["ArcticLongyearbyen"] = "arctic/longyearbyen";
    Timezone["AsiaAden"] = "asia/aden";
    Timezone["AsiaAlmaty"] = "asia/almaty";
    Timezone["AsiaAmman"] = "asia/amman";
    Timezone["AsiaAnadyr"] = "asia/anadyr";
    Timezone["AsiaAqtau"] = "asia/aqtau";
    Timezone["AsiaAqtobe"] = "asia/aqtobe";
    Timezone["AsiaAshgabat"] = "asia/ashgabat";
    Timezone["AsiaAtyrau"] = "asia/atyrau";
    Timezone["AsiaBaghdad"] = "asia/baghdad";
    Timezone["AsiaBahrain"] = "asia/bahrain";
    Timezone["AsiaBaku"] = "asia/baku";
    Timezone["AsiaBangkok"] = "asia/bangkok";
    Timezone["AsiaBarnaul"] = "asia/barnaul";
    Timezone["AsiaBeirut"] = "asia/beirut";
    Timezone["AsiaBishkek"] = "asia/bishkek";
    Timezone["AsiaBrunei"] = "asia/brunei";
    Timezone["AsiaChita"] = "asia/chita";
    Timezone["AsiaColombo"] = "asia/colombo";
    Timezone["AsiaDamascus"] = "asia/damascus";
    Timezone["AsiaDhaka"] = "asia/dhaka";
    Timezone["AsiaDili"] = "asia/dili";
    Timezone["AsiaDubai"] = "asia/dubai";
    Timezone["AsiaDushanbe"] = "asia/dushanbe";
    Timezone["AsiaFamagusta"] = "asia/famagusta";
    Timezone["AsiaGaza"] = "asia/gaza";
    Timezone["AsiaHebron"] = "asia/hebron";
    Timezone["AsiaHoChiMinh"] = "asia/ho_chi_minh";
    Timezone["AsiaHongKong"] = "asia/hong_kong";
    Timezone["AsiaHovd"] = "asia/hovd";
    Timezone["AsiaIrkutsk"] = "asia/irkutsk";
    Timezone["AsiaJakarta"] = "asia/jakarta";
    Timezone["AsiaJayapura"] = "asia/jayapura";
    Timezone["AsiaJerusalem"] = "asia/jerusalem";
    Timezone["AsiaKabul"] = "asia/kabul";
    Timezone["AsiaKamchatka"] = "asia/kamchatka";
    Timezone["AsiaKarachi"] = "asia/karachi";
    Timezone["AsiaKathmandu"] = "asia/kathmandu";
    Timezone["AsiaKhandyga"] = "asia/khandyga";
    Timezone["AsiaKolkata"] = "asia/kolkata";
    Timezone["AsiaKrasnoyarsk"] = "asia/krasnoyarsk";
    Timezone["AsiaKualaLumpur"] = "asia/kuala_lumpur";
    Timezone["AsiaKuching"] = "asia/kuching";
    Timezone["AsiaKuwait"] = "asia/kuwait";
    Timezone["AsiaMacau"] = "asia/macau";
    Timezone["AsiaMagadan"] = "asia/magadan";
    Timezone["AsiaMakassar"] = "asia/makassar";
    Timezone["AsiaManila"] = "asia/manila";
    Timezone["AsiaMuscat"] = "asia/muscat";
    Timezone["AsiaNicosia"] = "asia/nicosia";
    Timezone["AsiaNovokuznetsk"] = "asia/novokuznetsk";
    Timezone["AsiaNovosibirsk"] = "asia/novosibirsk";
    Timezone["AsiaOmsk"] = "asia/omsk";
    Timezone["AsiaOral"] = "asia/oral";
    Timezone["AsiaPhnomPenh"] = "asia/phnom_penh";
    Timezone["AsiaPontianak"] = "asia/pontianak";
    Timezone["AsiaPyongyang"] = "asia/pyongyang";
    Timezone["AsiaQatar"] = "asia/qatar";
    Timezone["AsiaQostanay"] = "asia/qostanay";
    Timezone["AsiaQyzylorda"] = "asia/qyzylorda";
    Timezone["AsiaRiyadh"] = "asia/riyadh";
    Timezone["AsiaSakhalin"] = "asia/sakhalin";
    Timezone["AsiaSamarkand"] = "asia/samarkand";
    Timezone["AsiaSeoul"] = "asia/seoul";
    Timezone["AsiaShanghai"] = "asia/shanghai";
    Timezone["AsiaSingapore"] = "asia/singapore";
    Timezone["AsiaSrednekolymsk"] = "asia/srednekolymsk";
    Timezone["AsiaTaipei"] = "asia/taipei";
    Timezone["AsiaTashkent"] = "asia/tashkent";
    Timezone["AsiaTbilisi"] = "asia/tbilisi";
    Timezone["AsiaTehran"] = "asia/tehran";
    Timezone["AsiaThimphu"] = "asia/thimphu";
    Timezone["AsiaTokyo"] = "asia/tokyo";
    Timezone["AsiaTomsk"] = "asia/tomsk";
    Timezone["AsiaUlaanbaatar"] = "asia/ulaanbaatar";
    Timezone["AsiaUrumqi"] = "asia/urumqi";
    Timezone["AsiaUstnera"] = "asia/ust-nera";
    Timezone["AsiaVientiane"] = "asia/vientiane";
    Timezone["AsiaVladivostok"] = "asia/vladivostok";
    Timezone["AsiaYakutsk"] = "asia/yakutsk";
    Timezone["AsiaYangon"] = "asia/yangon";
    Timezone["AsiaYekaterinburg"] = "asia/yekaterinburg";
    Timezone["AsiaYerevan"] = "asia/yerevan";
    Timezone["AtlanticAzores"] = "atlantic/azores";
    Timezone["AtlanticBermuda"] = "atlantic/bermuda";
    Timezone["AtlanticCanary"] = "atlantic/canary";
    Timezone["AtlanticCapeVerde"] = "atlantic/cape_verde";
    Timezone["AtlanticFaroe"] = "atlantic/faroe";
    Timezone["AtlanticMadeira"] = "atlantic/madeira";
    Timezone["AtlanticReykjavik"] = "atlantic/reykjavik";
    Timezone["AtlanticSouthGeorgia"] = "atlantic/south_georgia";
    Timezone["AtlanticStHelena"] = "atlantic/st_helena";
    Timezone["AtlanticStanley"] = "atlantic/stanley";
    Timezone["AustraliaAdelaide"] = "australia/adelaide";
    Timezone["AustraliaBrisbane"] = "australia/brisbane";
    Timezone["AustraliaBrokenHill"] = "australia/broken_hill";
    Timezone["AustraliaDarwin"] = "australia/darwin";
    Timezone["AustraliaEucla"] = "australia/eucla";
    Timezone["AustraliaHobart"] = "australia/hobart";
    Timezone["AustraliaLindeman"] = "australia/lindeman";
    Timezone["AustraliaLordHowe"] = "australia/lord_howe";
    Timezone["AustraliaMelbourne"] = "australia/melbourne";
    Timezone["AustraliaPerth"] = "australia/perth";
    Timezone["AustraliaSydney"] = "australia/sydney";
    Timezone["EuropeAmsterdam"] = "europe/amsterdam";
    Timezone["EuropeAndorra"] = "europe/andorra";
    Timezone["EuropeAstrakhan"] = "europe/astrakhan";
    Timezone["EuropeAthens"] = "europe/athens";
    Timezone["EuropeBelgrade"] = "europe/belgrade";
    Timezone["EuropeBerlin"] = "europe/berlin";
    Timezone["EuropeBratislava"] = "europe/bratislava";
    Timezone["EuropeBrussels"] = "europe/brussels";
    Timezone["EuropeBucharest"] = "europe/bucharest";
    Timezone["EuropeBudapest"] = "europe/budapest";
    Timezone["EuropeBusingen"] = "europe/busingen";
    Timezone["EuropeChisinau"] = "europe/chisinau";
    Timezone["EuropeCopenhagen"] = "europe/copenhagen";
    Timezone["EuropeDublin"] = "europe/dublin";
    Timezone["EuropeGibraltar"] = "europe/gibraltar";
    Timezone["EuropeGuernsey"] = "europe/guernsey";
    Timezone["EuropeHelsinki"] = "europe/helsinki";
    Timezone["EuropeIsleOfMan"] = "europe/isle_of_man";
    Timezone["EuropeIstanbul"] = "europe/istanbul";
    Timezone["EuropeJersey"] = "europe/jersey";
    Timezone["EuropeKaliningrad"] = "europe/kaliningrad";
    Timezone["EuropeKirov"] = "europe/kirov";
    Timezone["EuropeKyiv"] = "europe/kyiv";
    Timezone["EuropeLisbon"] = "europe/lisbon";
    Timezone["EuropeLjubljana"] = "europe/ljubljana";
    Timezone["EuropeLondon"] = "europe/london";
    Timezone["EuropeLuxembourg"] = "europe/luxembourg";
    Timezone["EuropeMadrid"] = "europe/madrid";
    Timezone["EuropeMalta"] = "europe/malta";
    Timezone["EuropeMariehamn"] = "europe/mariehamn";
    Timezone["EuropeMinsk"] = "europe/minsk";
    Timezone["EuropeMonaco"] = "europe/monaco";
    Timezone["EuropeMoscow"] = "europe/moscow";
    Timezone["EuropeOslo"] = "europe/oslo";
    Timezone["EuropeParis"] = "europe/paris";
    Timezone["EuropePodgorica"] = "europe/podgorica";
    Timezone["EuropePrague"] = "europe/prague";
    Timezone["EuropeRiga"] = "europe/riga";
    Timezone["EuropeRome"] = "europe/rome";
    Timezone["EuropeSamara"] = "europe/samara";
    Timezone["EuropeSanMarino"] = "europe/san_marino";
    Timezone["EuropeSarajevo"] = "europe/sarajevo";
    Timezone["EuropeSaratov"] = "europe/saratov";
    Timezone["EuropeSimferopol"] = "europe/simferopol";
    Timezone["EuropeSkopje"] = "europe/skopje";
    Timezone["EuropeSofia"] = "europe/sofia";
    Timezone["EuropeStockholm"] = "europe/stockholm";
    Timezone["EuropeTallinn"] = "europe/tallinn";
    Timezone["EuropeTirane"] = "europe/tirane";
    Timezone["EuropeUlyanovsk"] = "europe/ulyanovsk";
    Timezone["EuropeVaduz"] = "europe/vaduz";
    Timezone["EuropeVatican"] = "europe/vatican";
    Timezone["EuropeVienna"] = "europe/vienna";
    Timezone["EuropeVilnius"] = "europe/vilnius";
    Timezone["EuropeVolgograd"] = "europe/volgograd";
    Timezone["EuropeWarsaw"] = "europe/warsaw";
    Timezone["EuropeZagreb"] = "europe/zagreb";
    Timezone["EuropeZurich"] = "europe/zurich";
    Timezone["IndianAntananarivo"] = "indian/antananarivo";
    Timezone["IndianChagos"] = "indian/chagos";
    Timezone["IndianChristmas"] = "indian/christmas";
    Timezone["IndianCocos"] = "indian/cocos";
    Timezone["IndianComoro"] = "indian/comoro";
    Timezone["IndianKerguelen"] = "indian/kerguelen";
    Timezone["IndianMahe"] = "indian/mahe";
    Timezone["IndianMaldives"] = "indian/maldives";
    Timezone["IndianMauritius"] = "indian/mauritius";
    Timezone["IndianMayotte"] = "indian/mayotte";
    Timezone["IndianReunion"] = "indian/reunion";
    Timezone["PacificApia"] = "pacific/apia";
    Timezone["PacificAuckland"] = "pacific/auckland";
    Timezone["PacificBougainville"] = "pacific/bougainville";
    Timezone["PacificChatham"] = "pacific/chatham";
    Timezone["PacificChuuk"] = "pacific/chuuk";
    Timezone["PacificEaster"] = "pacific/easter";
    Timezone["PacificEfate"] = "pacific/efate";
    Timezone["PacificFakaofo"] = "pacific/fakaofo";
    Timezone["PacificFiji"] = "pacific/fiji";
    Timezone["PacificFunafuti"] = "pacific/funafuti";
    Timezone["PacificGalapagos"] = "pacific/galapagos";
    Timezone["PacificGambier"] = "pacific/gambier";
    Timezone["PacificGuadalcanal"] = "pacific/guadalcanal";
    Timezone["PacificGuam"] = "pacific/guam";
    Timezone["PacificHonolulu"] = "pacific/honolulu";
    Timezone["PacificKanton"] = "pacific/kanton";
    Timezone["PacificKiritimati"] = "pacific/kiritimati";
    Timezone["PacificKosrae"] = "pacific/kosrae";
    Timezone["PacificKwajalein"] = "pacific/kwajalein";
    Timezone["PacificMajuro"] = "pacific/majuro";
    Timezone["PacificMarquesas"] = "pacific/marquesas";
    Timezone["PacificMidway"] = "pacific/midway";
    Timezone["PacificNauru"] = "pacific/nauru";
    Timezone["PacificNiue"] = "pacific/niue";
    Timezone["PacificNorfolk"] = "pacific/norfolk";
    Timezone["PacificNoumea"] = "pacific/noumea";
    Timezone["PacificPagoPago"] = "pacific/pago_pago";
    Timezone["PacificPalau"] = "pacific/palau";
    Timezone["PacificPitcairn"] = "pacific/pitcairn";
    Timezone["PacificPohnpei"] = "pacific/pohnpei";
    Timezone["PacificPortMoresby"] = "pacific/port_moresby";
    Timezone["PacificRarotonga"] = "pacific/rarotonga";
    Timezone["PacificSaipan"] = "pacific/saipan";
    Timezone["PacificTahiti"] = "pacific/tahiti";
    Timezone["PacificTarawa"] = "pacific/tarawa";
    Timezone["PacificTongatapu"] = "pacific/tongatapu";
    Timezone["PacificWake"] = "pacific/wake";
    Timezone["PacificWallis"] = "pacific/wallis";
    Timezone["Utc"] = "utc";
})(Timezone || (Timezone = {}));

var BrowserPermission;
(function (BrowserPermission) {
    BrowserPermission["Geolocation"] = "geolocation";
    BrowserPermission["Camera"] = "camera";
    BrowserPermission["Microphone"] = "microphone";
    BrowserPermission["Notifications"] = "notifications";
    BrowserPermission["Midi"] = "midi";
    BrowserPermission["Push"] = "push";
    BrowserPermission["Clipboardread"] = "clipboard-read";
    BrowserPermission["Clipboardwrite"] = "clipboard-write";
    BrowserPermission["Paymenthandler"] = "payment-handler";
    BrowserPermission["Usb"] = "usb";
    BrowserPermission["Bluetooth"] = "bluetooth";
    BrowserPermission["Accelerometer"] = "accelerometer";
    BrowserPermission["Gyroscope"] = "gyroscope";
    BrowserPermission["Magnetometer"] = "magnetometer";
    BrowserPermission["Ambientlightsensor"] = "ambient-light-sensor";
    BrowserPermission["Backgroundsync"] = "background-sync";
    BrowserPermission["Persistentstorage"] = "persistent-storage";
    BrowserPermission["Screenwakelock"] = "screen-wake-lock";
    BrowserPermission["Webshare"] = "web-share";
    BrowserPermission["Xrspatialtracking"] = "xr-spatial-tracking";
})(BrowserPermission || (BrowserPermission = {}));

var ImageFormat;
(function (ImageFormat) {
    ImageFormat["Jpg"] = "jpg";
    ImageFormat["Jpeg"] = "jpeg";
    ImageFormat["Png"] = "png";
    ImageFormat["Webp"] = "webp";
    ImageFormat["Heic"] = "heic";
    ImageFormat["Avif"] = "avif";
    ImageFormat["Gif"] = "gif";
})(ImageFormat || (ImageFormat = {}));

var BackupServices;
(function (BackupServices) {
    BackupServices["Databases"] = "databases";
    BackupServices["Functions"] = "functions";
    BackupServices["Storage"] = "storage";
})(BackupServices || (BackupServices = {}));

var Platform;
(function (Platform) {
    Platform["Appwrite"] = "appwrite";
    Platform["Imagine"] = "imagine";
})(Platform || (Platform = {}));

var ConsoleResourceType;
(function (ConsoleResourceType) {
    ConsoleResourceType["Rules"] = "rules";
})(ConsoleResourceType || (ConsoleResourceType = {}));

var UsageRange;
(function (UsageRange) {
    UsageRange["TwentyFourHours"] = "24h";
    UsageRange["ThirtyDays"] = "30d";
    UsageRange["NinetyDays"] = "90d";
})(UsageRange || (UsageRange = {}));

var RelationshipType;
(function (RelationshipType) {
    RelationshipType["OneToOne"] = "oneToOne";
    RelationshipType["ManyToOne"] = "manyToOne";
    RelationshipType["ManyToMany"] = "manyToMany";
    RelationshipType["OneToMany"] = "oneToMany";
})(RelationshipType || (RelationshipType = {}));

var RelationMutate;
(function (RelationMutate) {
    RelationMutate["Cascade"] = "cascade";
    RelationMutate["Restrict"] = "restrict";
    RelationMutate["SetNull"] = "setNull";
})(RelationMutate || (RelationMutate = {}));

var IndexType;
(function (IndexType) {
    IndexType["Key"] = "key";
    IndexType["Fulltext"] = "fulltext";
    IndexType["Unique"] = "unique";
    IndexType["Spatial"] = "spatial";
})(IndexType || (IndexType = {}));

var OrderBy;
(function (OrderBy) {
    OrderBy["Asc"] = "asc";
    OrderBy["Desc"] = "desc";
})(OrderBy || (OrderBy = {}));

var RegistrationType;
(function (RegistrationType) {
    RegistrationType["New"] = "new";
    RegistrationType["Transfer"] = "transfer";
    RegistrationType["Renewal"] = "renewal";
    RegistrationType["Trade"] = "trade";
})(RegistrationType || (RegistrationType = {}));

var FilterType;
(function (FilterType) {
    FilterType["Premium"] = "premium";
    FilterType["Suggestion"] = "suggestion";
})(FilterType || (FilterType = {}));

var Runtime;
(function (Runtime) {
    Runtime["Node145"] = "node-14.5";
    Runtime["Node160"] = "node-16.0";
    Runtime["Node180"] = "node-18.0";
    Runtime["Node190"] = "node-19.0";
    Runtime["Node200"] = "node-20.0";
    Runtime["Node210"] = "node-21.0";
    Runtime["Node22"] = "node-22";
    Runtime["Node23"] = "node-23";
    Runtime["Node24"] = "node-24";
    Runtime["Node25"] = "node-25";
    Runtime["Php80"] = "php-8.0";
    Runtime["Php81"] = "php-8.1";
    Runtime["Php82"] = "php-8.2";
    Runtime["Php83"] = "php-8.3";
    Runtime["Php84"] = "php-8.4";
    Runtime["Ruby30"] = "ruby-3.0";
    Runtime["Ruby31"] = "ruby-3.1";
    Runtime["Ruby32"] = "ruby-3.2";
    Runtime["Ruby33"] = "ruby-3.3";
    Runtime["Ruby34"] = "ruby-3.4";
    Runtime["Ruby40"] = "ruby-4.0";
    Runtime["Python38"] = "python-3.8";
    Runtime["Python39"] = "python-3.9";
    Runtime["Python310"] = "python-3.10";
    Runtime["Python311"] = "python-3.11";
    Runtime["Python312"] = "python-3.12";
    Runtime["Python313"] = "python-3.13";
    Runtime["Python314"] = "python-3.14";
    Runtime["Pythonml311"] = "python-ml-3.11";
    Runtime["Pythonml312"] = "python-ml-3.12";
    Runtime["Pythonml313"] = "python-ml-3.13";
    Runtime["Deno121"] = "deno-1.21";
    Runtime["Deno124"] = "deno-1.24";
    Runtime["Deno135"] = "deno-1.35";
    Runtime["Deno140"] = "deno-1.40";
    Runtime["Deno146"] = "deno-1.46";
    Runtime["Deno20"] = "deno-2.0";
    Runtime["Deno25"] = "deno-2.5";
    Runtime["Deno26"] = "deno-2.6";
    Runtime["Dart215"] = "dart-2.15";
    Runtime["Dart216"] = "dart-2.16";
    Runtime["Dart217"] = "dart-2.17";
    Runtime["Dart218"] = "dart-2.18";
    Runtime["Dart219"] = "dart-2.19";
    Runtime["Dart30"] = "dart-3.0";
    Runtime["Dart31"] = "dart-3.1";
    Runtime["Dart33"] = "dart-3.3";
    Runtime["Dart35"] = "dart-3.5";
    Runtime["Dart38"] = "dart-3.8";
    Runtime["Dart39"] = "dart-3.9";
    Runtime["Dart310"] = "dart-3.10";
    Runtime["Dotnet60"] = "dotnet-6.0";
    Runtime["Dotnet70"] = "dotnet-7.0";
    Runtime["Dotnet80"] = "dotnet-8.0";
    Runtime["Dotnet10"] = "dotnet-10";
    Runtime["Java80"] = "java-8.0";
    Runtime["Java110"] = "java-11.0";
    Runtime["Java170"] = "java-17.0";
    Runtime["Java180"] = "java-18.0";
    Runtime["Java210"] = "java-21.0";
    Runtime["Java22"] = "java-22";
    Runtime["Java25"] = "java-25";
    Runtime["Swift55"] = "swift-5.5";
    Runtime["Swift58"] = "swift-5.8";
    Runtime["Swift59"] = "swift-5.9";
    Runtime["Swift510"] = "swift-5.10";
    Runtime["Swift62"] = "swift-6.2";
    Runtime["Kotlin16"] = "kotlin-1.6";
    Runtime["Kotlin18"] = "kotlin-1.8";
    Runtime["Kotlin19"] = "kotlin-1.9";
    Runtime["Kotlin20"] = "kotlin-2.0";
    Runtime["Kotlin23"] = "kotlin-2.3";
    Runtime["Cpp17"] = "cpp-17";
    Runtime["Cpp20"] = "cpp-20";
    Runtime["Bun10"] = "bun-1.0";
    Runtime["Bun11"] = "bun-1.1";
    Runtime["Bun12"] = "bun-1.2";
    Runtime["Bun13"] = "bun-1.3";
    Runtime["Go123"] = "go-1.23";
    Runtime["Go124"] = "go-1.24";
    Runtime["Go125"] = "go-1.25";
    Runtime["Go126"] = "go-1.26";
    Runtime["Static1"] = "static-1";
    Runtime["Flutter324"] = "flutter-3.24";
    Runtime["Flutter327"] = "flutter-3.27";
    Runtime["Flutter329"] = "flutter-3.29";
    Runtime["Flutter332"] = "flutter-3.32";
    Runtime["Flutter335"] = "flutter-3.35";
    Runtime["Flutter338"] = "flutter-3.38";
})(Runtime || (Runtime = {}));

var Runtimes;
(function (Runtimes) {
    Runtimes["Node145"] = "node-14.5";
    Runtimes["Node160"] = "node-16.0";
    Runtimes["Node180"] = "node-18.0";
    Runtimes["Node190"] = "node-19.0";
    Runtimes["Node200"] = "node-20.0";
    Runtimes["Node210"] = "node-21.0";
    Runtimes["Node22"] = "node-22";
    Runtimes["Node23"] = "node-23";
    Runtimes["Node24"] = "node-24";
    Runtimes["Node25"] = "node-25";
    Runtimes["Php80"] = "php-8.0";
    Runtimes["Php81"] = "php-8.1";
    Runtimes["Php82"] = "php-8.2";
    Runtimes["Php83"] = "php-8.3";
    Runtimes["Php84"] = "php-8.4";
    Runtimes["Ruby30"] = "ruby-3.0";
    Runtimes["Ruby31"] = "ruby-3.1";
    Runtimes["Ruby32"] = "ruby-3.2";
    Runtimes["Ruby33"] = "ruby-3.3";
    Runtimes["Ruby34"] = "ruby-3.4";
    Runtimes["Ruby40"] = "ruby-4.0";
    Runtimes["Python38"] = "python-3.8";
    Runtimes["Python39"] = "python-3.9";
    Runtimes["Python310"] = "python-3.10";
    Runtimes["Python311"] = "python-3.11";
    Runtimes["Python312"] = "python-3.12";
    Runtimes["Python313"] = "python-3.13";
    Runtimes["Python314"] = "python-3.14";
    Runtimes["Pythonml311"] = "python-ml-3.11";
    Runtimes["Pythonml312"] = "python-ml-3.12";
    Runtimes["Pythonml313"] = "python-ml-3.13";
    Runtimes["Deno121"] = "deno-1.21";
    Runtimes["Deno124"] = "deno-1.24";
    Runtimes["Deno135"] = "deno-1.35";
    Runtimes["Deno140"] = "deno-1.40";
    Runtimes["Deno146"] = "deno-1.46";
    Runtimes["Deno20"] = "deno-2.0";
    Runtimes["Deno25"] = "deno-2.5";
    Runtimes["Deno26"] = "deno-2.6";
    Runtimes["Dart215"] = "dart-2.15";
    Runtimes["Dart216"] = "dart-2.16";
    Runtimes["Dart217"] = "dart-2.17";
    Runtimes["Dart218"] = "dart-2.18";
    Runtimes["Dart219"] = "dart-2.19";
    Runtimes["Dart30"] = "dart-3.0";
    Runtimes["Dart31"] = "dart-3.1";
    Runtimes["Dart33"] = "dart-3.3";
    Runtimes["Dart35"] = "dart-3.5";
    Runtimes["Dart38"] = "dart-3.8";
    Runtimes["Dart39"] = "dart-3.9";
    Runtimes["Dart310"] = "dart-3.10";
    Runtimes["Dotnet60"] = "dotnet-6.0";
    Runtimes["Dotnet70"] = "dotnet-7.0";
    Runtimes["Dotnet80"] = "dotnet-8.0";
    Runtimes["Dotnet10"] = "dotnet-10";
    Runtimes["Java80"] = "java-8.0";
    Runtimes["Java110"] = "java-11.0";
    Runtimes["Java170"] = "java-17.0";
    Runtimes["Java180"] = "java-18.0";
    Runtimes["Java210"] = "java-21.0";
    Runtimes["Java22"] = "java-22";
    Runtimes["Java25"] = "java-25";
    Runtimes["Swift55"] = "swift-5.5";
    Runtimes["Swift58"] = "swift-5.8";
    Runtimes["Swift59"] = "swift-5.9";
    Runtimes["Swift510"] = "swift-5.10";
    Runtimes["Swift62"] = "swift-6.2";
    Runtimes["Kotlin16"] = "kotlin-1.6";
    Runtimes["Kotlin18"] = "kotlin-1.8";
    Runtimes["Kotlin19"] = "kotlin-1.9";
    Runtimes["Kotlin20"] = "kotlin-2.0";
    Runtimes["Kotlin23"] = "kotlin-2.3";
    Runtimes["Cpp17"] = "cpp-17";
    Runtimes["Cpp20"] = "cpp-20";
    Runtimes["Bun10"] = "bun-1.0";
    Runtimes["Bun11"] = "bun-1.1";
    Runtimes["Bun12"] = "bun-1.2";
    Runtimes["Bun13"] = "bun-1.3";
    Runtimes["Go123"] = "go-1.23";
    Runtimes["Go124"] = "go-1.24";
    Runtimes["Go125"] = "go-1.25";
    Runtimes["Go126"] = "go-1.26";
    Runtimes["Static1"] = "static-1";
    Runtimes["Flutter324"] = "flutter-3.24";
    Runtimes["Flutter327"] = "flutter-3.27";
    Runtimes["Flutter329"] = "flutter-3.29";
    Runtimes["Flutter332"] = "flutter-3.32";
    Runtimes["Flutter335"] = "flutter-3.35";
    Runtimes["Flutter338"] = "flutter-3.38";
})(Runtimes || (Runtimes = {}));

var UseCases;
(function (UseCases) {
    UseCases["Starter"] = "starter";
    UseCases["Databases"] = "databases";
    UseCases["Ai"] = "ai";
    UseCases["Messaging"] = "messaging";
    UseCases["Utilities"] = "utilities";
    UseCases["Devtools"] = "dev-tools";
    UseCases["Auth"] = "auth";
    UseCases["Portfolio"] = "portfolio";
    UseCases["Events"] = "events";
    UseCases["Ecommerce"] = "ecommerce";
    UseCases["Documentation"] = "documentation";
    UseCases["Blog"] = "blog";
    UseCases["Forms"] = "forms";
    UseCases["Dashboard"] = "dashboard";
})(UseCases || (UseCases = {}));

var TemplateReferenceType;
(function (TemplateReferenceType) {
    TemplateReferenceType["Commit"] = "commit";
    TemplateReferenceType["Branch"] = "branch";
    TemplateReferenceType["Tag"] = "tag";
})(TemplateReferenceType || (TemplateReferenceType = {}));

var VCSReferenceType;
(function (VCSReferenceType) {
    VCSReferenceType["Branch"] = "branch";
    VCSReferenceType["Commit"] = "commit";
    VCSReferenceType["Tag"] = "tag";
})(VCSReferenceType || (VCSReferenceType = {}));

var DeploymentDownloadType;
(function (DeploymentDownloadType) {
    DeploymentDownloadType["Source"] = "source";
    DeploymentDownloadType["Output"] = "output";
})(DeploymentDownloadType || (DeploymentDownloadType = {}));

var ExecutionMethod;
(function (ExecutionMethod) {
    ExecutionMethod["GET"] = "GET";
    ExecutionMethod["POST"] = "POST";
    ExecutionMethod["PUT"] = "PUT";
    ExecutionMethod["PATCH"] = "PATCH";
    ExecutionMethod["DELETE"] = "DELETE";
    ExecutionMethod["OPTIONS"] = "OPTIONS";
    ExecutionMethod["HEAD"] = "HEAD";
})(ExecutionMethod || (ExecutionMethod = {}));

var Name;
(function (Name) {
    Name["V1database"] = "v1-database";
    Name["V1deletes"] = "v1-deletes";
    Name["V1audits"] = "v1-audits";
    Name["V1mails"] = "v1-mails";
    Name["V1functions"] = "v1-functions";
    Name["V1statsresources"] = "v1-stats-resources";
    Name["V1statsusage"] = "v1-stats-usage";
    Name["V1webhooks"] = "v1-webhooks";
    Name["V1certificates"] = "v1-certificates";
    Name["V1builds"] = "v1-builds";
    Name["V1screenshots"] = "v1-screenshots";
    Name["V1messaging"] = "v1-messaging";
    Name["V1migrations"] = "v1-migrations";
})(Name || (Name = {}));

var MessagePriority;
(function (MessagePriority) {
    MessagePriority["Normal"] = "normal";
    MessagePriority["High"] = "high";
})(MessagePriority || (MessagePriority = {}));

var SmtpEncryption;
(function (SmtpEncryption) {
    SmtpEncryption["None"] = "none";
    SmtpEncryption["Ssl"] = "ssl";
    SmtpEncryption["Tls"] = "tls";
})(SmtpEncryption || (SmtpEncryption = {}));

var Resources;
(function (Resources) {
    Resources["User"] = "user";
    Resources["Team"] = "team";
    Resources["Membership"] = "membership";
    Resources["Database"] = "database";
    Resources["Table"] = "table";
    Resources["Column"] = "column";
    Resources["Index"] = "index";
    Resources["Row"] = "row";
    Resources["Document"] = "document";
    Resources["Attribute"] = "attribute";
    Resources["Collection"] = "collection";
    Resources["Bucket"] = "bucket";
    Resources["File"] = "file";
    Resources["Function"] = "function";
    Resources["Deployment"] = "deployment";
    Resources["Environmentvariable"] = "environment-variable";
    Resources["Site"] = "site";
    Resources["Sitedeployment"] = "site-deployment";
    Resources["Sitevariable"] = "site-variable";
})(Resources || (Resources = {}));

var ProjectUsageRange;
(function (ProjectUsageRange) {
    ProjectUsageRange["OneHour"] = "1h";
    ProjectUsageRange["OneDay"] = "1d";
})(ProjectUsageRange || (ProjectUsageRange = {}));

var Region;
(function (Region) {
    Region["Fra"] = "fra";
    Region["Nyc"] = "nyc";
    Region["Syd"] = "syd";
    Region["Sfo"] = "sfo";
    Region["Sgp"] = "sgp";
    Region["Tor"] = "tor";
})(Region || (Region = {}));

var Api;
(function (Api) {
    Api["Rest"] = "rest";
    Api["Graphql"] = "graphql";
    Api["Realtime"] = "realtime";
})(Api || (Api = {}));

var AuthMethod;
(function (AuthMethod) {
    AuthMethod["Emailpassword"] = "email-password";
    AuthMethod["Magicurl"] = "magic-url";
    AuthMethod["Emailotp"] = "email-otp";
    AuthMethod["Anonymous"] = "anonymous";
    AuthMethod["Invites"] = "invites";
    AuthMethod["Jwt"] = "jwt";
    AuthMethod["Phone"] = "phone";
})(AuthMethod || (AuthMethod = {}));

var PlatformType;
(function (PlatformType) {
    PlatformType["Web"] = "web";
    PlatformType["Flutterweb"] = "flutter-web";
    PlatformType["Flutterios"] = "flutter-ios";
    PlatformType["Flutterandroid"] = "flutter-android";
    PlatformType["Flutterlinux"] = "flutter-linux";
    PlatformType["Fluttermacos"] = "flutter-macos";
    PlatformType["Flutterwindows"] = "flutter-windows";
    PlatformType["Appleios"] = "apple-ios";
    PlatformType["Applemacos"] = "apple-macos";
    PlatformType["Applewatchos"] = "apple-watchos";
    PlatformType["Appletvos"] = "apple-tvos";
    PlatformType["Android"] = "android";
    PlatformType["Unity"] = "unity";
    PlatformType["Reactnativeios"] = "react-native-ios";
    PlatformType["Reactnativeandroid"] = "react-native-android";
})(PlatformType || (PlatformType = {}));

var ResourceType;
(function (ResourceType) {
    ResourceType["Function"] = "function";
    ResourceType["Execution"] = "execution";
    ResourceType["Message"] = "message";
    ResourceType["Backup"] = "backup";
})(ResourceType || (ResourceType = {}));

var ApiService;
(function (ApiService) {
    ApiService["Account"] = "account";
    ApiService["Avatars"] = "avatars";
    ApiService["Databases"] = "databases";
    ApiService["Tablesdb"] = "tablesdb";
    ApiService["Locale"] = "locale";
    ApiService["Health"] = "health";
    ApiService["Storage"] = "storage";
    ApiService["Teams"] = "teams";
    ApiService["Users"] = "users";
    ApiService["Sites"] = "sites";
    ApiService["Functions"] = "functions";
    ApiService["Graphql"] = "graphql";
    ApiService["Messaging"] = "messaging";
})(ApiService || (ApiService = {}));

var SMTPSecure;
(function (SMTPSecure) {
    SMTPSecure["Tls"] = "tls";
    SMTPSecure["Ssl"] = "ssl";
})(SMTPSecure || (SMTPSecure = {}));

var Status;
(function (Status) {
    Status["Active"] = "active";
})(Status || (Status = {}));

var EmailTemplateType;
(function (EmailTemplateType) {
    EmailTemplateType["Verification"] = "verification";
    EmailTemplateType["MagicSession"] = "magicSession";
    EmailTemplateType["Recovery"] = "recovery";
    EmailTemplateType["Invitation"] = "invitation";
    EmailTemplateType["MfaChallenge"] = "mfaChallenge";
    EmailTemplateType["SessionAlert"] = "sessionAlert";
    EmailTemplateType["OtpSession"] = "otpSession";
})(EmailTemplateType || (EmailTemplateType = {}));

var EmailTemplateLocale;
(function (EmailTemplateLocale) {
    EmailTemplateLocale["Af"] = "af";
    EmailTemplateLocale["Arae"] = "ar-ae";
    EmailTemplateLocale["Arbh"] = "ar-bh";
    EmailTemplateLocale["Ardz"] = "ar-dz";
    EmailTemplateLocale["Areg"] = "ar-eg";
    EmailTemplateLocale["Ariq"] = "ar-iq";
    EmailTemplateLocale["Arjo"] = "ar-jo";
    EmailTemplateLocale["Arkw"] = "ar-kw";
    EmailTemplateLocale["Arlb"] = "ar-lb";
    EmailTemplateLocale["Arly"] = "ar-ly";
    EmailTemplateLocale["Arma"] = "ar-ma";
    EmailTemplateLocale["Arom"] = "ar-om";
    EmailTemplateLocale["Arqa"] = "ar-qa";
    EmailTemplateLocale["Arsa"] = "ar-sa";
    EmailTemplateLocale["Arsy"] = "ar-sy";
    EmailTemplateLocale["Artn"] = "ar-tn";
    EmailTemplateLocale["Arye"] = "ar-ye";
    EmailTemplateLocale["As"] = "as";
    EmailTemplateLocale["Az"] = "az";
    EmailTemplateLocale["Be"] = "be";
    EmailTemplateLocale["Bg"] = "bg";
    EmailTemplateLocale["Bh"] = "bh";
    EmailTemplateLocale["Bn"] = "bn";
    EmailTemplateLocale["Bs"] = "bs";
    EmailTemplateLocale["Ca"] = "ca";
    EmailTemplateLocale["Cs"] = "cs";
    EmailTemplateLocale["Cy"] = "cy";
    EmailTemplateLocale["Da"] = "da";
    EmailTemplateLocale["De"] = "de";
    EmailTemplateLocale["Deat"] = "de-at";
    EmailTemplateLocale["Dech"] = "de-ch";
    EmailTemplateLocale["Deli"] = "de-li";
    EmailTemplateLocale["Delu"] = "de-lu";
    EmailTemplateLocale["El"] = "el";
    EmailTemplateLocale["En"] = "en";
    EmailTemplateLocale["Enau"] = "en-au";
    EmailTemplateLocale["Enbz"] = "en-bz";
    EmailTemplateLocale["Enca"] = "en-ca";
    EmailTemplateLocale["Engb"] = "en-gb";
    EmailTemplateLocale["Enie"] = "en-ie";
    EmailTemplateLocale["Enjm"] = "en-jm";
    EmailTemplateLocale["Ennz"] = "en-nz";
    EmailTemplateLocale["Entt"] = "en-tt";
    EmailTemplateLocale["Enus"] = "en-us";
    EmailTemplateLocale["Enza"] = "en-za";
    EmailTemplateLocale["Eo"] = "eo";
    EmailTemplateLocale["Es"] = "es";
    EmailTemplateLocale["Esar"] = "es-ar";
    EmailTemplateLocale["Esbo"] = "es-bo";
    EmailTemplateLocale["Escl"] = "es-cl";
    EmailTemplateLocale["Esco"] = "es-co";
    EmailTemplateLocale["Escr"] = "es-cr";
    EmailTemplateLocale["Esdo"] = "es-do";
    EmailTemplateLocale["Esec"] = "es-ec";
    EmailTemplateLocale["Esgt"] = "es-gt";
    EmailTemplateLocale["Eshn"] = "es-hn";
    EmailTemplateLocale["Esmx"] = "es-mx";
    EmailTemplateLocale["Esni"] = "es-ni";
    EmailTemplateLocale["Espa"] = "es-pa";
    EmailTemplateLocale["Espe"] = "es-pe";
    EmailTemplateLocale["Espr"] = "es-pr";
    EmailTemplateLocale["Espy"] = "es-py";
    EmailTemplateLocale["Essv"] = "es-sv";
    EmailTemplateLocale["Esuy"] = "es-uy";
    EmailTemplateLocale["Esve"] = "es-ve";
    EmailTemplateLocale["Et"] = "et";
    EmailTemplateLocale["Eu"] = "eu";
    EmailTemplateLocale["Fa"] = "fa";
    EmailTemplateLocale["Fi"] = "fi";
    EmailTemplateLocale["Fo"] = "fo";
    EmailTemplateLocale["Fr"] = "fr";
    EmailTemplateLocale["Frbe"] = "fr-be";
    EmailTemplateLocale["Frca"] = "fr-ca";
    EmailTemplateLocale["Frch"] = "fr-ch";
    EmailTemplateLocale["Frlu"] = "fr-lu";
    EmailTemplateLocale["Ga"] = "ga";
    EmailTemplateLocale["Gd"] = "gd";
    EmailTemplateLocale["He"] = "he";
    EmailTemplateLocale["Hi"] = "hi";
    EmailTemplateLocale["Hr"] = "hr";
    EmailTemplateLocale["Hu"] = "hu";
    EmailTemplateLocale["Id"] = "id";
    EmailTemplateLocale["Is"] = "is";
    EmailTemplateLocale["It"] = "it";
    EmailTemplateLocale["Itch"] = "it-ch";
    EmailTemplateLocale["Ja"] = "ja";
    EmailTemplateLocale["Ji"] = "ji";
    EmailTemplateLocale["Ko"] = "ko";
    EmailTemplateLocale["Ku"] = "ku";
    EmailTemplateLocale["Lt"] = "lt";
    EmailTemplateLocale["Lv"] = "lv";
    EmailTemplateLocale["Mk"] = "mk";
    EmailTemplateLocale["Ml"] = "ml";
    EmailTemplateLocale["Ms"] = "ms";
    EmailTemplateLocale["Mt"] = "mt";
    EmailTemplateLocale["Nb"] = "nb";
    EmailTemplateLocale["Ne"] = "ne";
    EmailTemplateLocale["Nl"] = "nl";
    EmailTemplateLocale["Nlbe"] = "nl-be";
    EmailTemplateLocale["Nn"] = "nn";
    EmailTemplateLocale["No"] = "no";
    EmailTemplateLocale["Pa"] = "pa";
    EmailTemplateLocale["Pl"] = "pl";
    EmailTemplateLocale["Pt"] = "pt";
    EmailTemplateLocale["Ptbr"] = "pt-br";
    EmailTemplateLocale["Rm"] = "rm";
    EmailTemplateLocale["Ro"] = "ro";
    EmailTemplateLocale["Romd"] = "ro-md";
    EmailTemplateLocale["Ru"] = "ru";
    EmailTemplateLocale["Rumd"] = "ru-md";
    EmailTemplateLocale["Sb"] = "sb";
    EmailTemplateLocale["Sk"] = "sk";
    EmailTemplateLocale["Sl"] = "sl";
    EmailTemplateLocale["Sq"] = "sq";
    EmailTemplateLocale["Sr"] = "sr";
    EmailTemplateLocale["Sv"] = "sv";
    EmailTemplateLocale["Svfi"] = "sv-fi";
    EmailTemplateLocale["Th"] = "th";
    EmailTemplateLocale["Tn"] = "tn";
    EmailTemplateLocale["Tr"] = "tr";
    EmailTemplateLocale["Ts"] = "ts";
    EmailTemplateLocale["Ua"] = "ua";
    EmailTemplateLocale["Ur"] = "ur";
    EmailTemplateLocale["Ve"] = "ve";
    EmailTemplateLocale["Vi"] = "vi";
    EmailTemplateLocale["Xh"] = "xh";
    EmailTemplateLocale["Zhcn"] = "zh-cn";
    EmailTemplateLocale["Zhhk"] = "zh-hk";
    EmailTemplateLocale["Zhsg"] = "zh-sg";
    EmailTemplateLocale["Zhtw"] = "zh-tw";
    EmailTemplateLocale["Zu"] = "zu";
})(EmailTemplateLocale || (EmailTemplateLocale = {}));

var SmsTemplateType;
(function (SmsTemplateType) {
    SmsTemplateType["Verification"] = "verification";
    SmsTemplateType["Login"] = "login";
    SmsTemplateType["Invitation"] = "invitation";
    SmsTemplateType["MfaChallenge"] = "mfaChallenge";
})(SmsTemplateType || (SmsTemplateType = {}));

var SmsTemplateLocale;
(function (SmsTemplateLocale) {
    SmsTemplateLocale["Af"] = "af";
    SmsTemplateLocale["Arae"] = "ar-ae";
    SmsTemplateLocale["Arbh"] = "ar-bh";
    SmsTemplateLocale["Ardz"] = "ar-dz";
    SmsTemplateLocale["Areg"] = "ar-eg";
    SmsTemplateLocale["Ariq"] = "ar-iq";
    SmsTemplateLocale["Arjo"] = "ar-jo";
    SmsTemplateLocale["Arkw"] = "ar-kw";
    SmsTemplateLocale["Arlb"] = "ar-lb";
    SmsTemplateLocale["Arly"] = "ar-ly";
    SmsTemplateLocale["Arma"] = "ar-ma";
    SmsTemplateLocale["Arom"] = "ar-om";
    SmsTemplateLocale["Arqa"] = "ar-qa";
    SmsTemplateLocale["Arsa"] = "ar-sa";
    SmsTemplateLocale["Arsy"] = "ar-sy";
    SmsTemplateLocale["Artn"] = "ar-tn";
    SmsTemplateLocale["Arye"] = "ar-ye";
    SmsTemplateLocale["As"] = "as";
    SmsTemplateLocale["Az"] = "az";
    SmsTemplateLocale["Be"] = "be";
    SmsTemplateLocale["Bg"] = "bg";
    SmsTemplateLocale["Bh"] = "bh";
    SmsTemplateLocale["Bn"] = "bn";
    SmsTemplateLocale["Bs"] = "bs";
    SmsTemplateLocale["Ca"] = "ca";
    SmsTemplateLocale["Cs"] = "cs";
    SmsTemplateLocale["Cy"] = "cy";
    SmsTemplateLocale["Da"] = "da";
    SmsTemplateLocale["De"] = "de";
    SmsTemplateLocale["Deat"] = "de-at";
    SmsTemplateLocale["Dech"] = "de-ch";
    SmsTemplateLocale["Deli"] = "de-li";
    SmsTemplateLocale["Delu"] = "de-lu";
    SmsTemplateLocale["El"] = "el";
    SmsTemplateLocale["En"] = "en";
    SmsTemplateLocale["Enau"] = "en-au";
    SmsTemplateLocale["Enbz"] = "en-bz";
    SmsTemplateLocale["Enca"] = "en-ca";
    SmsTemplateLocale["Engb"] = "en-gb";
    SmsTemplateLocale["Enie"] = "en-ie";
    SmsTemplateLocale["Enjm"] = "en-jm";
    SmsTemplateLocale["Ennz"] = "en-nz";
    SmsTemplateLocale["Entt"] = "en-tt";
    SmsTemplateLocale["Enus"] = "en-us";
    SmsTemplateLocale["Enza"] = "en-za";
    SmsTemplateLocale["Eo"] = "eo";
    SmsTemplateLocale["Es"] = "es";
    SmsTemplateLocale["Esar"] = "es-ar";
    SmsTemplateLocale["Esbo"] = "es-bo";
    SmsTemplateLocale["Escl"] = "es-cl";
    SmsTemplateLocale["Esco"] = "es-co";
    SmsTemplateLocale["Escr"] = "es-cr";
    SmsTemplateLocale["Esdo"] = "es-do";
    SmsTemplateLocale["Esec"] = "es-ec";
    SmsTemplateLocale["Esgt"] = "es-gt";
    SmsTemplateLocale["Eshn"] = "es-hn";
    SmsTemplateLocale["Esmx"] = "es-mx";
    SmsTemplateLocale["Esni"] = "es-ni";
    SmsTemplateLocale["Espa"] = "es-pa";
    SmsTemplateLocale["Espe"] = "es-pe";
    SmsTemplateLocale["Espr"] = "es-pr";
    SmsTemplateLocale["Espy"] = "es-py";
    SmsTemplateLocale["Essv"] = "es-sv";
    SmsTemplateLocale["Esuy"] = "es-uy";
    SmsTemplateLocale["Esve"] = "es-ve";
    SmsTemplateLocale["Et"] = "et";
    SmsTemplateLocale["Eu"] = "eu";
    SmsTemplateLocale["Fa"] = "fa";
    SmsTemplateLocale["Fi"] = "fi";
    SmsTemplateLocale["Fo"] = "fo";
    SmsTemplateLocale["Fr"] = "fr";
    SmsTemplateLocale["Frbe"] = "fr-be";
    SmsTemplateLocale["Frca"] = "fr-ca";
    SmsTemplateLocale["Frch"] = "fr-ch";
    SmsTemplateLocale["Frlu"] = "fr-lu";
    SmsTemplateLocale["Ga"] = "ga";
    SmsTemplateLocale["Gd"] = "gd";
    SmsTemplateLocale["He"] = "he";
    SmsTemplateLocale["Hi"] = "hi";
    SmsTemplateLocale["Hr"] = "hr";
    SmsTemplateLocale["Hu"] = "hu";
    SmsTemplateLocale["Id"] = "id";
    SmsTemplateLocale["Is"] = "is";
    SmsTemplateLocale["It"] = "it";
    SmsTemplateLocale["Itch"] = "it-ch";
    SmsTemplateLocale["Ja"] = "ja";
    SmsTemplateLocale["Ji"] = "ji";
    SmsTemplateLocale["Ko"] = "ko";
    SmsTemplateLocale["Ku"] = "ku";
    SmsTemplateLocale["Lt"] = "lt";
    SmsTemplateLocale["Lv"] = "lv";
    SmsTemplateLocale["Mk"] = "mk";
    SmsTemplateLocale["Ml"] = "ml";
    SmsTemplateLocale["Ms"] = "ms";
    SmsTemplateLocale["Mt"] = "mt";
    SmsTemplateLocale["Nb"] = "nb";
    SmsTemplateLocale["Ne"] = "ne";
    SmsTemplateLocale["Nl"] = "nl";
    SmsTemplateLocale["Nlbe"] = "nl-be";
    SmsTemplateLocale["Nn"] = "nn";
    SmsTemplateLocale["No"] = "no";
    SmsTemplateLocale["Pa"] = "pa";
    SmsTemplateLocale["Pl"] = "pl";
    SmsTemplateLocale["Pt"] = "pt";
    SmsTemplateLocale["Ptbr"] = "pt-br";
    SmsTemplateLocale["Rm"] = "rm";
    SmsTemplateLocale["Ro"] = "ro";
    SmsTemplateLocale["Romd"] = "ro-md";
    SmsTemplateLocale["Ru"] = "ru";
    SmsTemplateLocale["Rumd"] = "ru-md";
    SmsTemplateLocale["Sb"] = "sb";
    SmsTemplateLocale["Sk"] = "sk";
    SmsTemplateLocale["Sl"] = "sl";
    SmsTemplateLocale["Sq"] = "sq";
    SmsTemplateLocale["Sr"] = "sr";
    SmsTemplateLocale["Sv"] = "sv";
    SmsTemplateLocale["Svfi"] = "sv-fi";
    SmsTemplateLocale["Th"] = "th";
    SmsTemplateLocale["Tn"] = "tn";
    SmsTemplateLocale["Tr"] = "tr";
    SmsTemplateLocale["Ts"] = "ts";
    SmsTemplateLocale["Ua"] = "ua";
    SmsTemplateLocale["Ur"] = "ur";
    SmsTemplateLocale["Ve"] = "ve";
    SmsTemplateLocale["Vi"] = "vi";
    SmsTemplateLocale["Xh"] = "xh";
    SmsTemplateLocale["Zhcn"] = "zh-cn";
    SmsTemplateLocale["Zhhk"] = "zh-hk";
    SmsTemplateLocale["Zhsg"] = "zh-sg";
    SmsTemplateLocale["Zhtw"] = "zh-tw";
    SmsTemplateLocale["Zu"] = "zu";
})(SmsTemplateLocale || (SmsTemplateLocale = {}));

var StatusCode;
(function (StatusCode) {
    StatusCode["MovedPermanently301"] = "301";
    StatusCode["Found302"] = "302";
    StatusCode["TemporaryRedirect307"] = "307";
    StatusCode["PermanentRedirect308"] = "308";
})(StatusCode || (StatusCode = {}));

var ProxyResourceType;
(function (ProxyResourceType) {
    ProxyResourceType["Site"] = "site";
    ProxyResourceType["Function"] = "function";
})(ProxyResourceType || (ProxyResourceType = {}));

var Framework;
(function (Framework) {
    Framework["Analog"] = "analog";
    Framework["Angular"] = "angular";
    Framework["Nextjs"] = "nextjs";
    Framework["React"] = "react";
    Framework["Nuxt"] = "nuxt";
    Framework["Vue"] = "vue";
    Framework["Sveltekit"] = "sveltekit";
    Framework["Astro"] = "astro";
    Framework["Tanstackstart"] = "tanstack-start";
    Framework["Remix"] = "remix";
    Framework["Lynx"] = "lynx";
    Framework["Flutter"] = "flutter";
    Framework["Reactnative"] = "react-native";
    Framework["Vite"] = "vite";
    Framework["Other"] = "other";
})(Framework || (Framework = {}));

var BuildRuntime;
(function (BuildRuntime) {
    BuildRuntime["Node145"] = "node-14.5";
    BuildRuntime["Node160"] = "node-16.0";
    BuildRuntime["Node180"] = "node-18.0";
    BuildRuntime["Node190"] = "node-19.0";
    BuildRuntime["Node200"] = "node-20.0";
    BuildRuntime["Node210"] = "node-21.0";
    BuildRuntime["Node22"] = "node-22";
    BuildRuntime["Node23"] = "node-23";
    BuildRuntime["Node24"] = "node-24";
    BuildRuntime["Node25"] = "node-25";
    BuildRuntime["Php80"] = "php-8.0";
    BuildRuntime["Php81"] = "php-8.1";
    BuildRuntime["Php82"] = "php-8.2";
    BuildRuntime["Php83"] = "php-8.3";
    BuildRuntime["Php84"] = "php-8.4";
    BuildRuntime["Ruby30"] = "ruby-3.0";
    BuildRuntime["Ruby31"] = "ruby-3.1";
    BuildRuntime["Ruby32"] = "ruby-3.2";
    BuildRuntime["Ruby33"] = "ruby-3.3";
    BuildRuntime["Ruby34"] = "ruby-3.4";
    BuildRuntime["Ruby40"] = "ruby-4.0";
    BuildRuntime["Python38"] = "python-3.8";
    BuildRuntime["Python39"] = "python-3.9";
    BuildRuntime["Python310"] = "python-3.10";
    BuildRuntime["Python311"] = "python-3.11";
    BuildRuntime["Python312"] = "python-3.12";
    BuildRuntime["Python313"] = "python-3.13";
    BuildRuntime["Python314"] = "python-3.14";
    BuildRuntime["Pythonml311"] = "python-ml-3.11";
    BuildRuntime["Pythonml312"] = "python-ml-3.12";
    BuildRuntime["Pythonml313"] = "python-ml-3.13";
    BuildRuntime["Deno121"] = "deno-1.21";
    BuildRuntime["Deno124"] = "deno-1.24";
    BuildRuntime["Deno135"] = "deno-1.35";
    BuildRuntime["Deno140"] = "deno-1.40";
    BuildRuntime["Deno146"] = "deno-1.46";
    BuildRuntime["Deno20"] = "deno-2.0";
    BuildRuntime["Deno25"] = "deno-2.5";
    BuildRuntime["Deno26"] = "deno-2.6";
    BuildRuntime["Dart215"] = "dart-2.15";
    BuildRuntime["Dart216"] = "dart-2.16";
    BuildRuntime["Dart217"] = "dart-2.17";
    BuildRuntime["Dart218"] = "dart-2.18";
    BuildRuntime["Dart219"] = "dart-2.19";
    BuildRuntime["Dart30"] = "dart-3.0";
    BuildRuntime["Dart31"] = "dart-3.1";
    BuildRuntime["Dart33"] = "dart-3.3";
    BuildRuntime["Dart35"] = "dart-3.5";
    BuildRuntime["Dart38"] = "dart-3.8";
    BuildRuntime["Dart39"] = "dart-3.9";
    BuildRuntime["Dart310"] = "dart-3.10";
    BuildRuntime["Dotnet60"] = "dotnet-6.0";
    BuildRuntime["Dotnet70"] = "dotnet-7.0";
    BuildRuntime["Dotnet80"] = "dotnet-8.0";
    BuildRuntime["Dotnet10"] = "dotnet-10";
    BuildRuntime["Java80"] = "java-8.0";
    BuildRuntime["Java110"] = "java-11.0";
    BuildRuntime["Java170"] = "java-17.0";
    BuildRuntime["Java180"] = "java-18.0";
    BuildRuntime["Java210"] = "java-21.0";
    BuildRuntime["Java22"] = "java-22";
    BuildRuntime["Java25"] = "java-25";
    BuildRuntime["Swift55"] = "swift-5.5";
    BuildRuntime["Swift58"] = "swift-5.8";
    BuildRuntime["Swift59"] = "swift-5.9";
    BuildRuntime["Swift510"] = "swift-5.10";
    BuildRuntime["Swift62"] = "swift-6.2";
    BuildRuntime["Kotlin16"] = "kotlin-1.6";
    BuildRuntime["Kotlin18"] = "kotlin-1.8";
    BuildRuntime["Kotlin19"] = "kotlin-1.9";
    BuildRuntime["Kotlin20"] = "kotlin-2.0";
    BuildRuntime["Kotlin23"] = "kotlin-2.3";
    BuildRuntime["Cpp17"] = "cpp-17";
    BuildRuntime["Cpp20"] = "cpp-20";
    BuildRuntime["Bun10"] = "bun-1.0";
    BuildRuntime["Bun11"] = "bun-1.1";
    BuildRuntime["Bun12"] = "bun-1.2";
    BuildRuntime["Bun13"] = "bun-1.3";
    BuildRuntime["Go123"] = "go-1.23";
    BuildRuntime["Go124"] = "go-1.24";
    BuildRuntime["Go125"] = "go-1.25";
    BuildRuntime["Go126"] = "go-1.26";
    BuildRuntime["Static1"] = "static-1";
    BuildRuntime["Flutter324"] = "flutter-3.24";
    BuildRuntime["Flutter327"] = "flutter-3.27";
    BuildRuntime["Flutter329"] = "flutter-3.29";
    BuildRuntime["Flutter332"] = "flutter-3.32";
    BuildRuntime["Flutter335"] = "flutter-3.35";
    BuildRuntime["Flutter338"] = "flutter-3.38";
})(BuildRuntime || (BuildRuntime = {}));

var Adapter;
(function (Adapter) {
    Adapter["Static"] = "static";
    Adapter["Ssr"] = "ssr";
})(Adapter || (Adapter = {}));

var Frameworks;
(function (Frameworks) {
    Frameworks["Analog"] = "analog";
    Frameworks["Angular"] = "angular";
    Frameworks["Nextjs"] = "nextjs";
    Frameworks["React"] = "react";
    Frameworks["Nuxt"] = "nuxt";
    Frameworks["Vue"] = "vue";
    Frameworks["Sveltekit"] = "sveltekit";
    Frameworks["Astro"] = "astro";
    Frameworks["Tanstackstart"] = "tanstack-start";
    Frameworks["Remix"] = "remix";
    Frameworks["Lynx"] = "lynx";
    Frameworks["Flutter"] = "flutter";
    Frameworks["Reactnative"] = "react-native";
    Frameworks["Vite"] = "vite";
    Frameworks["Other"] = "other";
})(Frameworks || (Frameworks = {}));

var Compression;
(function (Compression) {
    Compression["None"] = "none";
    Compression["Gzip"] = "gzip";
    Compression["Zstd"] = "zstd";
})(Compression || (Compression = {}));

var ImageGravity;
(function (ImageGravity) {
    ImageGravity["Center"] = "center";
    ImageGravity["Topleft"] = "top-left";
    ImageGravity["Top"] = "top";
    ImageGravity["Topright"] = "top-right";
    ImageGravity["Left"] = "left";
    ImageGravity["Right"] = "right";
    ImageGravity["Bottomleft"] = "bottom-left";
    ImageGravity["Bottom"] = "bottom";
    ImageGravity["Bottomright"] = "bottom-right";
})(ImageGravity || (ImageGravity = {}));

var PasswordHash;
(function (PasswordHash) {
    PasswordHash["Sha1"] = "sha1";
    PasswordHash["Sha224"] = "sha224";
    PasswordHash["Sha256"] = "sha256";
    PasswordHash["Sha384"] = "sha384";
    PasswordHash["Sha512224"] = "sha512/224";
    PasswordHash["Sha512256"] = "sha512/256";
    PasswordHash["Sha512"] = "sha512";
    PasswordHash["Sha3224"] = "sha3-224";
    PasswordHash["Sha3256"] = "sha3-256";
    PasswordHash["Sha3384"] = "sha3-384";
    PasswordHash["Sha3512"] = "sha3-512";
})(PasswordHash || (PasswordHash = {}));

var MessagingProviderType;
(function (MessagingProviderType) {
    MessagingProviderType["Email"] = "email";
    MessagingProviderType["Sms"] = "sms";
    MessagingProviderType["Push"] = "push";
})(MessagingProviderType || (MessagingProviderType = {}));

var VCSDetectionType;
(function (VCSDetectionType) {
    VCSDetectionType["Runtime"] = "runtime";
    VCSDetectionType["Framework"] = "framework";
})(VCSDetectionType || (VCSDetectionType = {}));

var DatabaseType;
(function (DatabaseType) {
    DatabaseType["Legacy"] = "legacy";
    DatabaseType["Tablesdb"] = "tablesdb";
})(DatabaseType || (DatabaseType = {}));

var AttributeStatus;
(function (AttributeStatus) {
    AttributeStatus["Available"] = "available";
    AttributeStatus["Processing"] = "processing";
    AttributeStatus["Deleting"] = "deleting";
    AttributeStatus["Stuck"] = "stuck";
    AttributeStatus["Failed"] = "failed";
})(AttributeStatus || (AttributeStatus = {}));

var ColumnStatus;
(function (ColumnStatus) {
    ColumnStatus["Available"] = "available";
    ColumnStatus["Processing"] = "processing";
    ColumnStatus["Deleting"] = "deleting";
    ColumnStatus["Stuck"] = "stuck";
    ColumnStatus["Failed"] = "failed";
})(ColumnStatus || (ColumnStatus = {}));

var IndexStatus;
(function (IndexStatus) {
    IndexStatus["Available"] = "available";
    IndexStatus["Processing"] = "processing";
    IndexStatus["Deleting"] = "deleting";
    IndexStatus["Stuck"] = "stuck";
    IndexStatus["Failed"] = "failed";
})(IndexStatus || (IndexStatus = {}));

var DeploymentStatus;
(function (DeploymentStatus) {
    DeploymentStatus["Waiting"] = "waiting";
    DeploymentStatus["Processing"] = "processing";
    DeploymentStatus["Building"] = "building";
    DeploymentStatus["Ready"] = "ready";
    DeploymentStatus["Canceled"] = "canceled";
    DeploymentStatus["Failed"] = "failed";
})(DeploymentStatus || (DeploymentStatus = {}));

var ExecutionTrigger;
(function (ExecutionTrigger) {
    ExecutionTrigger["Http"] = "http";
    ExecutionTrigger["Schedule"] = "schedule";
    ExecutionTrigger["Event"] = "event";
})(ExecutionTrigger || (ExecutionTrigger = {}));

var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus["Waiting"] = "waiting";
    ExecutionStatus["Processing"] = "processing";
    ExecutionStatus["Completed"] = "completed";
    ExecutionStatus["Failed"] = "failed";
    ExecutionStatus["Scheduled"] = "scheduled";
})(ExecutionStatus || (ExecutionStatus = {}));

var HealthAntivirusStatus;
(function (HealthAntivirusStatus) {
    HealthAntivirusStatus["Disabled"] = "disabled";
    HealthAntivirusStatus["Offline"] = "offline";
    HealthAntivirusStatus["Online"] = "online";
})(HealthAntivirusStatus || (HealthAntivirusStatus = {}));

var HealthCheckStatus;
(function (HealthCheckStatus) {
    HealthCheckStatus["Pass"] = "pass";
    HealthCheckStatus["Fail"] = "fail";
})(HealthCheckStatus || (HealthCheckStatus = {}));

var ProxyRuleDeploymentResourceType;
(function (ProxyRuleDeploymentResourceType) {
    ProxyRuleDeploymentResourceType["Function"] = "function";
    ProxyRuleDeploymentResourceType["Site"] = "site";
})(ProxyRuleDeploymentResourceType || (ProxyRuleDeploymentResourceType = {}));

var ProxyRuleStatus;
(function (ProxyRuleStatus) {
    ProxyRuleStatus["Created"] = "created";
    ProxyRuleStatus["Verifying"] = "verifying";
    ProxyRuleStatus["Verified"] = "verified";
    ProxyRuleStatus["Unverified"] = "unverified";
})(ProxyRuleStatus || (ProxyRuleStatus = {}));

var MessageStatus;
(function (MessageStatus) {
    MessageStatus["Draft"] = "draft";
    MessageStatus["Processing"] = "processing";
    MessageStatus["Scheduled"] = "scheduled";
    MessageStatus["Sent"] = "sent";
    MessageStatus["Failed"] = "failed";
})(MessageStatus || (MessageStatus = {}));

var BillingPlanGroup;
(function (BillingPlanGroup) {
    BillingPlanGroup["Starter"] = "starter";
    BillingPlanGroup["Pro"] = "pro";
    BillingPlanGroup["Scale"] = "scale";
})(BillingPlanGroup || (BillingPlanGroup = {}));

export { Account, Activities, Adapter, Api, ApiService, AppwriteException, Assistant, AttributeStatus, AuthMethod, AuthenticationFactor, AuthenticatorType, Avatars, BackupServices, Backups, BillingPlanGroup, Browser, BrowserPermission, BuildRuntime, Channel, Client, ColumnStatus, Compression, Condition, Console, ConsoleResourceType, CreditCard, DatabaseType, Databases, DeploymentDownloadType, DeploymentStatus, Domains, EmailTemplateLocale, EmailTemplateType, ExecutionMethod, ExecutionStatus, ExecutionTrigger, FilterType, Flag, Framework, Frameworks, Functions, Graphql, Health, HealthAntivirusStatus, HealthCheckStatus, ID, ImageFormat, ImageGravity, IndexStatus, IndexType, Locale, MessagePriority, MessageStatus, Messaging, MessagingProviderType, Migrations, Name, OAuthProvider, Operator, OrderBy, Organizations, PasswordHash, Permission, Platform, PlatformType, Project, ProjectUsageRange, Projects, Proxy, ProxyResourceType, ProxyRuleDeploymentResourceType, ProxyRuleStatus, Query, Realtime, Region, RegistrationType, RelationMutate, RelationshipType, ResourceType, Resources, Role, Runtime, Runtimes, SMTPSecure, Scopes, Sites, SmsTemplateLocale, SmsTemplateType, SmtpEncryption, Status, StatusCode, Storage, TablesDB, Teams, TemplateReferenceType, Theme, Timezone, Tokens, UsageRange, UseCases, Users, VCSDetectionType, VCSReferenceType, Vcs };
//# sourceMappingURL=sdk.js.map
